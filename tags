!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Rust	C,constant	/A constant/
!_TAG_KIND_DESCRIPTION!Rust	M,macro	/Macro Definition/
!_TAG_KIND_DESCRIPTION!Rust	P,method	/A method/
!_TAG_KIND_DESCRIPTION!Rust	c,implementation	/implementation/
!_TAG_KIND_DESCRIPTION!Rust	e,enumerator	/An enum variant/
!_TAG_KIND_DESCRIPTION!Rust	f,function	/Function/
!_TAG_KIND_DESCRIPTION!Rust	g,enum	/Enum/
!_TAG_KIND_DESCRIPTION!Rust	i,interface	/trait interface/
!_TAG_KIND_DESCRIPTION!Rust	m,field	/A struct field/
!_TAG_KIND_DESCRIPTION!Rust	n,module	/module/
!_TAG_KIND_DESCRIPTION!Rust	s,struct	/structural type/
!_TAG_KIND_DESCRIPTION!Rust	t,typedef	/Type Alias/
!_TAG_KIND_DESCRIPTION!Rust	v,variable	/Global variable/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!Rust	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/Users/jackmazac/Desktop/zephyr/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/7b085e7ad/
Abstain	src/api/models/request/governance_request.rs	/^    Abstain,$/;"	e	enum:VoteType
Abstain	src/chain/governance/voting.rs	/^    Abstain,$/;"	e	enum:VoteType
Accepted	src/api/models/request/governance_request.rs	/^    Accepted,$/;"	e	enum:ProposalStatus
AccessControl	src/secure_core/access_control.rs	/^impl AccessControl {$/;"	c
AccessControl	src/secure_core/access_control.rs	/^pub struct AccessControl {$/;"	s
Account	src/chain/state/account.rs	/^impl Account {$/;"	c
Account	src/chain/state/account.rs	/^impl Default for Account {$/;"	c
Account	src/chain/state/account.rs	/^pub struct Account {$/;"	s
AccuracyBenchmark	src/hdcmodels/benchmark.rs	/^impl AccuracyBenchmark {$/;"	c
AccuracyBenchmark	src/hdcmodels/benchmark.rs	/^pub struct AccuracyBenchmark {$/;"	s
Active	src/chain/governance/proposal.rs	/^    Active,$/;"	e	enum:ProposalStatus
Add	src/smart_contract/types.rs	/^    Add,$/;"	e	enum:BinaryOperator
Add	src/zkp/constraint_system.rs	/^    Add(Box<Expression>, Box<Expression>),$/;"	e	enum:Expression
AddTransactionError	src/chain/sharding.rs	/^    AddTransactionError(u64, String),$/;"	e	enum:ShardingError
Address	src/types/address.rs	/^impl Address {$/;"	c
Address	src/types/address.rs	/^impl fmt::Display for Address {$/;"	c
Address	src/types/address.rs	/^pub struct Address(pub Vec<u8>);$/;"	s
AddressAlreadyInUse	src/error_handling/network_error.rs	/^    AddressAlreadyInUse(String),$/;"	e	enum:NetworkError
AddressError	src/types/address.rs	/^pub enum AddressError {$/;"	g
AdjustedTransaction	src/chain/state_channel.rs	/^    AdjustedTransaction(OffChainTransaction),$/;"	e	enum:DisputeResolution
Admin	src/api/middleware/authentication.rs	/^    Admin,$/;"	e	enum:Role
Admin	src/secure_core/access_control.rs	/^    Admin,$/;"	e	enum:Role
AggregatedModel	src/hdcmodels/distributed_training/distributed_framework.rs	/^    AggregatedModel(Vec<Vec<f64>>),$/;"	e	enum:DistributedTrainingMessage
And	src/smart_contract/types.rs	/^    And,$/;"	e	enum:BinaryOperator
Arbitration	src/chain/state_channel.rs	/^pub struct Arbitration {$/;"	s
ArbitrationStatus	src/chain/state_channel.rs	/^pub enum ArbitrationStatus {$/;"	g
Array	src/smart_contract/types.rs	/^    Array(Vec<Value>),$/;"	e	enum:Value
AuthenticatedUser	src/api/middleware/authentication.rs	/^impl AuthenticatedUser {$/;"	c
AuthenticatedUser	src/api/middleware/authentication.rs	/^impl FromRequest for AuthenticatedUser {$/;"	c
AuthenticatedUser	src/api/middleware/authentication.rs	/^pub struct AuthenticatedUser {$/;"	s
AuthenticationFailed	src/error_handling/network_error.rs	/^    AuthenticationFailed,$/;"	e	enum:NetworkError
AuthorizationMiddleware	src/api/middleware/authorization.rs	/^impl AuthorizationMiddleware {$/;"	c
AuthorizationMiddleware	src/api/middleware/authorization.rs	/^impl<S, B> Transform<S> for AuthorizationMiddleware$/;"	c
AuthorizationMiddleware	src/api/middleware/authorization.rs	/^pub struct AuthorizationMiddleware {$/;"	s
AuthorizationMiddlewareMiddleware	src/api/middleware/authorization.rs	/^impl<S, B> Service for AuthorizationMiddlewareMiddleware<S>$/;"	c
AuthorizationMiddlewareMiddleware	src/api/middleware/authorization.rs	/^pub struct AuthorizationMiddlewareMiddleware<S> {$/;"	s
BACKUP_KEY_STORAGE_PATH	src/secure_core/secure_vault.rs	/^    const BACKUP_KEY_STORAGE_PATH: &'static str = "\/path\/to\/secure\/backup\/location";$/;"	C	implementation:SecureVault
BalanceManager	src/utils/indexing.rs	/^impl BalanceManager {$/;"	c
BalanceManager	src/utils/indexing.rs	/^pub struct BalanceManager {$/;"	s
BanPeerRequest	src/api/models/request/network_request.rs	/^pub struct BanPeerRequest {$/;"	s
BaseElement	src/utils/fft.rs	/^type BaseElement = f64;$/;"	t
BaseField	src/zephyrchain_circuit.rs	/^    type BaseField = BaseElement;$/;"	t	implementation:ZephyrChainCircuit
BenchmarkAnalyzer	src/hdcmodels/benchmarking/analysis.rs	/^impl BenchmarkAnalyzer {$/;"	c
BenchmarkAnalyzer	src/hdcmodels/benchmarking/analysis.rs	/^pub struct BenchmarkAnalyzer {$/;"	s
BenchmarkData	src/hdcmodels/benchmarking/data_collection.rs	/^pub struct BenchmarkData {$/;"	s
BenchmarkDataCollector	src/hdcmodels/benchmarking/data_collection.rs	/^impl BenchmarkDataCollector {$/;"	c
BenchmarkDataCollector	src/hdcmodels/benchmarking/data_collection.rs	/^pub struct BenchmarkDataCollector {$/;"	s
BenchmarkReport	src/hdcmodels/benchmarking/reporting.rs	/^impl From<&HDCBenchmarkResult> for BenchmarkReport {$/;"	c
BenchmarkReport	src/hdcmodels/benchmarking/reporting.rs	/^pub struct BenchmarkReport {$/;"	s
BenchmarkReporter	src/hdcmodels/benchmarking/reporting.rs	/^impl BenchmarkReporter {$/;"	c
BenchmarkReporter	src/hdcmodels/benchmarking/reporting.rs	/^pub struct BenchmarkReporter {$/;"	s
BinaryOp	src/smart_contract/types.rs	/^    BinaryOp { left: Box<Expression>, op: BinaryOperator, right: Box<Expression> },$/;"	e	enum:Expression
BinaryOperator	src/smart_contract/types.rs	/^pub enum BinaryOperator {$/;"	g
Blake3bHasher	src/zkp/crypto.rs	/^impl Hasher for Blake3bHasher {$/;"	c
Blake3bHasher	src/zkp/crypto.rs	/^pub struct Blake3bHasher(Blake3Hasher); \/\/ Adjusted to use Blake3Hasher$/;"	s
Block	src/chain/block.rs	/^impl Block {$/;"	c
Block	src/chain/block.rs	/^pub struct Block {$/;"	s
Block	src/network/p2p/message.rs	/^    Block(Block),$/;"	e	enum:Message
BlockBroadcast	src/network/node_message.rs	/^    BlockBroadcast(Block),$/;"	e	enum:NodeMessage
BlockData	src/api/models/request/blockchain_request.rs	/^pub struct BlockData {$/;"	s
BlockData	src/api/models/response/blockchain_response.rs	/^pub struct BlockData {$/;"	s
BlockError	src/chain/block.rs	/^pub enum BlockError {$/;"	g
BlockHeader	src/api/models/request/blockchain_request.rs	/^pub struct BlockHeader {$/;"	s
BlockHeader	src/api/models/response/blockchain_response.rs	/^pub struct BlockHeader {$/;"	s
BlockInfo	src/api/handlers/blockchain_handler.rs	/^impl BlockInfo {$/;"	c
BlockInfo	src/api/handlers/blockchain_handler.rs	/^struct BlockInfo {$/;"	s
BlockInfo	src/api/routes/blockchain.rs	/^pub struct BlockInfo {$/;"	s
BlockNotFound	src/chain/storage/block_storage.rs	/^    BlockNotFound(String),$/;"	e	enum:BlockStorageError
BlockNotFound	src/network/node_message.rs	/^    BlockNotFound(Hash),$/;"	e	enum:NodeMessageError
BlockProcessingFailed	src/network/node_message.rs	/^    BlockProcessingFailed(String),$/;"	e	enum:NodeMessageError
BlockProducer	src/mining/block_producer.rs	/^impl BlockProducer {$/;"	c
BlockProducer	src/mining/block_producer.rs	/^pub struct BlockProducer {$/;"	s
BlockRequest	src/network/node_message.rs	/^    BlockRequest(Hash),$/;"	e	enum:NodeMessage
BlockRequest	src/network/protocol.rs	/^    BlockRequest {$/;"	e	enum:ProtocolMessage
BlockResponse	src/network/node_message.rs	/^    BlockResponse(Block),$/;"	e	enum:NodeMessage
BlockResponse	src/network/protocol.rs	/^    BlockResponse {$/;"	e	enum:ProtocolMessage
BlockReward	src/types/block_reward.rs	/^impl BlockReward {$/;"	c
BlockReward	src/types/block_reward.rs	/^pub struct BlockReward {$/;"	s
BlockStorage	src/chain/storage/block_storage.rs	/^impl BlockStorage {$/;"	c
BlockStorage	src/chain/storage/block_storage.rs	/^pub struct BlockStorage {$/;"	s
BlockStorageError	src/chain/storage/block_storage.rs	/^pub enum BlockStorageError {$/;"	g
BlockTimeExceedsAllowedWindow	src/chain/validation.rs	/^    BlockTimeExceedsAllowedWindow,$/;"	e	enum:ValidationError
BlockValidationFailed	src/chain/state_transition.rs	/^    BlockValidationFailed(String),$/;"	e	enum:StateTransitionError
BlockValidationFailed	src/error_handling/error.rs	/^    BlockValidationFailed,$/;"	e	enum:BlockchainError
Blockchain	src/chain/blockchain.rs	/^impl Blockchain {$/;"	c
Blockchain	src/chain/blockchain.rs	/^pub struct Blockchain {$/;"	s
BlockchainBlocks	src/api/middleware/authorization.rs	/^    BlockchainBlocks,$/;"	e	enum:Path
BlockchainError	src/chain/blockchain.rs	/^pub enum BlockchainError {$/;"	g
BlockchainError	src/error_handling/error.rs	/^    BlockchainError(#[from] BlockchainError),$/;"	e	enum:Error
BlockchainError	src/error_handling/error.rs	/^pub enum BlockchainError {$/;"	g
BlockchainIndexer	src/utils/indexing.rs	/^impl BlockchainIndexer {$/;"	c
BlockchainIndexer	src/utils/indexing.rs	/^pub struct BlockchainIndexer {$/;"	s
BlockchainStateError	src/error_handling/error.rs	/^    BlockchainStateError,$/;"	e	enum:BlockchainError
BlockchainTransactions	src/api/middleware/authorization.rs	/^    BlockchainTransactions,$/;"	e	enum:Path
Blocks	src/network/p2p/message.rs	/^    Blocks(Vec<Block>),$/;"	e	enum:Message
Boolean	src/smart_contract/types.rs	/^    Boolean(bool),$/;"	e	enum:Value
Break	src/smart_contract/types.rs	/^    Break,$/;"	e	enum:Operation
CallContractRequest	src/api/models/request/smart_contract_request.rs	/^pub struct CallContractRequest {$/;"	s
CallRequest	src/api/handlers/smart_contract_handler.rs	/^struct CallRequest {$/;"	s
CallRequest	src/api/routes/smart_contract.rs	/^struct CallRequest {$/;"	s
Candidate	src/chain/quantum_voting/types.rs	/^pub struct Candidate {$/;"	s
CandidateVotingStatusUpdateError	src/chain/quantum_voting/error.rs	/^    CandidateVotingStatusUpdateError,$/;"	e	enum:VotingError
CastVoteRequest	src/api/models/request/governance_request.rs	/^pub struct CastVoteRequest {$/;"	s
CertificateAuthority	src/chain/certificate_authority.rs	/^impl CertificateAuthority {$/;"	c
CertificateAuthority	src/chain/certificate_authority.rs	/^pub struct CertificateAuthority {$/;"	s
CertificateAuthorityClient	src/chain/certificate_authority.rs	/^impl CertificateAuthorityClient {$/;"	c
CertificateAuthorityClient	src/chain/certificate_authority.rs	/^pub struct CertificateAuthorityClient {$/;"	s
CertificateAuthorityConfig	src/chain/certificate_authority.rs	/^pub struct CertificateAuthorityConfig {$/;"	s
ChainStatus	src/api/handlers/blockchain_handler.rs	/^struct ChainStatus {$/;"	s
ChainStatus	src/api/routes/blockchain.rs	/^struct ChainStatus {$/;"	s
ChannelManagerOptimized	src/chain/state_channel.rs	/^impl ChannelManagerOptimized {$/;"	c
ChannelManagerOptimized	src/chain/state_channel.rs	/^pub struct ChannelManagerOptimized {$/;"	s
ChannelSendError	src/network/sync/state_sync.rs	/^    ChannelSendError(String),$/;"	e	enum:StateSyncError
Claims	src/api/middleware/authentication.rs	/^struct Claims {$/;"	s
Client	src/network/client.rs	/^impl Client {$/;"	c
Client	src/network/client.rs	/^pub struct Client {$/;"	s
ClientBucket	src/api/middleware/rate_limiter.rs	/^struct ClientBucket {$/;"	s
CodeDataset	src/optimization_problems/hdc_code_generation/dataset.rs	/^impl CodeDataset {$/;"	c
CodeDataset	src/optimization_problems/hdc_code_generation/dataset.rs	/^pub struct CodeDataset {$/;"	s
Complex64	src/crypto/quantum_state.rs	/^impl Complex64 {$/;"	c
Complex64	src/crypto/quantum_state.rs	/^pub struct Complex64 {$/;"	s
Compression	src/chain/quantum_voting/compression.rs	/^impl Compression {$/;"	c
Compression	src/chain/quantum_voting/compression.rs	/^pub struct Compression {}$/;"	s
CompressionError	src/chain/shard.rs	/^    CompressionError(#[from] CompressionError),$/;"	e	enum:ShardError
CompressionError	src/utils/compression.rs	/^pub enum CompressionError {$/;"	g
CompressionFailed	src/network/node_message.rs	/^    CompressionFailed(String),$/;"	e	enum:NodeMessageError
CompressionFailed	src/network/protocol.rs	/^    CompressionFailed(String),$/;"	e	enum:ProtocolError
CompressionFailed	src/utils/compression.rs	/^    CompressionFailed(String),$/;"	e	enum:CompressionError
ComputeCapacityLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^impl ComputeCapacityLoadBalancer {$/;"	c
ComputeCapacityLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^impl LoadBalancer for ComputeCapacityLoadBalancer {$/;"	c
ComputeCapacityLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^pub struct ComputeCapacityLoadBalancer {$/;"	s
Config	src/api/middleware/authentication.rs	/^    type Config = ();$/;"	t	implementation:AuthenticatedUser
ConfigurationError	src/error_handling/error.rs	/^    ConfigurationError(#[from] ConfigurationError),$/;"	e	enum:Error
ConfigurationError	src/error_handling/error.rs	/^pub enum ConfigurationError {$/;"	g
ConfigurationFileNotFound	src/error_handling/error.rs	/^    ConfigurationFileNotFound,$/;"	e	enum:ConfigurationError
Confirmed	src/api/models/request/transaction_request.rs	/^    Confirmed,$/;"	e	enum:TransactionStatusType
ConnectPeerRequest	src/api/models/request/network_request.rs	/^pub struct ConnectPeerRequest {$/;"	s
ConnectionError	src/error_handling/network_error.rs	/^    ConnectionError(String),$/;"	e	enum:NetworkError
ConnectionError	src/network/error.rs	/^    ConnectionError(String),$/;"	e	enum:NetworkError
ConnectionFailed	src/error_handling/error.rs	/^    ConnectionFailed,$/;"	e	enum:NetworkError
ConnectionRefused	src/error_handling/network_error.rs	/^    ConnectionRefused,$/;"	e	enum:NetworkError
ConnectionResetByPeer	src/error_handling/network_error.rs	/^    ConnectionResetByPeer,$/;"	e	enum:NetworkError
ConsensusError	src/error_handling/error.rs	/^    ConsensusError(#[from] ConsensusError),$/;"	e	enum:Error
ConsensusError	src/error_handling/error.rs	/^pub enum ConsensusError {$/;"	g
ConsensusMessageInvalid	src/error_handling/error.rs	/^    ConsensusMessageInvalid,$/;"	e	enum:ConsensusError
ConsensusParameters	src/api/routes/consensus.rs	/^struct ConsensusParameters {$/;"	s
ConsensusSecurityMonitor	src/hdcmodels/governance_integration/consensus_security.rs	/^impl ConsensusSecurityMonitor {$/;"	c
ConsensusSecurityMonitor	src/hdcmodels/governance_integration/consensus_security.rs	/^pub struct ConsensusSecurityMonitor {$/;"	s
ConsensusState	src/api/routes/consensus.rs	/^struct ConsensusState {$/;"	s
ConsensusTimeout	src/error_handling/error.rs	/^    ConsensusTimeout,$/;"	e	enum:ConsensusError
Constant	src/zkp/constraint_system.rs	/^    Constant(FieldElement),$/;"	e	enum:Expression
Constraint	src/constraint_system.rs	/^type Constraint = Arc<dyn Fn(&Witness) -> bool + Send + Sync>;$/;"	t
ConstraintSystem	src/zkp/constraint_system.rs	/^pub trait ConstraintSystem {$/;"	i
ConstraintSystemImpl	src/zkp/constraint_system.rs	/^impl ConstraintSystem for ConstraintSystemImpl {$/;"	c
ConstraintSystemImpl	src/zkp/constraint_system.rs	/^pub struct ConstraintSystemImpl {$/;"	s
Continue	src/smart_contract/types.rs	/^    Continue,$/;"	e	enum:Operation
ContractFunctionInput	src/api/models/request/smart_contract_request.rs	/^pub struct ContractFunctionInput {$/;"	s
ContractInfo	src/api/handlers/smart_contract_handler.rs	/^struct ContractInfo {$/;"	s
ContractInfo	src/api/routes/smart_contract.rs	/^struct ContractInfo {$/;"	s
ContractNotFound	src/chain/storage/contract_storage.rs	/^    ContractNotFound(String),$/;"	e	enum:ContractStorageError
ContractState	src/api/handlers/smart_contract_handler.rs	/^struct ContractState {$/;"	s
ContractState	src/api/models/request/smart_contract_request.rs	/^pub struct ContractState {$/;"	s
ContractState	src/api/routes/smart_contract.rs	/^struct ContractState {$/;"	s
ContractStorage	src/chain/storage/contract_storage.rs	/^impl ContractStorage {$/;"	c
ContractStorage	src/chain/storage/contract_storage.rs	/^pub struct ContractStorage {$/;"	s
ContractStorageError	src/chain/storage/contract_storage.rs	/^pub enum ContractStorageError {$/;"	g
CorrectionError	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    CorrectionError(String),$/;"	e	enum:QuantumErrorCorrectionError
CosineSimilarity	src/hdcmodels/hdcmodels.rs	/^    CosineSimilarity,$/;"	e	enum:SimilarityMetric
CosineSimilarity	src/hdcmodels/mod.rs	/^    CosineSimilarity,$/;"	e	enum:SimilarityMetric
CryptoError	src/chain/wallet.rs	/^    CryptoError(#[from] CryptoError),$/;"	e	enum:WalletError
CryptoError	src/error_handling/error.rs	/^    CryptoError(#[from] CryptoError),$/;"	e	enum:Error
CryptoError	src/error_handling/error.rs	/^pub enum CryptoError {$/;"	g
DISCOVERY_INTERVAL	src/network/discovery.rs	/^const DISCOVERY_INTERVAL: Duration = Duration::from_secs(60);$/;"	C
DataConverter	src/hdcmodels/model_integration/data_conversion.rs	/^impl DataConverter {$/;"	c
DataConverter	src/hdcmodels/model_integration/data_conversion.rs	/^pub struct DataConverter;$/;"	s
DataCorruption	src/error_handling/error.rs	/^    DataCorruption,$/;"	e	enum:StorageError
DataItem	src/hdcmodels/distributed_training/load_balancing.rs	/^trait DataItem {$/;"	i
DataItem	src/hdcmodels/hdcmodels.rs	/^pub enum DataItem {$/;"	g
DataNotFound	src/error_handling/error.rs	/^    DataNotFound,$/;"	e	enum:StorageError
DataSizeLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^impl LoadBalancer for DataSizeLoadBalancer {$/;"	c
DataSizeLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^pub struct DataSizeLoadBalancer;$/;"	s
Database	src/chain/storage/database.rs	/^pub trait Database: Send + Sync {$/;"	i
DatabaseError	src/chain/storage/block_storage.rs	/^    DatabaseError(String),$/;"	e	enum:BlockStorageError
DatabaseError	src/chain/storage/contract_storage.rs	/^    DatabaseError(String),$/;"	e	enum:ContractStorageError
DatabaseError	src/chain/storage/database.rs	/^pub enum DatabaseError {$/;"	g
Dataset	src/hdcmodels/benchmarking/benchmark_suite.rs	/^impl Dataset {$/;"	c
Dataset	src/hdcmodels/benchmarking/benchmark_suite.rs	/^pub struct Dataset {$/;"	s
Dataset	src/hdcmodels/hdcmodels.rs	/^impl Dataset {$/;"	c
Dataset	src/hdcmodels/hdcmodels.rs	/^pub struct Dataset {$/;"	s
Dataset	src/hdcmodels/parallel_processing.rs	/^impl DatasetExt for Dataset {$/;"	c
DatasetExt	src/hdcmodels/parallel_processing.rs	/^trait DatasetExt {$/;"	i
DecompressionError	src/chain/shard.rs	/^    DecompressionError(#[from] DecompressionError),$/;"	e	enum:ShardError
DecompressionFailed	src/network/node_message.rs	/^    DecompressionFailed(String),$/;"	e	enum:NodeMessageError
DecompressionFailed	src/network/protocol.rs	/^    DecompressionFailed(String),$/;"	e	enum:ProtocolError
DecompressionFailed	src/utils/compression.rs	/^    DecompressionFailed(String),$/;"	e	enum:CompressionError
DecryptionError	src/chain/shard.rs	/^    DecryptionError(#[from] DecryptionError),$/;"	e	enum:ShardError
DecryptionError	src/chain/transaction.rs	/^    DecryptionError(String),$/;"	e	enum:TransactionError
DecryptionError	src/error_handling/network_error.rs	/^    DecryptionError(String),$/;"	e	enum:NetworkError
DecryptionError	src/secure_core/secure_communication.rs	/^    DecryptionError(String),$/;"	e	enum:SecureCommunicationError
DecryptionError	src/secure_core/secure_storage.rs	/^    DecryptionError(String),$/;"	e	enum:SecureStorageError
DecryptionFailed	src/crypto/post_quantum.rs	/^    DecryptionFailed,$/;"	e	enum:PostQuantumError
DecryptionFailed	src/error_handling/error.rs	/^    DecryptionFailed,$/;"	e	enum:CryptoError
DecryptionFailed	src/network/protocol.rs	/^    DecryptionFailed(String),$/;"	e	enum:ProtocolError
DecryptionFailed	src/utils/encryption.rs	/^    DecryptionFailed(String),$/;"	e	enum:EncryptionError
Defeated	src/chain/governance/proposal.rs	/^    Defeated,$/;"	e	enum:ProposalStatus
DeployContractRequest	src/api/models/request/smart_contract_request.rs	/^pub struct DeployContractRequest {$/;"	s
DeployRequest	src/api/handlers/smart_contract_handler.rs	/^struct DeployRequest {$/;"	s
DeployRequest	src/api/routes/smart_contract.rs	/^struct DeployRequest {$/;"	s
DeployedContract	src/api/models/request/smart_contract_request.rs	/^pub struct DeployedContract {$/;"	s
DeserializationError	src/chain/storage/database.rs	/^    DeserializationError(String),$/;"	e	enum:DatabaseError
DeserializationError	src/chain/storage/snapshot.rs	/^    DeserializationError(String),$/;"	e	enum:SnapshotError
DeserializationError	src/secure_core/secure_storage.rs	/^    DeserializationError(String),$/;"	e	enum:SecureStorageError
DeserializationFailed	src/network/node_message.rs	/^    DeserializationFailed(String),$/;"	e	enum:NodeMessageError
DeserializationFailed	src/network/protocol.rs	/^    DeserializationFailed(String),$/;"	e	enum:ProtocolError
Developer	src/secure_core/access_control.rs	/^    Developer,$/;"	e	enum:Role
DilithiumKeypair	src/crypto/post_quantum.rs	/^impl DilithiumKeypair {$/;"	c
DilithiumKeypair	src/crypto/post_quantum.rs	/^impl fmt::Debug for DilithiumKeypair {$/;"	c
DilithiumKeypair	src/crypto/post_quantum.rs	/^pub struct DilithiumKeypair {$/;"	s
DilithiumPublicKey	src/crypto/post_quantum.rs	/^impl DilithiumPublicKey {$/;"	c
DilithiumPublicKey	src/crypto/post_quantum.rs	/^pub struct DilithiumPublicKey(dilithium2::PublicKey);$/;"	s
DilithiumSecretKey	src/crypto/post_quantum.rs	/^impl DilithiumSecretKey {$/;"	c
DilithiumSecretKey	src/crypto/post_quantum.rs	/^pub struct DilithiumSecretKey(dilithium2::SecretKey);$/;"	s
DilithiumSignature	src/crypto/post_quantum.rs	/^impl DilithiumSignature {$/;"	c
DilithiumSignature	src/crypto/post_quantum.rs	/^pub struct DilithiumSignature(dilithium2::Signature);$/;"	s
DisconnectPeerRequest	src/api/models/request/network_request.rs	/^pub struct DisconnectPeerRequest {$/;"	s
Discovery	src/network/discovery.rs	/^impl Discovery {$/;"	c
Discovery	src/network/discovery.rs	/^pub struct Discovery {$/;"	s
DiscoveryError	src/network/error.rs	/^    DiscoveryError(String),$/;"	e	enum:NetworkError
Dispute	src/chain/state_channel.rs	/^pub struct Dispute {$/;"	s
DisputeResolution	src/chain/state_channel.rs	/^pub enum DisputeResolution {$/;"	g
DistributedTrainingAggregator	src/hdcmodels/distributed_training/distributed_framework.rs	/^impl DistributedTrainingAggregator {$/;"	c
DistributedTrainingAggregator	src/hdcmodels/distributed_training/distributed_framework.rs	/^pub struct DistributedTrainingAggregator {$/;"	s
DistributedTrainingMessage	src/hdcmodels/distributed_training/distributed_framework.rs	/^pub enum DistributedTrainingMessage {$/;"	g
DistributedTrainingNode	src/hdcmodels/distributed_training/distributed_framework.rs	/^impl DistributedTrainingNode {$/;"	c
DistributedTrainingNode	src/hdcmodels/distributed_training/distributed_framework.rs	/^pub struct DistributedTrainingNode {$/;"	s
Divide	src/smart_contract/types.rs	/^    Divide,$/;"	e	enum:BinaryOperator
DoubleSpending	src/chain/blockchain.rs	/^    DoubleSpending(usize),$/;"	e	enum:BlockchainError
DuplicateTransaction	src/chain/block.rs	/^    DuplicateTransaction(Transaction),$/;"	e	enum:BlockError
EmptyBlockchain	src/chain/blockchain.rs	/^    EmptyBlockchain,$/;"	e	enum:BlockchainError
EmptyLeaves	src/utils/merkle_tree.rs	/^    EmptyLeaves,$/;"	e	enum:MerkleTreeError
EncryptedData	src/secure_core/secure_storage.rs	/^pub struct EncryptedData {$/;"	s
EncryptionError	src/chain/shard.rs	/^    EncryptionError(#[from] EncryptionError),$/;"	e	enum:ShardError
EncryptionError	src/chain/transaction.rs	/^    EncryptionError(String),$/;"	e	enum:TransactionError
EncryptionError	src/error_handling/network_error.rs	/^    EncryptionError(String),$/;"	e	enum:NetworkError
EncryptionError	src/secure_core/secure_communication.rs	/^    EncryptionError(String),$/;"	e	enum:SecureCommunicationError
EncryptionError	src/secure_core/secure_storage.rs	/^    EncryptionError(String),$/;"	e	enum:SecureStorageError
EncryptionError	src/utils/encryption.rs	/^pub enum EncryptionError {$/;"	g
EncryptionFailed	src/crypto/post_quantum.rs	/^    EncryptionFailed,$/;"	e	enum:PostQuantumError
EncryptionFailed	src/error_handling/error.rs	/^    EncryptionFailed,$/;"	e	enum:CryptoError
EncryptionFailed	src/network/protocol.rs	/^    EncryptionFailed(String),$/;"	e	enum:ProtocolError
EncryptionFailed	src/utils/encryption.rs	/^    EncryptionFailed(String),$/;"	e	enum:EncryptionError
EncryptionKey	src/utils/encryption.rs	/^pub type EncryptionKey = [u8; 32];$/;"	t
EntanglementDistillation	src/chain/quantum_voting/entanglement_distillation.rs	/^impl EntanglementDistillation {$/;"	c
EntanglementDistillation	src/chain/quantum_voting/entanglement_distillation.rs	/^pub struct EntanglementDistillation {$/;"	s
Equals	src/smart_contract/types.rs	/^    Equals,$/;"	e	enum:BinaryOperator
EqualsConstraint	src/zkp/constraint_system.rs	/^impl EqualsConstraint {$/;"	c
EqualsConstraint	src/zkp/constraint_system.rs	/^pub struct EqualsConstraint {$/;"	s
Err	src/utils/node_id.rs	/^    type Err = NodeIdError;$/;"	t	implementation:NodeId
Error	src/api/middleware/authentication.rs	/^    type Error = Error;$/;"	t	implementation:AuthenticatedUser
Error	src/api/middleware/authorization.rs	/^    type Error = Error;$/;"	t
Error	src/api/middleware/rate_limiter.rs	/^    type Error = Error;$/;"	t
Error	src/api/middleware/request_validator.rs	/^    type Error = Error;$/;"	t
Error	src/error_handling/error.rs	/^pub enum Error {$/;"	g
ErrorCorrection	src/chain/quantum_voting/error_correction.rs	/^impl ErrorCorrection {$/;"	c
ErrorCorrection	src/chain/quantum_voting/error_correction.rs	/^pub struct ErrorCorrection {}$/;"	s
ErrorExt	src/error_handling/error_utils.rs	/^pub trait ErrorExt<T> {$/;"	i
ErrorReporter	src/error_handling/error_reporter.rs	/^impl ErrorReporter {$/;"	c
ErrorReporter	src/error_handling/error_reporter.rs	/^pub struct ErrorReporter {$/;"	s
ErrorResponse	src/network/node_message.rs	/^    ErrorResponse(NodeMessageError),$/;"	e	enum:NodeMessage
EvaluationResult	src/constraint_system.rs	/^type EvaluationResult = Result<Vec<bool>, String>;$/;"	t
EvaluationResult	src/optimization_problems/hdc_code_generation/evaluator.rs	/^pub struct EvaluationResult {$/;"	s
Evaluator	src/optimization_problems/hdc_code_generation/evaluator.rs	/^impl<'a> Evaluator<'a> {$/;"	c
Evaluator	src/optimization_problems/hdc_code_generation/evaluator.rs	/^pub struct Evaluator<'a> {$/;"	s
ExceededMaxVoters	src/chain/quantum_voting/error.rs	/^    ExceededMaxVoters(usize),$/;"	e	enum:VotingError
ExecuteContract	src/secure_core/access_control.rs	/^    ExecuteContract,$/;"	e	enum:Permission
Executed	src/chain/governance/proposal.rs	/^    Executed,$/;"	e	enum:ProposalStatus
ExecutedProposal	src/chain/governance/governance_engine.rs	/^    ExecutedProposal(u64),$/;"	e	enum:GovernanceMessage
ExecutionContext	src/smart_contract/execution_context.rs	/^impl ExecutionContext {$/;"	c
ExecutionContext	src/smart_contract/execution_context.rs	/^pub struct ExecutionContext {$/;"	s
ExecutionFailed	src/error_handling/error.rs	/^    ExecutionFailed,$/;"	e	enum:SmartContractError
Expired	src/api/models/request/governance_request.rs	/^    Expired,$/;"	e	enum:ProposalStatus
Expression	src/smart_contract/types.rs	/^pub enum Expression {$/;"	g
Expression	src/zkp/constraint_system.rs	/^impl Expression {$/;"	c
Expression	src/zkp/constraint_system.rs	/^pub enum Expression {$/;"	g
FIELD1_LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const FIELD1_LOAD_FACTOR: f64 = 0.2;$/;"	C	method:MyDataType::compute_load
FIELD2_LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const FIELD2_LOAD_FACTOR: f64 = 0.3;$/;"	C	method:MyDataType::compute_load
FIELD3_LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const FIELD3_LOAD_FACTOR: f64 = 0.5;$/;"	C	method:MyDataType::compute_load
Failed	src/api/models/request/transaction_request.rs	/^    Failed,$/;"	e	enum:TransactionStatusType
FailedToBroadcastRewardMessage	src/chain/governance/rewards.rs	/^    FailedToBroadcastRewardMessage(String),$/;"	e	enum:RewardError
FailedToBroadcastStakingMessage	src/chain/governance/staking.rs	/^    FailedToBroadcastStakingMessage(String),$/;"	e	enum:StakingError
FailedToClaimReward	src/chain/governance/rewards.rs	/^    FailedToClaimReward(String),$/;"	e	enum:RewardError
FailedToDistributeReward	src/chain/governance/staking.rs	/^    FailedToDistributeReward(String),$/;"	e	enum:StakingError
FailedToUpdateLockPeriod	src/chain/governance/staking.rs	/^    FailedToUpdateLockPeriod(String),$/;"	e	enum:StakingError
FailedToUpdateReward	src/chain/governance/rewards.rs	/^    FailedToUpdateReward(String),$/;"	e	enum:RewardError
FailedToUpdateRewardPool	src/chain/governance/rewards.rs	/^    FailedToUpdateRewardPool(String),$/;"	e	enum:RewardError
FailedToUpdateRewardRate	src/chain/governance/rewards.rs	/^    FailedToUpdateRewardRate(String),$/;"	e	enum:RewardError
FailedToUpdateRewardRate	src/chain/governance/staking.rs	/^    FailedToUpdateRewardRate(String),$/;"	e	enum:StakingError
FailedToUpdateStaking	src/chain/governance/staking.rs	/^    FailedToUpdateStaking(String),$/;"	e	enum:StakingError
Failure	src/chain/quantum_voting/types.rs	/^    Failure(VotingError),$/;"	e	enum:VotingResult
FaultTolerantDistributedTrainingAggregator	src/hdcmodels/distributed_training/fault_tolerance.rs	/^impl FaultTolerantDistributedTrainingAggregator {$/;"	c
FaultTolerantDistributedTrainingAggregator	src/hdcmodels/distributed_training/fault_tolerance.rs	/^pub struct FaultTolerantDistributedTrainingAggregator {$/;"	s
FaultTolerantDistributedTrainingNode	src/hdcmodels/distributed_training/fault_tolerance.rs	/^impl FaultTolerantDistributedTrainingNode {$/;"	c
FaultTolerantDistributedTrainingNode	src/hdcmodels/distributed_training/fault_tolerance.rs	/^pub struct FaultTolerantDistributedTrainingNode {$/;"	s
FieldElement	src/zkp/math.rs	/^impl Add for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl AddAssign for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl Mul for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl MulAssign for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl Sub for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^impl SubAssign for FieldElement {$/;"	c
FieldElement	src/zkp/math.rs	/^pub struct FieldElement(BigUint);$/;"	s
FriProof	src/zkp/zk_starks.rs	/^pub struct FriProof {$/;"	s
FriQueryRoundProof	src/zkp/zk_starks.rs	/^pub struct FriQueryRoundProof {$/;"	s
FunctionCall	src/smart_contract/types.rs	/^    FunctionCall { name: String, args: Vec<Expression> },$/;"	e	enum:Expression
FunctionCall	src/smart_contract/types.rs	/^    FunctionCall { name: String, args: Vec<Expression> },$/;"	e	enum:Operation
Future	src/api/middleware/authentication.rs	/^    type Future = Ready<Result<Self, Self::Error>>;$/;"	t	implementation:AuthenticatedUser
Future	src/api/middleware/authorization.rs	/^    type Future = Ready<Result<Self::Response, Self::Error>>;$/;"	t
Future	src/api/middleware/authorization.rs	/^    type Future = Ready<Result<Self::Transform, Self::InitError>>;$/;"	t
Future	src/api/middleware/rate_limiter.rs	/^    type Future = Ready<Result<Self::Response, Self::Error>>;$/;"	t
Future	src/api/middleware/rate_limiter.rs	/^    type Future = Ready<Result<Self::Transform, Self::InitError>>;$/;"	t
Future	src/api/middleware/request_validator.rs	/^    type Future = Ready<Result<Self::Response, Self::Error>>;$/;"	t
Future	src/api/middleware/request_validator.rs	/^    type Future = Ready<Result<Self::Transform, Self::InitError>>;$/;"	t
GPUHDCModel	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^impl GPUHDCModel {$/;"	c
GPUHDCModel	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^pub struct GPUHDCModel {$/;"	s
GasCost	src/smart_contract/gas.rs	/^impl Default for GasCost {$/;"	c
GasCost	src/smart_contract/gas.rs	/^pub struct GasCost {$/;"	s
Get	src/api/middleware/authorization.rs	/^    Get,$/;"	e	enum:Method
GetBlockRequest	src/api/models/request/blockchain_request.rs	/^pub struct GetBlockRequest {$/;"	s
GetBlockResponse	src/api/models/response/blockchain_response.rs	/^pub struct GetBlockResponse {$/;"	s
GetBlocks	src/network/p2p/message.rs	/^    GetBlocks(Hasher),$/;"	e	enum:Message
GetChainInfoRequest	src/api/models/request/blockchain_request.rs	/^pub struct GetChainInfoRequest {}/;"	s
GetChainInfoResponse	src/api/models/response/blockchain_response.rs	/^pub struct GetChainInfoResponse {$/;"	s
GetConsensusParametersRequest	src/api/models/request/qup_request.rs	/^pub struct GetConsensusParametersRequest {}$/;"	s
GetConsensusParametersResponse	src/api/models/response/qup_response.rs	/^pub struct GetConsensusParametersResponse {$/;"	s
GetConsensusStateRequest	src/api/models/request/qup_request.rs	/^pub struct GetConsensusStateRequest {}$/;"	s
GetConsensusStateResponse	src/api/models/response/qup_response.rs	/^pub struct GetConsensusStateResponse {$/;"	s
GetContractRequest	src/api/models/request/smart_contract_request.rs	/^pub struct GetContractRequest {$/;"	s
GetContractStateRequest	src/api/models/request/smart_contract_request.rs	/^pub struct GetContractStateRequest {$/;"	s
GetGovernanceParametersRequest	src/api/models/request/governance_request.rs	/^pub struct GetGovernanceParametersRequest {}$/;"	s
GetNetworkConfigResponse	src/api/models/response/network_response.rs	/^pub struct GetNetworkConfigResponse {$/;"	s
GetNetworkStatsRequest	src/api/models/request/network_request.rs	/^pub struct GetNetworkStatsRequest {}$/;"	s
GetNetworkStatsResponse	src/api/models/response/network_response.rs	/^pub struct GetNetworkStatsResponse {$/;"	s
GetPeers	src/network/p2p/message.rs	/^    GetPeers,$/;"	e	enum:Message
GetPeersResponse	src/api/models/response/network_response.rs	/^pub struct GetPeersResponse {$/;"	s
GetProposalRequest	src/api/models/request/governance_request.rs	/^pub struct GetProposalRequest {$/;"	s
GetProposalsRequest	src/api/models/request/governance_request.rs	/^pub struct GetProposalsRequest {$/;"	s
GetShardStateError	src/chain/sharding.rs	/^    GetShardStateError(u64),$/;"	e	enum:ShardingError
GetState	src/network/p2p/message.rs	/^    GetState(u64),$/;"	e	enum:Message
GetTransactionRequest	src/api/models/request/transaction_request.rs	/^pub struct GetTransactionRequest {$/;"	s
GetTransactionResponse	src/api/models/response/blockchain_response.rs	/^pub struct GetTransactionResponse {$/;"	s
GetTransactionsRequest	src/api/models/request/blockchain_request.rs	/^pub struct GetTransactionsRequest {$/;"	s
GetTransactionsRequest	src/api/models/request/transaction_request.rs	/^pub struct GetTransactionsRequest {$/;"	s
GetTransactionsResponse	src/api/models/response/blockchain_response.rs	/^pub struct GetTransactionsResponse {$/;"	s
GetValidatorsRequest	src/api/models/request/qup_request.rs	/^pub struct GetValidatorsRequest {}$/;"	s
GetValidatorsResponse	src/api/models/response/qup_response.rs	/^pub struct GetValidatorsResponse {$/;"	s
GovernanceEngine	src/chain/governance/governance_engine.rs	/^impl GovernanceEngine {$/;"	c
GovernanceEngine	src/chain/governance/governance_engine.rs	/^pub struct GovernanceEngine {$/;"	s
GovernanceMessage	src/chain/governance/governance_engine.rs	/^pub enum GovernanceMessage {$/;"	g
GovernanceParameters	src/api/handlers/governance_handler.rs	/^struct GovernanceParameters {$/;"	s
GovernanceParameters	src/api/models/request/governance_request.rs	/^pub struct GovernanceParameters {$/;"	s
GovernanceParameters	src/api/routes/governance.rs	/^struct GovernanceParameters {$/;"	s
GreaterThan	src/smart_contract/types.rs	/^    GreaterThan,$/;"	e	enum:BinaryOperator
GreaterThanOrEqual	src/smart_contract/types.rs	/^    GreaterThanOrEqual,$/;"	e	enum:BinaryOperator
Guest	src/api/middleware/authentication.rs	/^    Guest,$/;"	e	enum:Role
HANDSHAKE_TIMEOUT	src/network/protocol.rs	/^pub const HANDSHAKE_TIMEOUT: u64 = 10; \/\/ 10 seconds$/;"	C
HDCBenchmarkResult	src/hdcmodels/benchmarking/benchmark_suite.rs	/^pub struct HDCBenchmarkResult {$/;"	s
HDCBenchmarkSuite	src/hdcmodels/benchmarking/benchmark_suite.rs	/^impl HDCBenchmarkSuite {$/;"	c
HDCBenchmarkSuite	src/hdcmodels/benchmarking/benchmark_suite.rs	/^pub struct HDCBenchmarkSuite {$/;"	s
HDCModel	src/hdcmodels/distributed_training/distributed_framework.rs	/^impl HDCModelExt for HDCModel {$/;"	c
HDCModel	src/hdcmodels/distributed_training/load_balancing.rs	/^impl DataItem for HDCModel {$/;"	c
HDCModel	src/hdcmodels/hdcmodels.rs	/^impl HDCModel {$/;"	c
HDCModel	src/hdcmodels/hdcmodels.rs	/^pub struct HDCModel {$/;"	s
HDCModel	src/hdcmodels/mod.rs	/^impl HDCModel {$/;"	c
HDCModel	src/hdcmodels/mod.rs	/^pub struct HDCModel {$/;"	s
HDCModel	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^impl HDCModel {$/;"	c
HDCModelExt	src/hdcmodels/distributed_training/distributed_framework.rs	/^trait HDCModelExt {$/;"	i
HDCommunication	src/qup/hdcomm.rs	/^impl HDCommunication {$/;"	c
HDCommunication	src/qup/hdcomm.rs	/^pub struct HDCommunication {$/;"	s
HYPERVECTOR_DIMENSION	src/hdcmodels/mod.rs	/^const HYPERVECTOR_DIMENSION: usize = 5000;$/;"	C
Hadamard	src/crypto/quantum_state.rs	/^    Hadamard,$/;"	e	enum:QuantumGate
HammingDistance	src/hdcmodels/hdcmodels.rs	/^    HammingDistance,$/;"	e	enum:SimilarityMetric
HammingDistance	src/hdcmodels/mod.rs	/^    HammingDistance,$/;"	e	enum:SimilarityMetric
Handler	src/network/handler.rs	/^pub trait Handler {$/;"	i
HandlerImpl	src/network/handler.rs	/^impl Handler for HandlerImpl {$/;"	c
HandlerImpl	src/network/handler.rs	/^impl HandlerImpl {$/;"	c
HandlerImpl	src/network/handler.rs	/^pub struct HandlerImpl {$/;"	s
Handshake	src/network/protocol.rs	/^    Handshake {$/;"	e	enum:ProtocolMessage
HandshakeError	src/network/error.rs	/^    HandshakeError(String),$/;"	e	enum:NetworkError
HandshakeFailed	src/error_handling/network_error.rs	/^    HandshakeFailed(String),$/;"	e	enum:NetworkError
HardwareConfigurationError	src/chain/quantum_voting/error.rs	/^    HardwareConfigurationError,$/;"	e	enum:VotingError
HardwareError	src/chain/quantum_voting/error.rs	/^    HardwareError,$/;"	e	enum:VotingError
Hasher	src/zkp/crypto.rs	/^pub trait Hasher {$/;"	i
Hasher	src/zkp/math.rs	/^type Hasher = Sha256;$/;"	t
HistoricalDataError	src/chain/quantum_voting/error.rs	/^    HistoricalDataError,$/;"	e	enum:VotingError
HybridModel	src/hdcmodels/model_integration/hybrid_models.rs	/^impl HybridModel {$/;"	c
HybridModel	src/hdcmodels/model_integration/hybrid_models.rs	/^pub struct HybridModel {$/;"	s
If	src/smart_contract/types.rs	/^    If { condition: Expression, then_branch: Vec<Operation>, else_branch: Vec<Operation> },$/;"	e	enum:Operation
InProgress	src/chain/state_channel.rs	/^    InProgress { arbitrator: String },$/;"	e	enum:ArbitrationStatus
IncompatibleProtocolVersion	src/error_handling/network_error.rs	/^    IncompatibleProtocolVersion(String),$/;"	e	enum:NetworkError
IncrementalLearningHDCModel	src/hdcmodels/continuous_learning/incremental_learning.rs	/^impl IncrementalLearningHDCModel {$/;"	c
IncrementalLearningHDCModel	src/hdcmodels/continuous_learning/incremental_learning.rs	/^pub struct IncrementalLearningHDCModel {$/;"	s
InitError	src/api/middleware/authorization.rs	/^    type InitError = ();$/;"	t
InitError	src/api/middleware/rate_limiter.rs	/^    type InitError = ();$/;"	t
InitError	src/api/middleware/request_validator.rs	/^    type InitError = ();$/;"	t
InitializeTraining	src/hdcmodels/distributed_training/distributed_framework.rs	/^    InitializeTraining(usize),$/;"	e	enum:DistributedTrainingMessage
InsufficientAccountBalance	src/chain/validation.rs	/^    InsufficientAccountBalance,$/;"	e	enum:ValidationError
InsufficientBalance	src/chain/state_transition.rs	/^    InsufficientBalance(String, u64, u64),$/;"	e	enum:StateTransitionError
InsufficientCoherence	src/chain/quantum_voting/error.rs	/^    InsufficientCoherence,$/;"	e	enum:VotingError
InsufficientDelegatedStake	src/qup/error.rs	/^    InsufficientDelegatedStake(String),$/;"	e	enum:QUPError
InsufficientEntanglementQuality	src/chain/quantum_voting/error.rs	/^    InsufficientEntanglementQuality,$/;"	e	enum:VotingError
InsufficientFidelity	src/chain/quantum_voting/error.rs	/^    InsufficientFidelity,$/;"	e	enum:VotingError
InsufficientFunds	src/error_handling/error.rs	/^    InsufficientFunds,$/;"	e	enum:WalletError
InsufficientPermissions	src/error_handling/network_error.rs	/^    InsufficientPermissions,$/;"	e	enum:NetworkError
InsufficientPurity	src/chain/quantum_voting/error.rs	/^    InsufficientPurity,$/;"	e	enum:VotingError
InsufficientSecurityLevel	src/chain/quantum_voting/error.rs	/^    InsufficientSecurityLevel(f64),$/;"	e	enum:VotingError
InsufficientStake	src/qup/error.rs	/^    InsufficientStake(String),$/;"	e	enum:QUPError
InsufficientStakedAmount	src/chain/governance/staking.rs	/^    InsufficientStakedAmount,$/;"	e	enum:StakingError
InsufficientVotes	src/chain/quantum_voting/types.rs	/^    InsufficientVotes,$/;"	e	enum:VotingError
Integer	src/smart_contract/types.rs	/^    Integer(i64),$/;"	e	enum:Value
Interpreter	src/smart_contract/interpreter.rs	/^impl Interpreter {$/;"	c
Interpreter	src/smart_contract/interpreter.rs	/^pub struct Interpreter {$/;"	s
InvalidAddress	src/error_handling/error.rs	/^    InvalidAddress,$/;"	e	enum:WalletError
InvalidAddress	src/error_handling/network_error.rs	/^    InvalidAddress(String),$/;"	e	enum:NetworkError
InvalidBlock	src/qup/error.rs	/^    InvalidBlock(String),$/;"	e	enum:QUPError
InvalidBlockHash	src/chain/blockchain.rs	/^    InvalidBlockHash(usize, String, String),$/;"	e	enum:BlockchainError
InvalidBlockHash	src/chain/validation.rs	/^    InvalidBlockHash,$/;"	e	enum:ValidationError
InvalidBlockProposer	src/error_handling/error.rs	/^    InvalidBlockProposer,$/;"	e	enum:ConsensusError
InvalidBlockTimestamp	src/chain/validation.rs	/^    InvalidBlockTimestamp,$/;"	e	enum:ValidationError
InvalidCompressedState	src/chain/quantum_voting/error.rs	/^    InvalidCompressedState,$/;"	e	enum:VotingError
InvalidConfiguration	src/error_handling/error.rs	/^    InvalidConfiguration,$/;"	e	enum:ConfigurationError
InvalidConsensusMessage	src/qup/error.rs	/^    InvalidConsensusMessage(String),$/;"	e	enum:QUPError
InvalidDataError	src/error_handling/error.rs	/^    InvalidDataError(String),$/;"	e	enum:Error
InvalidDecodedState	src/chain/quantum_voting/error.rs	/^    InvalidDecodedState,$/;"	e	enum:VotingError
InvalidEncodedData	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    InvalidEncodedData,$/;"	e	enum:QuantumErrorCorrectionError
InvalidEncodedState	src/chain/quantum_voting/error.rs	/^    InvalidEncodedState,$/;"	e	enum:VotingError
InvalidErrorCorrectionRate	src/chain/quantum_voting/error.rs	/^    InvalidErrorCorrectionRate(f64),$/;"	e	enum:VotingError
InvalidFormat	src/utils/node_id.rs	/^    InvalidFormat(String),$/;"	e	enum:NodeIdError
InvalidHexFormat	src/types/address.rs	/^    InvalidHexFormat,$/;"	e	enum:AddressError
InvalidMessageFormat	src/error_handling/network_error.rs	/^    InvalidMessageFormat,$/;"	e	enum:NetworkError
InvalidNoiseLevel	src/chain/quantum_voting/error.rs	/^    InvalidNoiseLevel(f64),$/;"	e	enum:VotingError
InvalidNumVoters	src/chain/quantum_voting/error.rs	/^    InvalidNumVoters(usize),$/;"	e	enum:VotingError
InvalidPreviousHash	src/chain/blockchain.rs	/^    InvalidPreviousHash(usize, String, String),$/;"	e	enum:BlockchainError
InvalidProblem	src/qup/error.rs	/^    InvalidProblem(String),$/;"	e	enum:UsefulWorkError
InvalidProof	src/chain/state/merkle_trie.rs	/^    InvalidProof,$/;"	e	enum:MerkleTrieError
InvalidSecurityLevel	src/chain/quantum_voting/error.rs	/^    InvalidSecurityLevel(f64),$/;"	e	enum:VotingError
InvalidSignature	src/qup/error.rs	/^    InvalidSignature(String),$/;"	e	enum:QUPError
InvalidSmartContract	src/chain/block.rs	/^    InvalidSmartContract(String),$/;"	e	enum:BlockError
InvalidSmartContract	src/error_handling/error.rs	/^    InvalidSmartContract,$/;"	e	enum:SmartContractError
InvalidSolution	src/qup/error.rs	/^    InvalidSolution(String),$/;"	e	enum:UsefulWorkError
InvalidStateSignature	src/network/sync/state_sync.rs	/^    InvalidStateSignature(u64),$/;"	e	enum:StateSyncError
InvalidTransaction	src/chain/shard.rs	/^    InvalidTransaction(String),$/;"	e	enum:ShardError
InvalidTransaction	src/chain/transaction.rs	/^    InvalidTransaction(String),$/;"	e	enum:TransactionError
InvalidTransaction	src/qup/error.rs	/^    InvalidTransaction(String),$/;"	e	enum:QUPError
InvalidTransactionAmount	src/chain/validation.rs	/^    InvalidTransactionAmount,$/;"	e	enum:ValidationError
InvalidTransactionNonce	src/chain/state_transition.rs	/^    InvalidTransactionNonce(u64, u64),$/;"	e	enum:StateTransitionError
InvalidTransactions	src/chain/block.rs	/^    InvalidTransactions(String),$/;"	e	enum:BlockError
InvalidUsefulWork	src/chain/block.rs	/^    InvalidUsefulWork(String),$/;"	e	enum:BlockError
InvalidUsefulWork	src/qup/error.rs	/^    InvalidUsefulWork(String),$/;"	e	enum:QUPError
IoError	src/chain/blockchain.rs	/^    IoError(#[from] std::io::Error),$/;"	e	enum:BlockchainError
IoError	src/chain/storage/snapshot.rs	/^    IoError(#[from] io::Error),$/;"	e	enum:SnapshotError
IoError	src/error_handling/error.rs	/^    IoError(#[from] std::io::Error),$/;"	e	enum:Error
IoError	src/error_handling/network_error.rs	/^    IoError(#[from] io::Error),$/;"	e	enum:NetworkError
KeyExchangeError	src/secure_core/secure_communication.rs	/^    KeyExchangeError(String),$/;"	e	enum:SecureCommunicationError
KeyGenerationError	src/secure_core/quantum_resistant_signatures.rs	/^    KeyGenerationError(String),$/;"	e	enum:QuantumResistantSignatureError
KeyGenerationFailed	src/crypto/post_quantum.rs	/^    KeyGenerationFailed,$/;"	e	enum:PostQuantumError
KeyGenerationFailed	src/utils/encryption.rs	/^    KeyGenerationFailed(String),$/;"	e	enum:EncryptionError
KeyManagementError	src/chain/transaction.rs	/^    KeyManagementError(#[from] KeyManagementError),$/;"	e	enum:TransactionError
KeyNotFound	src/chain/storage/database.rs	/^    KeyNotFound(String),$/;"	e	enum:DatabaseError
Knapsack	src/qup/hdcomm.rs	/^    Knapsack(KnapsackProblem),$/;"	e	enum:UsefulWorkProblem
Knapsack	src/qup/hdcomm.rs	/^    Knapsack(KnapsackSolution),$/;"	e	enum:UsefulWorkSolution
Knapsack	src/qup/types.rs	/^    Knapsack(KnapsackProblem),$/;"	e	enum:UsefulWorkProblem
Knapsack	src/qup/types.rs	/^    Knapsack(KnapsackSolution),$/;"	e	enum:UsefulWorkSolution
KnapsackProblem	src/qup/types.rs	/^pub struct KnapsackProblem {$/;"	s
KnapsackSolution	src/qup/types.rs	/^pub struct KnapsackSolution {$/;"	s
KyberKeypair	src/crypto/post_quantum.rs	/^impl KyberKeypair {$/;"	c
KyberKeypair	src/crypto/post_quantum.rs	/^impl fmt::Debug for KyberKeypair {$/;"	c
KyberKeypair	src/crypto/post_quantum.rs	/^pub struct KyberKeypair {$/;"	s
KyberPublicKey	src/crypto/post_quantum.rs	/^impl KyberPublicKey {$/;"	c
KyberPublicKey	src/crypto/post_quantum.rs	/^pub struct KyberPublicKey(kyber512::PublicKey);$/;"	s
KyberSecretKey	src/crypto/post_quantum.rs	/^impl KyberSecretKey {$/;"	c
KyberSecretKey	src/crypto/post_quantum.rs	/^pub struct KyberSecretKey(kyber512::SecretKey);$/;"	s
LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const LOAD_FACTOR: f64 = 0.1;$/;"	C	method:String::compute_load
LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const LOAD_FACTOR: f64 = 0.5;$/;"	C	method:Vec::compute_load
LOAD_FACTOR	src/hdcmodels/distributed_training/load_balancing.rs	/^        const LOAD_FACTOR: f64 = 1.0;$/;"	C	method:HDCModel::compute_load
LessThan	src/smart_contract/types.rs	/^    LessThan,$/;"	e	enum:BinaryOperator
LessThanOrEqual	src/smart_contract/types.rs	/^    LessThanOrEqual,$/;"	e	enum:BinaryOperator
Literal	src/smart_contract/types.rs	/^    Literal(Value),$/;"	e	enum:Expression
LoadBalancedDistributedTrainingAggregator	src/hdcmodels/distributed_training/load_balancing.rs	/^impl<T: LoadBalancer> LoadBalancedDistributedTrainingAggregator<T> {$/;"	c
LoadBalancedDistributedTrainingAggregator	src/hdcmodels/distributed_training/load_balancing.rs	/^pub struct LoadBalancedDistributedTrainingAggregator<T: LoadBalancer> {$/;"	s
LoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^pub trait LoadBalancer {$/;"	i
LockPeriodUpdated	src/chain/governance/staking.rs	/^    LockPeriodUpdated {$/;"	e	enum:StakingMessage
LoggingError	src/chain/transaction.rs	/^    LoggingError(#[from] LoggingError),$/;"	e	enum:TransactionError
Loop	src/smart_contract/types.rs	/^    Loop { condition: Expression, body: Vec<Operation> },$/;"	e	enum:Operation
MAX_BLOCK_SIZE	src/hdcmodels/governance_integration/consensus_security.rs	/^        const MAX_BLOCK_SIZE: usize = 1024 * 1024; \/\/ 1 MB$/;"	C	method:ConsensusSecurityMonitor::is_valid_block_size
MAX_MESSAGE_SIZE	src/network/protocol.rs	/^pub const MAX_MESSAGE_SIZE: usize = 1024 * 1024;$/;"	C
MAX_OFF_CHAIN_TRANSACTIONS	src/chain/state_channel.rs	/^const MAX_OFF_CHAIN_TRANSACTIONS: usize = 100;$/;"	C
MAX_REQUESTS_PER_WINDOW	src/api/middleware/rate_limiter.rs	/^const MAX_REQUESTS_PER_WINDOW: usize = 100; \/\/ Maximum requests per window$/;"	C
Map	src/smart_contract/types.rs	/^    Map(HashMap<String, Value>),$/;"	e	enum:Value
MeasurementResultsMessage	src/network/node_message.rs	/^    MeasurementResultsMessage(Vec<bool>),$/;"	e	enum:NodeMessage
MemoryDatabase	src/chain/storage/database.rs	/^impl Database for MemoryDatabase {$/;"	c
MemoryDatabase	src/chain/storage/database.rs	/^impl MemoryDatabase {$/;"	c
MemoryDatabase	src/chain/storage/database.rs	/^pub struct MemoryDatabase {$/;"	s
MerkleTree	src/utils/merkle_tree.rs	/^impl MerkleTree {$/;"	c
MerkleTree	src/utils/merkle_tree.rs	/^pub struct MerkleTree {$/;"	s
MerkleTreeConstructionError	src/chain/block.rs	/^    MerkleTreeConstructionError(String),$/;"	e	enum:BlockError
MerkleTreeError	src/utils/merkle_tree.rs	/^pub enum MerkleTreeError {$/;"	g
MerkleTrie	src/chain/state/merkle_trie.rs	/^impl MerkleTrie {$/;"	c
MerkleTrie	src/chain/state/merkle_trie.rs	/^pub struct MerkleTrie {$/;"	s
MerkleTrieError	src/chain/state/merkle_trie.rs	/^pub enum MerkleTrieError {$/;"	g
Message	src/network/p2p/message.rs	/^impl Message {$/;"	c
Message	src/network/p2p/message.rs	/^pub enum Message {$/;"	g
MessageError	src/network/error.rs	/^    MessageError(String),$/;"	e	enum:NetworkError
MessageReceivingFailed	src/error_handling/error.rs	/^    MessageReceivingFailed,$/;"	e	enum:NetworkError
MessageReceivingFailed	src/error_handling/network_error.rs	/^    MessageReceivingFailed(String),$/;"	e	enum:NetworkError
MessageSendError	src/chain/shard.rs	/^    MessageSendError(String),$/;"	e	enum:ShardError
MessageSendingFailed	src/chain/sharding.rs	/^    MessageSendingFailed(String),$/;"	e	enum:ShardingError
MessageSendingFailed	src/error_handling/error.rs	/^    MessageSendingFailed,$/;"	e	enum:NetworkError
MessageSendingFailed	src/error_handling/network_error.rs	/^    MessageSendingFailed(String),$/;"	e	enum:NetworkError
Method	src/api/middleware/authorization.rs	/^enum Method {$/;"	g
Miner	src/mining/miner.rs	/^impl Miner {$/;"	c
Miner	src/mining/miner.rs	/^pub struct Miner {$/;"	s
MiningConfig	src/mining/mining_config.rs	/^impl Default for MiningConfig {$/;"	c
MiningConfig	src/mining/mining_config.rs	/^impl MiningConfig {$/;"	c
MiningConfig	src/mining/mining_config.rs	/^pub struct MiningConfig {$/;"	s
MiningError	src/chain/block.rs	/^    MiningError(String),$/;"	e	enum:BlockError
MissingConfiguration	src/error_handling/error.rs	/^    MissingConfiguration,$/;"	e	enum:ConfigurationError
MissingQuantumKey	src/chain/quantum_voting/error.rs	/^    MissingQuantumKey,$/;"	e	enum:VotingError
ModelUpdateMessage	src/hdcmodels/distributed_training/synchronization.rs	/^pub struct ModelUpdateMessage {$/;"	s
Mul	src/zkp/constraint_system.rs	/^    Mul(Box<Expression>, Box<Expression>),$/;"	e	enum:Expression
Multiply	src/smart_contract/types.rs	/^    Multiply,$/;"	e	enum:BinaryOperator
MyDataType	src/hdcmodels/distributed_training/load_balancing.rs	/^impl DataItem for MyDataType {$/;"	c
MyDataType	src/hdcmodels/distributed_training/load_balancing.rs	/^struct MyDataType {$/;"	s
NONCE_LENGTH	src/secure_core/secure_communication.rs	/^const NONCE_LENGTH: usize = 12;$/;"	C
NONCE_LENGTH	src/secure_core/secure_storage.rs	/^const NONCE_LENGTH: usize = 12;$/;"	C
NUM_COLUMNS	src/zephyrchain_circuit.rs	/^const NUM_COLUMNS: usize = 5;$/;"	C
NUM_CONSTRAINTS	src/zephyrchain_circuit.rs	/^const NUM_CONSTRAINTS: usize = 4;$/;"	C
NaturalLanguage	src/hdcmodels/hdcmodels.rs	/^    NaturalLanguage(String),$/;"	e	enum:DataItem
Negate	src/smart_contract/types.rs	/^    Negate,$/;"	e	enum:UnaryOperator
Network	src/network/lib.rs	/^impl Network {$/;"	c
Network	src/network/lib.rs	/^pub struct Network {$/;"	s
Network	src/network/mod.rs	/^impl Network {$/;"	c
Network	src/network/mod.rs	/^pub struct Network {$/;"	s
NetworkConfig	src/api/handlers/network_handler.rs	/^struct NetworkConfig {$/;"	s
NetworkConfig	src/api/models/request/network_request.rs	/^pub struct NetworkConfig {$/;"	s
NetworkConfig	src/api/models/response/network_response.rs	/^pub struct NetworkConfig {$/;"	s
NetworkConfig	src/api/routes/network.rs	/^struct NetworkConfig {$/;"	s
NetworkConfig	src/network/config.rs	/^impl Default for NetworkConfig {$/;"	c
NetworkConfig	src/network/config.rs	/^impl NetworkConfig {$/;"	c
NetworkConfig	src/network/config.rs	/^pub struct NetworkConfig {$/;"	s
NetworkError	src/error_handling/error.rs	/^    NetworkError(#[from] NetworkError),$/;"	e	enum:Error
NetworkError	src/error_handling/error.rs	/^pub enum NetworkError {$/;"	g
NetworkError	src/error_handling/network_error.rs	/^pub enum NetworkError {$/;"	g
NetworkError	src/network/error.rs	/^impl Error for NetworkError {}$/;"	c
NetworkError	src/network/error.rs	/^impl From<libp2p::core::transport::TransportError> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl From<libp2p::core::upgrade::ProtocolError> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl From<libp2p::identity::error::SigningError> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl From<libp2p::kad::KademliaError> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl From<serde_json::Error> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl From<std::io::Error> for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^impl fmt::Display for NetworkError {$/;"	c
NetworkError	src/network/error.rs	/^pub enum NetworkError {$/;"	g
NetworkError	src/network/mod.rs	/^pub enum NetworkError {$/;"	g
NetworkManager	src/network/network_manager.rs	/^impl NetworkManager {$/;"	c
NetworkManager	src/network/network_manager.rs	/^pub struct NetworkManager {$/;"	s
NetworkStats	src/api/handlers/network_handler.rs	/^struct NetworkStats {$/;"	s
NetworkStats	src/api/models/response/network_response.rs	/^pub struct NetworkStats {$/;"	s
NetworkStats	src/api/routes/network.rs	/^struct NetworkStats {$/;"	s
NetworkUnavailable	src/error_handling/network_error.rs	/^    NetworkUnavailable,$/;"	e	enum:NetworkError
NewProposal	src/chain/governance/governance_engine.rs	/^    NewProposal(Proposal),$/;"	e	enum:GovernanceMessage
NewTransactionRequest	src/api/api.rs	/^struct NewTransactionRequest {$/;"	s
NewVote	src/chain/governance/governance_engine.rs	/^    NewVote(Vote),$/;"	e	enum:GovernanceMessage
No	src/api/models/request/governance_request.rs	/^    No,$/;"	e	enum:VoteType
No	src/chain/governance/voting.rs	/^    No,$/;"	e	enum:VoteType
NoOngoingVoting	src/chain/quantum_voting/error.rs	/^    NoOngoingVoting,$/;"	e	enum:VotingError
NoRegisteredVoters	src/chain/quantum_voting/error.rs	/^    NoRegisteredVoters,$/;"	e	enum:VotingError
NoSuitableCompressionScheme	src/chain/quantum_voting/error.rs	/^    NoSuitableCompressionScheme,$/;"	e	enum:VotingError
NoSuitableErrorCorrectionCode	src/chain/quantum_voting/error.rs	/^    NoSuitableErrorCorrectionCode,$/;"	e	enum:VotingError
Node	src/chain/node.rs	/^impl Node {$/;"	c
Node	src/chain/node.rs	/^pub struct Node {$/;"	s
NodeConfig	src/chain/node.rs	/^pub struct NodeConfig {$/;"	s
NodeId	src/utils/node_id.rs	/^impl FromStr for NodeId {$/;"	c
NodeId	src/utils/node_id.rs	/^impl Hash for NodeId {$/;"	c
NodeId	src/utils/node_id.rs	/^impl NodeId {$/;"	c
NodeId	src/utils/node_id.rs	/^impl fmt::Display for NodeId {$/;"	c
NodeId	src/utils/node_id.rs	/^pub struct NodeId(String);$/;"	s
NodeIdError	src/utils/node_id.rs	/^pub enum NodeIdError {$/;"	g
NodeMessage	src/network/node_message.rs	/^impl NodeMessage {$/;"	c
NodeMessage	src/network/node_message.rs	/^pub enum NodeMessage {$/;"	g
NodeMessageError	src/network/node_message.rs	/^pub enum NodeMessageError {$/;"	g
NodeMessageHandler	src/network/node_message.rs	/^impl NodeMessageHandler {$/;"	c
NodeMessageHandler	src/network/node_message.rs	/^pub struct NodeMessageHandler {$/;"	s
NodeNotFound	src/chain/state/merkle_trie.rs	/^    NodeNotFound,$/;"	e	enum:MerkleTrieError
Not	src/smart_contract/types.rs	/^    Not,$/;"	e	enum:UnaryOperator
NotEquals	src/smart_contract/types.rs	/^    NotEquals,$/;"	e	enum:BinaryOperator
Null	src/smart_contract/types.rs	/^    Null,$/;"	e	enum:Value
OffChainTransaction	src/chain/state_channel.rs	/^#[derive(pub struct OffChainTransaction {$/;"	s
OnlineLearningHDCModel	src/hdcmodels/continuous_learning/online_learning.rs	/^impl OnlineLearningHDCModel {$/;"	c
OnlineLearningHDCModel	src/hdcmodels/continuous_learning/online_learning.rs	/^pub struct OnlineLearningHDCModel {$/;"	s
Open	src/api/models/request/governance_request.rs	/^    Open,$/;"	e	enum:ProposalStatus
Operation	src/smart_contract/types.rs	/^pub enum Operation {$/;"	g
OptimizationProblem	src/optimization_problems/optimization_problem.rs	/^pub trait OptimizationProblem {$/;"	i
OptimizedHDCModel	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^impl OptimizedHDCModel {$/;"	c
OptimizedHDCModel	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^pub struct OptimizedHDCModel {$/;"	s
Or	src/smart_contract/types.rs	/^    Or,$/;"	e	enum:BinaryOperator
Other	src/error_handling/network_error.rs	/^    Other(String),$/;"	e	enum:NetworkError
Other	src/network/error.rs	/^    Other(String),$/;"	e	enum:NetworkError
Output	src/zkp/math.rs	/^    type Output = Self;$/;"	t	implementation:FieldElement
PING_INTERVAL	src/network/protocol.rs	/^pub const PING_INTERVAL: u64 = 60;$/;"	C
PONG_TIMEOUT	src/network/protocol.rs	/^pub const PONG_TIMEOUT: u64 = 30;$/;"	C
PROTOCOL_VERSION	src/network/protocol.rs	/^pub const PROTOCOL_VERSION: u32 = 2;$/;"	C
PRUNE_INTERVAL	src/chain/shard.rs	/^const PRUNE_INTERVAL: Duration = Duration::from_secs(86400); \/\/ 24 hours$/;"	C
ParallelHDCInference	src/hdcmodels/parallel_processing.rs	/^impl ParallelHDCInference {$/;"	c
ParallelHDCInference	src/hdcmodels/parallel_processing.rs	/^pub struct ParallelHDCInference {$/;"	s
ParallelHDCTrainer	src/hdcmodels/parallel_processing.rs	/^impl ParallelHDCTrainer {$/;"	c
ParallelHDCTrainer	src/hdcmodels/parallel_processing.rs	/^pub struct ParallelHDCTrainer {$/;"	s
ParallelHDCValidator	src/hdcmodels/parallel_processing.rs	/^impl ParallelHDCValidator {$/;"	c
ParallelHDCValidator	src/hdcmodels/parallel_processing.rs	/^pub struct ParallelHDCValidator {$/;"	s
Parser	src/smart_contract/parser.rs	/^impl Parser {$/;"	c
Parser	src/smart_contract/parser.rs	/^pub struct Parser;$/;"	s
Path	src/api/middleware/authorization.rs	/^enum Path {$/;"	g
Peer	src/network/p2p/peer.rs	/^impl Peer {$/;"	c
Peer	src/network/p2p/peer.rs	/^pub struct Peer {$/;"	s
PeerDisconnected	src/error_handling/network_error.rs	/^    PeerDisconnected,$/;"	e	enum:NetworkError
PeerDiscovery	src/network/protocol.rs	/^    PeerDiscovery {$/;"	e	enum:ProtocolMessage
PeerError	src/network/error.rs	/^    PeerError(String),$/;"	e	enum:NetworkError
PeerError	src/network/mod.rs	/^    PeerError(#[from] PeerError),$/;"	e	enum:NetworkError
PeerError	src/network/p2p/peer.rs	/^impl From<tls::TLSError> for PeerError {$/;"	c
PeerError	src/network/p2p/peer.rs	/^pub enum PeerError {$/;"	g
PeerInfo	src/api/handlers/network_handler.rs	/^impl PeerInfo {$/;"	c
PeerInfo	src/api/handlers/network_handler.rs	/^struct PeerInfo {$/;"	s
PeerInfo	src/api/models/request/network_request.rs	/^pub struct PeerInfo {$/;"	s
PeerInfo	src/api/models/response/network_response.rs	/^pub struct PeerInfo {$/;"	s
PeerInfo	src/api/routes/network.rs	/^struct PeerInfo {$/;"	s
PeerNotFound	src/error_handling/network_error.rs	/^    PeerNotFound(String),$/;"	e	enum:NetworkError
PeerProcessingFailed	src/network/node_message.rs	/^    PeerProcessingFailed(String),$/;"	e	enum:NodeMessageError
PeerRequest	src/network/node_message.rs	/^    PeerRequest(NodeId),$/;"	e	enum:NodeMessage
PeerResponse	src/network/node_message.rs	/^    PeerResponse(Vec<NodeId>),$/;"	e	enum:NodeMessage
PeerRetrievalFailed	src/network/node_message.rs	/^    PeerRetrievalFailed(String),$/;"	e	enum:NodeMessageError
Peers	src/network/p2p/message.rs	/^    Peers(Vec<String>),$/;"	e	enum:Message
Pending	src/api/models/request/transaction_request.rs	/^    Pending,$/;"	e	enum:TransactionStatusType
Pending	src/chain/governance/proposal.rs	/^    Pending,$/;"	e	enum:ProposalStatus
Permission	src/api/middleware/authorization.rs	/^pub enum Permission {$/;"	g
Permission	src/secure_core/access_control.rs	/^pub enum Permission {$/;"	g
PermissionDeniedError	src/error_handling/error.rs	/^    PermissionDeniedError(String),$/;"	e	enum:Error
Ping	src/network/node_message.rs	/^    Ping,$/;"	e	enum:NodeMessage
Ping	src/network/p2p/message.rs	/^    Ping,$/;"	e	enum:Message
Ping	src/network/protocol.rs	/^    Ping,$/;"	e	enum:ProtocolMessage
PoUWParameters	src/api/routes/consensus.rs	/^struct PoUWParameters {$/;"	s
PoUWState	src/api/routes/consensus.rs	/^struct PoUWState {$/;"	s
PolynomialCommitment	src/zkp/math.rs	/^impl PolynomialCommitment {$/;"	c
PolynomialCommitment	src/zkp/math.rs	/^pub struct PolynomialCommitment {$/;"	s
Pong	src/network/node_message.rs	/^    Pong,$/;"	e	enum:NodeMessage
Pong	src/network/p2p/message.rs	/^    Pong,$/;"	e	enum:Message
Pong	src/network/protocol.rs	/^    Pong,$/;"	e	enum:ProtocolMessage
Post	src/api/middleware/authorization.rs	/^    Post,$/;"	e	enum:Method
PostQuantumCertificateSigningRequest	src/chain/node.rs	/^pub struct PostQuantumCertificateSigningRequest {$/;"	s
PostQuantumError	src/crypto/post_quantum.rs	/^pub enum PostQuantumError {$/;"	g
PostQuantumSignatureError	src/chain/block.rs	/^    PostQuantumSignatureError(String),$/;"	e	enum:BlockError
PostQuantumSignatureError	src/chain/transaction.rs	/^    PostQuantumSignatureError(String),$/;"	e	enum:TransactionError
PostQuantumTLSConfig	src/network/tls.rs	/^impl PostQuantumTLSConfig {$/;"	c
PostQuantumTLSConfig	src/network/tls.rs	/^pub struct PostQuantumTLSConfig {$/;"	s
PostQuantumTLSConnection	src/network/tls.rs	/^impl PostQuantumTLSConnection {$/;"	c
PostQuantumTLSConnection	src/network/tls.rs	/^pub struct PostQuantumTLSConnection {$/;"	s
Preprocessor	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^impl Preprocessor {$/;"	c
Preprocessor	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^pub struct Preprocessor {$/;"	s
ProblemSolution	src/optimization_problems/problem_solution.rs	/^impl ProblemSolution {$/;"	c
ProblemSolution	src/optimization_problems/problem_solution.rs	/^pub struct ProblemSolution {$/;"	s
Profiler	src/hdcmodels/performance_optimization/profiling.rs	/^impl Profiler {$/;"	c
Profiler	src/hdcmodels/performance_optimization/profiling.rs	/^pub struct Profiler {$/;"	s
Proof	src/chain/transaction.rs	/^pub struct Proof {$/;"	s
Proposal	src/chain/governance/proposal.rs	/^impl Hashable for Proposal {$/;"	c
Proposal	src/chain/governance/proposal.rs	/^impl Proposal {$/;"	c
Proposal	src/chain/governance/proposal.rs	/^pub struct Proposal {$/;"	s
ProposalAnalysis	src/hdcmodels/governance_integration/proposal_analysis.rs	/^pub struct ProposalAnalysis {$/;"	s
ProposalAnalyzer	src/hdcmodels/governance_integration/proposal_analysis.rs	/^impl ProposalAnalyzer {$/;"	c
ProposalAnalyzer	src/hdcmodels/governance_integration/proposal_analysis.rs	/^pub struct ProposalAnalyzer {$/;"	s
ProposalInfo	src/api/handlers/governance_handler.rs	/^impl ProposalInfo {$/;"	c
ProposalInfo	src/api/handlers/governance_handler.rs	/^struct ProposalInfo {$/;"	s
ProposalInfo	src/api/routes/governance.rs	/^struct ProposalInfo {$/;"	s
ProposalMessage	src/chain/governance/proposal.rs	/^pub enum ProposalMessage {$/;"	g
ProposalStatus	src/api/models/request/governance_request.rs	/^pub enum ProposalStatus {$/;"	g
ProposalStatus	src/chain/governance/proposal.rs	/^impl ProposalStatus {$/;"	c
ProposalStatus	src/chain/governance/proposal.rs	/^pub enum ProposalStatus {$/;"	g
ProtocolError	src/network/error.rs	/^    ProtocolError(String),$/;"	e	enum:NetworkError
ProtocolError	src/network/protocol.rs	/^pub enum ProtocolError {$/;"	g
ProtocolMessage	src/network/protocol.rs	/^    pub struct ProtocolMessage {$/;"	s	module:protocol_message
ProtocolMessage	src/network/protocol.rs	/^impl ProtocolMessage {$/;"	c
ProtocolMessage	src/network/protocol.rs	/^pub enum ProtocolMessage {$/;"	g
PublicInputs	src/zephyrchain_circuit.rs	/^    type PublicInputs = Vec<BaseElement>;$/;"	t	implementation:ZephyrChainCircuit
PublicKey	src/qup/crypto.rs	/^    type PublicKey = DilithiumPublicKey;$/;"	t	implementation:QUPCrypto
PublicKey	src/qup/crypto.rs	/^    type PublicKey = KyberPublicKey;$/;"	t	implementation:QUPCrypto
QDPoSParameters	src/api/routes/consensus.rs	/^struct QDPoSParameters {$/;"	s
QDPoSState	src/api/routes/consensus.rs	/^struct QDPoSState {$/;"	s
QKDFailed	src/network/node_message.rs	/^    QKDFailed(String),$/;"	e	enum:NodeMessageError
QKDFailed	src/network/protocol.rs	/^    QKDFailed(String),$/;"	e	enum:ProtocolError
QKDKey	src/network/node_message.rs	/^pub struct QKDKey {$/;"	s
QKDKey	src/network/protocol.rs	/^pub struct QKDKey {$/;"	s
QKDKeyConfirmation	src/network/node_message.rs	/^    QKDKeyConfirmation,$/;"	e	enum:NodeMessage
QKDKeyConfirmation	src/network/protocol.rs	/^    QKDKeyConfirmation,$/;"	e	enum:ProtocolMessage
QKDKeyConfirmationShard	src/network/shard_message.rs	/^    QKDKeyConfirmationShard,$/;"	e	enum:ShardMessage
QKDKeyRequest	src/network/node_message.rs	/^    QKDKeyRequest,$/;"	e	enum:NodeMessage
QKDKeyRequest	src/network/protocol.rs	/^    QKDKeyRequest,$/;"	e	enum:ProtocolMessage
QKDKeyRequestShard	src/network/shard_message.rs	/^    QKDKeyRequestShard,$/;"	e	enum:ShardMessage
QKDKeyResponse	src/network/node_message.rs	/^    QKDKeyResponse(QKDKey),$/;"	e	enum:NodeMessage
QKDKeyResponse	src/network/protocol.rs	/^    QKDKeyResponse {$/;"	e	enum:ProtocolMessage
QKDKeyResponseShard	src/network/shard_message.rs	/^    QKDKeyResponseShard(QKDKey),$/;"	e	enum:ShardMessage
QRNGConfig	src/quantum_entropy/config.rs	/^impl QRNGConfig {$/;"	c
QRNGConfig	src/quantum_entropy/config.rs	/^pub struct QRNGConfig {$/;"	s
QRNGError	src/quantum_entropy/qrng.rs	/^pub enum QRNGError {$/;"	g
QUPBlock	src/network/node_message.rs	/^pub struct QUPBlock {$/;"	s
QUPBlock	src/qup/block.rs	/^impl QUPBlock {$/;"	c
QUPBlock	src/qup/block.rs	/^pub struct QUPBlock {$/;"	s
QUPBlockCommit	src/network/node_message.rs	/^    QUPBlockCommit(QUPBlock),$/;"	e	enum:NodeMessage
QUPBlockHeader	src/qup/types.rs	/^pub struct QUPBlockHeader {$/;"	s
QUPBlockProposal	src/network/node_message.rs	/^    QUPBlockProposal(QUPBlock),$/;"	e	enum:NodeMessage
QUPConfig	src/qup/config.rs	/^impl QUPConfig {$/;"	c
QUPConfig	src/qup/config.rs	/^pub struct QUPConfig {$/;"	s
QUPConsensus	src/qup/consensus.rs	/^impl QUPConsensus {$/;"	c
QUPConsensus	src/qup/consensus.rs	/^pub struct QUPConsensus {$/;"	s
QUPCrypto	src/qup/crypto.rs	/^impl EncryptionScheme for QUPCrypto {$/;"	c
QUPCrypto	src/qup/crypto.rs	/^impl Hasher for QUPCrypto {$/;"	c
QUPCrypto	src/qup/crypto.rs	/^impl QUPCrypto {$/;"	c
QUPCrypto	src/qup/crypto.rs	/^impl SignatureScheme for QUPCrypto {$/;"	c
QUPCrypto	src/qup/crypto.rs	/^pub struct QUPCrypto {$/;"	s
QUPDecoding	src/hdcmodels/qup_integration/qup_decoding.rs	/^impl QUPDecoding {$/;"	c
QUPDecoding	src/hdcmodels/qup_integration/qup_decoding.rs	/^pub struct QUPDecoding {$/;"	s
QUPDelegator	src/qup/delegator.rs	/^impl QUPDelegator {$/;"	c
QUPDelegator	src/qup/delegator.rs	/^pub struct QUPDelegator {$/;"	s
QUPEncoding	src/hdcmodels/qup_integration/qup_encoding.rs	/^impl QUPEncoding {$/;"	c
QUPEncoding	src/hdcmodels/qup_integration/qup_encoding.rs	/^pub struct QUPEncoding {$/;"	s
QUPError	src/qup/error.rs	/^impl fmt::Display for QUPError {$/;"	c
QUPError	src/qup/error.rs	/^impl std::error::Error for QUPError {}$/;"	c
QUPError	src/qup/error.rs	/^pub enum QUPError {$/;"	g
QUPErrorCorrection	src/hdcmodels/qup_integration/qup_error_correction.rs	/^impl QUPErrorCorrection {$/;"	c
QUPErrorCorrection	src/hdcmodels/qup_integration/qup_error_correction.rs	/^pub struct QUPErrorCorrection {$/;"	s
QUPKeyExchange	src/network/node_message.rs	/^    QUPKeyExchange(QUPKeyExchange),$/;"	e	enum:NodeMessage
QUPKeyExchange	src/network/node_message.rs	/^pub struct QUPKeyExchange {$/;"	s
QUPKeyPair	src/qup/crypto.rs	/^pub struct QUPKeyPair {$/;"	s
QUPParameters	src/api/handlers/qup_handler.rs	/^struct QUPParameters {$/;"	s
QUPParameters	src/api/models/request/qup_request.rs	/^pub struct QUPParameters {$/;"	s
QUPParameters	src/api/models/response/qup_response.rs	/^pub struct QUPParameters {$/;"	s
QUPShardBlockCommit	src/network/shard_message.rs	/^    QUPShardBlockCommit {$/;"	e	enum:ShardMessage
QUPShardBlockProposal	src/network/shard_message.rs	/^    QUPShardBlockProposal {$/;"	e	enum:ShardMessage
QUPShardUsefulWork	src/network/shard_message.rs	/^    QUPShardUsefulWork(QUPUsefulWork),$/;"	e	enum:ShardMessage
QUPShardVote	src/network/shard_message.rs	/^    QUPShardVote(QUPVote),$/;"	e	enum:ShardMessage
QUPSignature	src/qup/crypto.rs	/^pub struct QUPSignature {$/;"	s
QUPState	src/api/handlers/qup_handler.rs	/^struct QUPState {$/;"	s
QUPState	src/api/models/response/qup_response.rs	/^pub struct QUPState {$/;"	s
QUPState	src/qup/state.rs	/^impl QUPState {$/;"	c
QUPState	src/qup/state.rs	/^pub struct QUPState {$/;"	s
QUPStateUpdateError	src/chain/transaction.rs	/^    QUPStateUpdateError(String),$/;"	e	enum:TransactionError
QUPTransaction	src/qup/types.rs	/^pub struct QUPTransaction {$/;"	s
QUPUsefulWork	src/network/node_message.rs	/^    QUPUsefulWork(QUPUsefulWork),$/;"	e	enum:NodeMessage
QUPUsefulWork	src/network/node_message.rs	/^pub struct QUPUsefulWork {$/;"	s
QUPValidator	src/qup/validator.rs	/^impl QUPValidator {$/;"	c
QUPValidator	src/qup/validator.rs	/^pub struct QUPValidator {$/;"	s
QUPVote	src/network/node_message.rs	/^    QUPVote(QUPVote),$/;"	e	enum:NodeMessage
QUPVote	src/network/node_message.rs	/^pub struct QUPVote {$/;"	s
QUPVote	src/qup/types.rs	/^pub struct QUPVote {$/;"	s
QuantumChannel	src/network/quantum_resistant.rs	/^impl QuantumChannel {$/;"	c
QuantumChannel	src/network/quantum_resistant.rs	/^struct QuantumChannel {$/;"	s
QuantumCommunication	src/chain/quantum_voting/quantum_communication.rs	/^impl QuantumCommunication {$/;"	c
QuantumCommunication	src/chain/quantum_voting/quantum_communication.rs	/^pub struct QuantumCommunication {$/;"	s
QuantumCryptography	src/chain/quantum_voting/quantum_cryptography.rs	/^impl QuantumCryptography {$/;"	c
QuantumCryptography	src/chain/quantum_voting/quantum_cryptography.rs	/^pub struct QuantumCryptography {$/;"	s
QuantumEntropy	src/quantum_entropy/qrng.rs	/^impl QuantumEntropy {$/;"	c
QuantumEntropy	src/quantum_entropy/qrng.rs	/^pub struct QuantumEntropy {$/;"	s
QuantumEntropySource	src/chain/quantum_entropy.rs	/^impl QuantumEntropySource {$/;"	c
QuantumEntropySource	src/chain/quantum_entropy.rs	/^pub struct QuantumEntropySource {$/;"	s
QuantumErrorCorrectionError	src/hdcmodels/qup_integration/qup_error_correction.rs	/^pub enum QuantumErrorCorrectionError {$/;"	g
QuantumErrorCorrectionFailed	src/chain/quantum_voting/error.rs	/^    QuantumErrorCorrectionFailed(usize),$/;"	e	enum:VotingError
QuantumGate	src/crypto/quantum_state.rs	/^pub enum QuantumGate {$/;"	g
QuantumKeyDistribution	src/chain/quantum_voting/quantum_key_distribution.rs	/^impl QuantumKeyDistribution {$/;"	c
QuantumKeyDistribution	src/chain/quantum_voting/quantum_key_distribution.rs	/^pub struct QuantumKeyDistribution {$/;"	s
QuantumKeyDistributionError	src/chain/quantum_voting/error.rs	/^    QuantumKeyDistributionError,$/;"	e	enum:VotingError
QuantumKeyGenerationFailed	src/chain/quantum_voting/types.rs	/^    QuantumKeyGenerationFailed,$/;"	e	enum:VotingError
QuantumKeyManagement	src/chain/quantum_voting/quantum_key_management.rs	/^impl QuantumKeyManagement {$/;"	c
QuantumKeyManagement	src/chain/quantum_voting/quantum_key_management.rs	/^pub struct QuantumKeyManagement {$/;"	s
QuantumNetworkConnectionFailed	src/chain/quantum_voting/error.rs	/^    QuantumNetworkConnectionFailed(String),$/;"	e	enum:VotingError
QuantumNoiseSimulationError	src/chain/quantum_voting/error.rs	/^pub enum QuantumNoiseSimulationError {$/;"	g
QuantumNoiseSimulationError	src/chain/quantum_voting/quantum_voting.rs	/^pub enum QuantumNoiseSimulationError {$/;"	g	implementation:QuantumVoting
QuantumResistantConnection	src/network/quantum_resistant.rs	/^impl QuantumResistantConnection {$/;"	c
QuantumResistantConnection	src/network/quantum_resistant.rs	/^impl QuantumResistantConnectionManager for QuantumResistantConnection {$/;"	c
QuantumResistantConnection	src/network/quantum_resistant.rs	/^pub struct QuantumResistantConnection {$/;"	s
QuantumResistantConnectionManager	src/chain/quantum_entropy.rs	/^impl QuantumResistantConnectionManager {$/;"	c
QuantumResistantConnectionManager	src/chain/quantum_entropy.rs	/^pub struct QuantumResistantConnectionManager {$/;"	s
QuantumResistantConnectionManager	src/network/quantum_resistant.rs	/^pub trait QuantumResistantConnectionManager {$/;"	i
QuantumResistantMerkleTree	src/zkp/crypto.rs	/^impl QuantumResistantMerkleTree {$/;"	c
QuantumResistantMerkleTree	src/zkp/crypto.rs	/^pub struct QuantumResistantMerkleTree {$/;"	s
QuantumResistantSignature	src/secure_core/quantum_resistant_signatures.rs	/^pub struct QuantumResistantSignature {$/;"	s
QuantumResistantSignatureError	src/secure_core/quantum_resistant_signatures.rs	/^pub enum QuantumResistantSignatureError {$/;"	g
QuantumResistantSigner	src/secure_core/quantum_resistant_signatures.rs	/^impl QuantumResistantSigner {$/;"	c
QuantumResistantSigner	src/secure_core/quantum_resistant_signatures.rs	/^pub struct QuantumResistantSigner {$/;"	s
QuantumSecureOptimizer	src/hdcmodels/smart_contract_generation/optimization.rs	/^impl QuantumSecureOptimizer {$/;"	c
QuantumSimulationError	src/chain/quantum_voting/error.rs	/^    QuantumSimulationError,$/;"	e	enum:VotingError
QuantumState	src/crypto/quantum_state.rs	/^pub trait QuantumState {$/;"	i
QuantumState	src/network/node_message.rs	/^pub struct QuantumState {$/;"	s
QuantumStateDecoding	src/chain/quantum_voting/quantum_state_decoding.rs	/^impl QuantumStateDecoding {$/;"	c
QuantumStateDecoding	src/chain/quantum_voting/quantum_state_decoding.rs	/^pub struct QuantumStateDecoding {}$/;"	s
QuantumStateDistribution	src/network/node_message.rs	/^    QuantumStateDistribution(QuantumState),$/;"	e	enum:NodeMessage
QuantumStateDistribution	src/network/protocol.rs	/^    QuantumStateDistribution {$/;"	e	enum:ProtocolMessage
QuantumStateDistributionFailed	src/chain/quantum_voting/types.rs	/^    QuantumStateDistributionFailed,$/;"	e	enum:VotingError
QuantumStateDistributionFailed	src/network/node_message.rs	/^    QuantumStateDistributionFailed(String),$/;"	e	enum:NodeMessageError
QuantumStateDistributionFailed	src/network/protocol.rs	/^    QuantumStateDistributionFailed(String),$/;"	e	enum:ProtocolError
QuantumStateDistributionShard	src/network/shard_message.rs	/^    QuantumStateDistributionShard(QuantumState),$/;"	e	enum:ShardMessage
QuantumStateEncoding	src/chain/quantum_voting/quantum_state_encoding.rs	/^impl QuantumStateEncoding {$/;"	c
QuantumStateEncoding	src/chain/quantum_voting/quantum_state_encoding.rs	/^pub struct QuantumStateEncoding {$/;"	s
QuantumStateMeasurementResults	src/network/node_message.rs	/^    QuantumStateMeasurementResults(Vec<bool>),$/;"	e	enum:NodeMessage
QuantumStateMeasurementResults	src/network/protocol.rs	/^    QuantumStateMeasurementResults {$/;"	e	enum:ProtocolMessage
QuantumStateMeasurementResultsShard	src/network/shard_message.rs	/^    QuantumStateMeasurementResultsShard(Vec<bool>),$/;"	e	enum:ShardMessage
QuantumStateMessage	src/network/node_message.rs	/^    QuantumStateMessage(TimeBinState),$/;"	e	enum:NodeMessage
QuantumStatePreparation	src/chain/quantum_voting/quantum_state_preparation.rs	/^impl QuantumStatePreparation {$/;"	c
QuantumStatePreparation	src/chain/quantum_voting/quantum_state_preparation.rs	/^pub struct QuantumStatePreparation {$/;"	s
QuantumStateSendingFailed	src/chain/quantum_voting/error.rs	/^    QuantumStateSendingFailed(String),$/;"	e	enum:VotingError
QuantumStateTomographyError	src/chain/quantum_voting/error.rs	/^    QuantumStateTomographyError,$/;"	e	enum:VotingError
QuantumStateTransmission	src/chain/quantum_voting/quantum_state_transmission.rs	/^impl QuantumStateTransmission {$/;"	c
QuantumStateTransmission	src/chain/quantum_voting/quantum_state_transmission.rs	/^pub struct QuantumStateTransmission {}$/;"	s
QuantumStateVerification	src/chain/quantum_voting/quantum_state_verification.rs	/^impl QuantumStateVerification {$/;"	c
QuantumStateVerification	src/chain/quantum_voting/quantum_state_verification.rs	/^pub struct QuantumStateVerification {$/;"	s
QuantumTeleportationError	src/chain/quantum_voting/error.rs	/^    QuantumTeleportationError,$/;"	e	enum:VotingError
QuantumVoting	src/chain/quantum_voting/mod.rs	/^impl QuantumVoting {$/;"	c
QuantumVoting	src/chain/quantum_voting/mod.rs	/^pub struct QuantumVoting {$/;"	s
QuantumVoting	src/chain/quantum_voting/quantum_voting.rs	/^impl QuantumVoting {$/;"	c
QuantumVoting	src/chain/quantum_voting/quantum_voting.rs	/^pub struct QuantumVoting {$/;"	s
RATE_LIMIT_WINDOW	src/api/middleware/rate_limiter.rs	/^const RATE_LIMIT_WINDOW: Duration = Duration::from_secs(60); \/\/ Rate limiting window (1 minute/;"	C
RandomNumberGeneratorError	src/quantum_entropy/qrng.rs	/^    RandomNumberGeneratorError(#[from] RandomNumberGeneratorError),$/;"	e	enum:QRNGError
RangeConstraint	src/zkp/constraint_system.rs	/^impl RangeConstraint {$/;"	c
RangeConstraint	src/zkp/constraint_system.rs	/^pub struct RangeConstraint {$/;"	s
RateLimiter	src/api/middleware/rate_limiter.rs	/^impl RateLimiter {$/;"	c
RateLimiter	src/api/middleware/rate_limiter.rs	/^struct RateLimiter {$/;"	s
RateLimiterMiddleware	src/api/middleware/rate_limiter.rs	/^impl RateLimiterMiddleware {$/;"	c
RateLimiterMiddleware	src/api/middleware/rate_limiter.rs	/^impl<S, B> Transform<S> for RateLimiterMiddleware$/;"	c
RateLimiterMiddleware	src/api/middleware/rate_limiter.rs	/^pub struct RateLimiterMiddleware {$/;"	s
RateLimiterMiddlewareMiddleware	src/api/middleware/rate_limiter.rs	/^impl<S, B> Service for RateLimiterMiddlewareMiddleware<S>$/;"	c
RateLimiterMiddlewareMiddleware	src/api/middleware/rate_limiter.rs	/^pub struct RateLimiterMiddlewareMiddleware<S> {$/;"	s
ReadBlocks	src/api/middleware/authorization.rs	/^    ReadBlocks,$/;"	e	enum:Permission
ReadData	src/secure_core/access_control.rs	/^    ReadData,$/;"	e	enum:Permission
ReadTransactions	src/api/middleware/authorization.rs	/^    ReadTransactions,$/;"	e	enum:Permission
ReceiveError	src/network/p2p/peer.rs	/^    ReceiveError,$/;"	e	enum:PeerError
ReceiverAccountNotFound	src/chain/state_transition.rs	/^    ReceiverAccountNotFound(String),$/;"	e	enum:StateTransitionError
RefreshTokenClaims	src/api/middleware/authentication.rs	/^struct RefreshTokenClaims {$/;"	s
RefreshTokenRequest	src/api/middleware/authentication.rs	/^struct RefreshTokenRequest {$/;"	s
Rejected	src/api/models/request/governance_request.rs	/^    Rejected,$/;"	e	enum:ProposalStatus
Request	src/api/middleware/authorization.rs	/^    type Request = ServiceRequest;$/;"	t
Request	src/api/middleware/rate_limiter.rs	/^    type Request = ServiceRequest;$/;"	t
Request	src/api/middleware/request_validator.rs	/^    type Request = ServiceRequest;$/;"	t
RequestModel	src/api/middleware/request_validator.rs	/^impl Default for RequestModel {$/;"	c
RequestModel	src/api/middleware/request_validator.rs	/^struct RequestModel {$/;"	s
RequestState	src/network/sync/state_sync.rs	/^    RequestState { shard_id: u64 },$/;"	e	enum:StateSyncMessage
RequestValidatorMiddleware	src/api/middleware/request_validator.rs	/^impl<S, B> Transform<S> for RequestValidatorMiddleware$/;"	c
RequestValidatorMiddleware	src/api/middleware/request_validator.rs	/^pub struct RequestValidatorMiddleware;$/;"	s
RequestValidatorMiddlewareMiddleware	src/api/middleware/request_validator.rs	/^impl<S, B> Service for RequestValidatorMiddlewareMiddleware<S>$/;"	c
RequestValidatorMiddlewareMiddleware	src/api/middleware/request_validator.rs	/^pub struct RequestValidatorMiddlewareMiddleware<S> {$/;"	s
Requested	src/chain/state_channel.rs	/^    Requested,$/;"	e	enum:ArbitrationStatus
Resolved	src/chain/state_channel.rs	/^    Resolved { resolution: DisputeResolution },$/;"	e	enum:ArbitrationStatus
ResourceNotFound	src/error_handling/network_error.rs	/^    ResourceNotFound(String),$/;"	e	enum:NetworkError
ResourceNotFoundError	src/error_handling/error.rs	/^    ResourceNotFoundError(String),$/;"	e	enum:Error
Response	src/api/middleware/authorization.rs	/^    type Response = ServiceResponse<B>;$/;"	t
Response	src/api/middleware/rate_limiter.rs	/^    type Response = ServiceResponse<B>;$/;"	t
Response	src/api/middleware/request_validator.rs	/^    type Response = ServiceResponse<B>;$/;"	t
Result	src/error_handling/error_utils.rs	/^impl<T, E: Into<Error>> ErrorExt<T> for std::result::Result<T, E> {$/;"	c
Result	src/error_handling/result.rs	/^pub type Result<T> = std::result::Result<T, Error>;/;"	t
Return	src/smart_contract/types.rs	/^    Return { value: Expression },$/;"	e	enum:Operation
RevokeTokenRequest	src/api/middleware/authentication.rs	/^struct RevokeTokenRequest {$/;"	s
RewardClaimed	src/chain/governance/rewards.rs	/^    RewardClaimed {$/;"	e	enum:RewardMessage
RewardDistributed	src/chain/governance/rewards.rs	/^    RewardDistributed {$/;"	e	enum:RewardMessage
RewardDistribution	src/chain/governance/governance_engine.rs	/^    RewardDistribution(HashMap<String, u64>),$/;"	e	enum:GovernanceMessage
RewardDistributor	src/qup/reward.rs	/^impl RewardDistributor {$/;"	c
RewardDistributor	src/qup/reward.rs	/^pub struct RewardDistributor {$/;"	s
RewardError	src/chain/governance/rewards.rs	/^pub enum RewardError {$/;"	g
RewardMessage	src/chain/governance/rewards.rs	/^pub enum RewardMessage {$/;"	g
RewardPoolUpdated	src/chain/governance/rewards.rs	/^    RewardPoolUpdated {$/;"	e	enum:RewardMessage
RewardRateUpdated	src/chain/governance/rewards.rs	/^    RewardRateUpdated {$/;"	e	enum:RewardMessage
RewardRateUpdated	src/chain/governance/staking.rs	/^    RewardRateUpdated {$/;"	e	enum:StakingMessage
RewardScheme	src/qup/config.rs	/^pub enum RewardScheme {$/;"	g
Rewards	src/chain/governance/rewards.rs	/^impl Rewards {$/;"	c
Rewards	src/chain/governance/rewards.rs	/^pub struct Rewards {$/;"	s
RewardsDistributed	src/chain/governance/staking.rs	/^    RewardsDistributed {$/;"	e	enum:StakingMessage
Role	src/api/middleware/authentication.rs	/^impl From<&str> for Role {$/;"	c
Role	src/api/middleware/authentication.rs	/^pub enum Role {$/;"	g
Role	src/secure_core/access_control.rs	/^pub enum Role {$/;"	g
RoundRobinLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^impl LoadBalancer for RoundRobinLoadBalancer {$/;"	c
RoundRobinLoadBalancer	src/hdcmodels/distributed_training/load_balancing.rs	/^pub struct RoundRobinLoadBalancer;$/;"	s
RustCode	src/hdcmodels/hdcmodels.rs	/^    RustCode(String),$/;"	e	enum:DataItem
SP_KEY_LIFETIME	src/secure_core/secure_vault.rs	/^const SP_KEY_LIFETIME: Duration = Duration::from_secs(86400); \/\/ Lifetime of SP keys (e.g., 24/;"	C
SUPPORTED_VERSIONS	src/hdcmodels/governance_integration/consensus_security.rs	/^        const SUPPORTED_VERSIONS: &[u32] = &[1, 2];$/;"	C	method:ConsensusSecurityMonitor::is_valid_block_version
Secp256k1Error	src/chain/transaction.rs	/^    Secp256k1Error(#[from] secp256k1::Error),$/;"	e	enum:TransactionError
SecretKey	src/qup/crypto.rs	/^    type SecretKey = DilithiumSecretKey;$/;"	t	implementation:QUPCrypto
SecretKey	src/qup/crypto.rs	/^    type SecretKey = KyberSecretKey;$/;"	t	implementation:QUPCrypto
SecureCommunication	src/secure_core/secure_communication.rs	/^impl SecureCommunication {$/;"	c
SecureCommunication	src/secure_core/secure_communication.rs	/^pub struct SecureCommunication {$/;"	s
SecureCommunicationError	src/secure_core/secure_communication.rs	/^pub enum SecureCommunicationError {$/;"	g
SecureHDCModelUpdate	src/hdcmodels/continuous_learning/secure_updates.rs	/^impl SecureHDCModelUpdate {$/;"	c
SecureHDCModelUpdate	src/hdcmodels/continuous_learning/secure_updates.rs	/^pub struct SecureHDCModelUpdate {$/;"	s
SecureHDCModelUpdateProposal	src/hdcmodels/continuous_learning/secure_updates.rs	/^impl GovernanceProposal for SecureHDCModelUpdateProposal {$/;"	c
SecureHDCModelUpdateProposal	src/hdcmodels/continuous_learning/secure_updates.rs	/^pub struct SecureHDCModelUpdateProposal {$/;"	s
SecureHDCModelUpdateVote	src/hdcmodels/continuous_learning/secure_updates.rs	/^impl SecureHDCModelUpdateVote {$/;"	c
SecureHDCModelUpdateVote	src/hdcmodels/continuous_learning/secure_updates.rs	/^pub struct SecureHDCModelUpdateVote {$/;"	s
SecureMessage	src/secure_core/secure_communication.rs	/^pub struct SecureMessage {$/;"	s
SecureStorage	src/secure_core/secure_storage.rs	/^impl SecureStorage {$/;"	c
SecureStorage	src/secure_core/secure_storage.rs	/^pub struct SecureStorage {$/;"	s
SecureStorageError	src/chain/blockchain.rs	/^    SecureStorageError(#[from] SecureStorageError),$/;"	e	enum:BlockchainError
SecureStorageError	src/chain/wallet.rs	/^    SecureStorageError(#[from] SecureStorageError),$/;"	e	enum:WalletError
SecureStorageError	src/secure_core/secure_storage.rs	/^pub enum SecureStorageError {$/;"	g
SecureVault	src/secure_core/secure_vault.rs	/^impl SecureVault {$/;"	c
SecureVault	src/secure_core/secure_vault.rs	/^pub struct SecureVault {$/;"	s
SecurityAnalysis	src/chain/quantum_voting/security_analysis.rs	/^impl SecurityAnalysis {$/;"	c
SecurityAnalysis	src/chain/quantum_voting/security_analysis.rs	/^pub struct SecurityAnalysis {$/;"	s
SecurityUtils	src/secure_core/security_utils.rs	/^impl SecurityUtils {$/;"	c
SecurityUtils	src/secure_core/security_utils.rs	/^pub struct SecurityUtils;$/;"	s
SendError	src/network/p2p/peer.rs	/^    SendError(String),$/;"	e	enum:PeerError
SenderAccountNotFound	src/chain/state_transition.rs	/^    SenderAccountNotFound(String),$/;"	e	enum:StateTransitionError
SerializationError	src/chain/shard.rs	/^    SerializationError(#[from] serde_json::Error),$/;"	e	enum:ShardError
SerializationError	src/chain/storage/database.rs	/^    SerializationError(String),$/;"	e	enum:DatabaseError
SerializationError	src/chain/storage/snapshot.rs	/^    SerializationError(String),$/;"	e	enum:SnapshotError
SerializationError	src/chain/transaction.rs	/^    SerializationError(#[from] serde_json::Error),$/;"	e	enum:TransactionError
SerializationError	src/error_handling/error.rs	/^    SerializationError(#[from] serde_json::Error),$/;"	e	enum:Error
SerializationError	src/secure_core/secure_storage.rs	/^    SerializationError(String),$/;"	e	enum:SecureStorageError
SerializationFailed	src/network/node_message.rs	/^    SerializationFailed(String),$/;"	e	enum:NodeMessageError
SerializationFailed	src/network/protocol.rs	/^    SerializationFailed(String),$/;"	e	enum:ProtocolError
Server	src/network/server.rs	/^impl Server {$/;"	c
Server	src/network/server.rs	/^pub struct Server {$/;"	s
Set	src/smart_contract/types.rs	/^    Set { key: String, value: Expression },$/;"	e	enum:Operation
Shard	src/chain/shard.rs	/^impl Shard {$/;"	c
Shard	src/chain/shard.rs	/^pub struct Shard {$/;"	s
ShardError	src/chain/shard.rs	/^pub enum ShardError {$/;"	g
ShardMessage	src/chain/shard.rs	/^enum ShardMessage {$/;"	g
ShardMessage	src/network/shard_message.rs	/^impl ShardMessage {$/;"	c
ShardMessage	src/network/shard_message.rs	/^pub enum ShardMessage {$/;"	g
ShardMessageHandler	src/network/shard_message.rs	/^impl ShardMessageHandler {$/;"	c
ShardMessageHandler	src/network/shard_message.rs	/^pub struct ShardMessageHandler {$/;"	s
ShardNotFound	src/chain/sharding.rs	/^    ShardNotFound(u64),$/;"	e	enum:ShardingError
ShardState	src/chain/shard.rs	/^impl Hash for ShardState {$/;"	c
ShardState	src/chain/shard.rs	/^pub struct ShardState {$/;"	s
Sharding	src/chain/sharding.rs	/^impl Sharding {$/;"	c
Sharding	src/chain/sharding.rs	/^pub struct Sharding {$/;"	s
ShardingError	src/chain/sharding.rs	/^pub enum ShardingError {$/;"	g
ShardingHash	src/crypto/hash.rs	/^impl AsRef<[u8]> for ShardingHash {$/;"	c
ShardingHash	src/crypto/hash.rs	/^impl From<Vec<u8>> for ShardingHash {$/;"	c
ShardingHash	src/crypto/hash.rs	/^pub struct ShardingHash(Vec<u8>);$/;"	s
Signature	src/qup/crypto.rs	/^    type Signature = QUPSignature;$/;"	t	implementation:QUPCrypto
SignatureVerificationFailed	src/chain/state/merkle_trie.rs	/^    SignatureVerificationFailed,$/;"	e	enum:MerkleTrieError
SignatureVerificationFailed	src/error_handling/error.rs	/^    SignatureVerificationFailed,$/;"	e	enum:CryptoError
SigningError	src/secure_core/quantum_resistant_signatures.rs	/^    SigningError(String),$/;"	e	enum:QuantumResistantSignatureError
SigningFailed	src/crypto/post_quantum.rs	/^    SigningFailed,$/;"	e	enum:PostQuantumError
SimilarityMetric	src/hdcmodels/hdcmodels.rs	/^pub enum SimilarityMetric {$/;"	g
SimilarityMetric	src/hdcmodels/mod.rs	/^pub enum SimilarityMetric {$/;"	g
SmartContract	src/hdcmodels/hdcmodels.rs	/^    SmartContract(String),$/;"	e	enum:DataItem
SmartContract	src/smart_contract/types.rs	/^pub struct SmartContract {$/;"	s
SmartContractError	src/error_handling/error.rs	/^    SmartContractError(#[from] SmartContractError),$/;"	e	enum:Error
SmartContractError	src/error_handling/error.rs	/^pub enum SmartContractError {$/;"	g
SmartContractExecutionError	src/chain/block.rs	/^    SmartContractExecutionError(String),$/;"	e	enum:BlockError
SmartContractGenerator	src/hdcmodels/smart_contract_generation/code_generation.rs	/^impl SmartContractGenerator {$/;"	c
SmartContractGenerator	src/hdcmodels/smart_contract_generation/code_generation.rs	/^pub struct SmartContractGenerator {$/;"	s
SmartContractNotFound	src/error_handling/error.rs	/^    SmartContractNotFound,$/;"	e	enum:SmartContractError
SmartContractOptimizer	src/hdcmodels/smart_contract_generation/optimization.rs	/^impl SmartContractOptimizer {$/;"	c
SmartContractOptimizer	src/hdcmodels/smart_contract_generation/optimization.rs	/^pub struct SmartContractOptimizer {$/;"	s
SmartContractSpecEncoder	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^impl SmartContractSpecEncoder {$/;"	c
SmartContractSpecEncoder	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^pub struct SmartContractSpecEncoder {$/;"	s
Snapshot	src/chain/storage/snapshot.rs	/^impl Snapshot {$/;"	c
Snapshot	src/chain/storage/snapshot.rs	/^pub struct Snapshot {$/;"	s
SnapshotError	src/chain/storage/snapshot.rs	/^pub enum SnapshotError {$/;"	g
StackEntry	src/optimization_problems/hdc_code_generation/dataset.rs	/^pub struct StackEntry {$/;"	s
StakeUpdated	src/chain/governance/staking.rs	/^    StakeUpdated {$/;"	e	enum:StakingMessage
StakerNotFound	src/chain/governance/staking.rs	/^    StakerNotFound,$/;"	e	enum:StakingError
Staking	src/chain/governance/staking.rs	/^impl Staking {$/;"	c
Staking	src/chain/governance/staking.rs	/^pub struct Staking {$/;"	s
StakingError	src/chain/governance/staking.rs	/^pub enum StakingError {$/;"	g
StakingMessage	src/chain/governance/staking.rs	/^pub enum StakingMessage {$/;"	g
StakingUpdate	src/chain/governance/governance_engine.rs	/^    StakingUpdate(String, u64),$/;"	e	enum:GovernanceMessage
State	src/network/p2p/message.rs	/^    State(Vec<u8>),$/;"	e	enum:Message
StateChannelOptimized	src/chain/state_channel.rs	/^impl StateChannelOptimized {$/;"	c
StateChannelOptimized	src/chain/state_channel.rs	/^pub struct StateChannelOptimized {$/;"	s
StateDB	src/chain/state/state_db.rs	/^impl StateDB {$/;"	c
StateDB	src/chain/state/state_db.rs	/^pub struct StateDB {$/;"	s
StateManager	src/chain/state/state_manager.rs	/^impl StateManager {$/;"	c
StateManager	src/chain/state/state_manager.rs	/^pub struct StateManager {$/;"	s
StateProcessingFailed	src/network/node_message.rs	/^    StateProcessingFailed(String),$/;"	e	enum:NodeMessageError
StateRequest	src/chain/shard.rs	/^    StateRequest { shard_id: u64 },$/;"	e	enum:ShardMessage
StateRequest	src/network/node_message.rs	/^    StateRequest(NodeId),$/;"	e	enum:NodeMessage
StateRequest	src/network/shard_message.rs	/^    StateRequest {$/;"	e	enum:ShardMessage
StateResponse	src/chain/shard.rs	/^    StateResponse(ShardState),$/;"	e	enum:ShardMessage
StateResponse	src/network/node_message.rs	/^    StateResponse(Vec<u8>),$/;"	e	enum:NodeMessage
StateResponse	src/network/shard_message.rs	/^    StateResponse(ShardState),$/;"	e	enum:ShardMessage
StateResponse	src/network/sync/state_sync.rs	/^    StateResponse { shard_id: u64, state: ShardState, signature: Signature },$/;"	e	enum:StateSyncMessage
StateRetrievalFailed	src/network/node_message.rs	/^    StateRetrievalFailed(String),$/;"	e	enum:NodeMessageError
StateSync	src/network/sync/state_sync.rs	/^impl StateSync {$/;"	c
StateSync	src/network/sync/state_sync.rs	/^pub struct StateSync {$/;"	s
StateSyncError	src/network/sync/state_sync.rs	/^pub enum StateSyncError {$/;"	g
StateSyncMessage	src/network/sync/state_sync.rs	/^pub enum StateSyncMessage {$/;"	g
StateSyncRequest	src/network/protocol.rs	/^    StateSyncRequest {$/;"	e	enum:ProtocolMessage
StateSyncResponse	src/network/protocol.rs	/^    StateSyncResponse {$/;"	e	enum:ProtocolMessage
StateTransition	src/chain/state/state_transition.rs	/^impl StateTransition {$/;"	c
StateTransition	src/chain/state/state_transition.rs	/^pub struct StateTransition {$/;"	s
StateTransition	src/chain/state_transition.rs	/^impl StateTransition {$/;"	c
StateTransition	src/chain/state_transition.rs	/^pub struct StateTransition {$/;"	s
StateTransition	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^pub struct StateTransition {$/;"	s
StateTransitionError	src/chain/state_transition.rs	/^pub enum StateTransitionError {$/;"	g
StateUpdateError	src/chain/block.rs	/^    StateUpdateError(String),$/;"	e	enum:BlockError
StateUpdateError	src/chain/blockchain.rs	/^    StateUpdateError(String),$/;"	e	enum:BlockchainError
StateUpdateError	src/chain/state_transition.rs	/^    StateUpdateError(String),$/;"	e	enum:StateTransitionError
StateUpdateError	src/chain/transaction.rs	/^    StateUpdateError(String),$/;"	e	enum:TransactionError
StealthAddress	src/chain/wallet.rs	/^impl StealthAddress {$/;"	c
StealthAddress	src/chain/wallet.rs	/^pub struct StealthAddress {$/;"	s
StealthAddressError	src/chain/wallet.rs	/^    StealthAddressError(String),$/;"	e	enum:WalletError
StorageError	src/chain/blockchain.rs	/^    StorageError(#[from] BlockchainStorageError),$/;"	e	enum:BlockchainError
StorageError	src/error_handling/error.rs	/^    StorageError(#[from] StorageError),$/;"	e	enum:Error
StorageError	src/error_handling/error.rs	/^pub enum StorageError {$/;"	g
StorageError	src/secure_core/secure_storage.rs	/^    StorageError(String),$/;"	e	enum:SecureStorageError
StorageUnavailable	src/error_handling/error.rs	/^    StorageUnavailable,$/;"	e	enum:StorageError
String	src/api/middleware/request_validator.rs	/^impl From<ValidationError> for String {$/;"	c
String	src/hdcmodels/distributed_training/load_balancing.rs	/^impl DataItem for String {$/;"	c
String	src/smart_contract/types.rs	/^    String(String),$/;"	e	enum:Value
SubmitBlockRequest	src/api/models/request/blockchain_request.rs	/^pub struct SubmitBlockRequest {$/;"	s
SubmitBlockResponse	src/api/models/response/blockchain_response.rs	/^pub struct SubmitBlockResponse {$/;"	s
SubmitProposalRequest	src/api/models/request/governance_request.rs	/^pub struct SubmitProposalRequest {$/;"	s
SubmitTransactionRequest	src/api/handlers/transaction_handler.rs	/^struct SubmitTransactionRequest {$/;"	s
SubmitTransactionRequest	src/api/models/request/blockchain_request.rs	/^pub struct SubmitTransactionRequest {$/;"	s
SubmitTransactionRequest	src/api/models/request/transaction_request.rs	/^pub struct SubmitTransactionRequest {$/;"	s
SubmitTransactionRequest	src/api/routes/transaction.rs	/^struct SubmitTransactionRequest {$/;"	s
Subtract	src/smart_contract/types.rs	/^    Subtract,$/;"	e	enum:BinaryOperator
Succeeded	src/chain/governance/proposal.rs	/^    Succeeded,$/;"	e	enum:ProposalStatus
Success	src/chain/quantum_voting/types.rs	/^    Success(Vec<Candidate>),$/;"	e	enum:VotingResult
Synchronizer	src/hdcmodels/distributed_training/synchronization.rs	/^impl Synchronizer {$/;"	c
Synchronizer	src/hdcmodels/distributed_training/synchronization.rs	/^pub struct Synchronizer {$/;"	s
TARGET_BLOCK_TIME	src/chain/block.rs	/^const TARGET_BLOCK_TIME: u64 = 600; \/\/ Target block time in seconds (10 minutes)$/;"	C
TLSConnectionError	src/network/mod.rs	/^    TLSConnectionError(#[from] TLSConnectionError),$/;"	e	enum:NetworkError
TLSError	src/network/p2p/peer.rs	/^    TLSError(String),$/;"	e	enum:PeerError
TRANSACTION_RETENTION_PERIOD	src/chain/shard.rs	/^const TRANSACTION_RETENTION_PERIOD: Duration = Duration::from_secs(604800); \/\/ 1 week$/;"	C
TimeBinState	src/crypto/quantum_state.rs	/^impl QuantumState for TimeBinState {$/;"	c
TimeBinState	src/crypto/quantum_state.rs	/^impl TimeBinState {$/;"	c
TimeBinState	src/crypto/quantum_state.rs	/^pub struct TimeBinState {$/;"	s
TimeoutError	src/error_handling/network_error.rs	/^    TimeoutError(String),$/;"	e	enum:NetworkError
TlsError	src/network/error.rs	/^    TlsError(String),$/;"	e	enum:NetworkError
TrainedModel	src/hdcmodels/distributed_training/distributed_framework.rs	/^    TrainedModel(Vec<Vec<f64>>),$/;"	e	enum:DistributedTrainingMessage
TrainingComplete	src/hdcmodels/distributed_training/distributed_framework.rs	/^    TrainingComplete,$/;"	e	enum:DistributedTrainingMessage
TrainingData	src/hdcmodels/distributed_training/distributed_framework.rs	/^    TrainingData(Dataset),$/;"	e	enum:DistributedTrainingMessage
Transaction	src/api/models/request/transaction_request.rs	/^pub struct Transaction {$/;"	s
Transaction	src/chain/transaction.rs	/^impl Transaction {$/;"	c
Transaction	src/chain/transaction.rs	/^pub struct Transaction {$/;"	s
Transaction	src/hdcmodels/hdcmodels.rs	/^impl Transaction {$/;"	c
Transaction	src/hdcmodels/hdcmodels.rs	/^pub struct Transaction {$/;"	s
Transaction	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^pub struct Transaction {$/;"	s
Transaction	src/network/p2p/message.rs	/^    Transaction(Transaction),$/;"	e	enum:Message
TransactionBroadcast	src/network/node_message.rs	/^    TransactionBroadcast(Transaction),$/;"	e	enum:NodeMessage
TransactionBroadcast	src/network/protocol.rs	/^    TransactionBroadcast {$/;"	e	enum:ProtocolMessage
TransactionContext	src/smart_contract/types.rs	/^pub struct TransactionContext {$/;"	s
TransactionData	src/api/models/request/blockchain_request.rs	/^pub struct TransactionData {$/;"	s
TransactionData	src/api/models/response/blockchain_response.rs	/^pub struct TransactionData {$/;"	s
TransactionEncoder	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^impl TransactionEncoder {$/;"	c
TransactionEncoder	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^pub struct TransactionEncoder {$/;"	s
TransactionError	src/chain/transaction.rs	/^pub enum TransactionError {$/;"	g
TransactionHistoryResponse	src/api/handlers/transaction_handler.rs	/^struct TransactionHistoryResponse {$/;"	s
TransactionHistoryResponse	src/api/routes/transaction.rs	/^struct TransactionHistoryResponse {$/;"	s
TransactionIndex	src/utils/indexing.rs	/^impl TransactionIndex {$/;"	c
TransactionIndex	src/utils/indexing.rs	/^pub struct TransactionIndex {$/;"	s
TransactionInfo	src/api/handlers/blockchain_handler.rs	/^impl TransactionInfo {$/;"	c
TransactionInfo	src/api/handlers/blockchain_handler.rs	/^struct TransactionInfo {$/;"	s
TransactionInfo	src/api/handlers/transaction_handler.rs	/^impl TransactionInfo {$/;"	c
TransactionInfo	src/api/handlers/transaction_handler.rs	/^struct TransactionInfo {$/;"	s
TransactionInfo	src/api/routes/blockchain.rs	/^pub struct TransactionInfo {$/;"	s
TransactionInfo	src/api/routes/transaction.rs	/^struct TransactionInfo {$/;"	s
TransactionMessage	src/network/shard_message.rs	/^    TransactionMessage(Transaction),$/;"	e	enum:ShardMessage
TransactionOptimizer	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^impl TransactionOptimizer {$/;"	c
TransactionOptimizer	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^pub struct TransactionOptimizer {$/;"	s
TransactionPool	src/mining/transaction_pool.rs	/^impl TransactionPool {$/;"	c
TransactionPool	src/mining/transaction_pool.rs	/^pub struct TransactionPool {$/;"	s
TransactionProcessingFailed	src/network/node_message.rs	/^    TransactionProcessingFailed(String),$/;"	e	enum:NodeMessageError
TransactionStatus	src/api/models/request/transaction_request.rs	/^pub struct TransactionStatus {$/;"	s
TransactionStatusResponse	src/api/handlers/transaction_handler.rs	/^struct TransactionStatusResponse {$/;"	s
TransactionStatusResponse	src/api/routes/transaction.rs	/^struct TransactionStatusResponse {$/;"	s
TransactionStatusType	src/api/models/request/transaction_request.rs	/^pub enum TransactionStatusType {$/;"	g
TransactionValidationError	src/chain/validation.rs	/^    TransactionValidationError(#[from] TransactionError),$/;"	e	enum:ValidationError
TransactionValidationFailed	src/error_handling/error.rs	/^    TransactionValidationFailed,$/;"	e	enum:BlockchainError
TransactionalData	src/hdcmodels/hdcmodels.rs	/^    TransactionalData(Vec<Transaction>),$/;"	e	enum:DataItem
TransferLearningModel	src/hdcmodels/model_integration/transfer_learning.rs	/^impl TransferLearningModel {$/;"	c
TransferLearningModel	src/hdcmodels/model_integration/transfer_learning.rs	/^pub struct TransferLearningModel {$/;"	s
Transform	src/api/middleware/authorization.rs	/^    type Transform = AuthorizationMiddlewareMiddleware<S>;$/;"	t
Transform	src/api/middleware/rate_limiter.rs	/^    type Transform = RateLimiterMiddlewareMiddleware<S>;$/;"	t
Transform	src/api/middleware/request_validator.rs	/^    type Transform = RequestValidatorMiddlewareMiddleware<S>;$/;"	t
Treasury	src/chain/governance/treasury.rs	/^impl Treasury {$/;"	c
Treasury	src/chain/governance/treasury.rs	/^pub struct Treasury {$/;"	s
TrieNode	src/chain/state/merkle_trie.rs	/^impl TrieNode {$/;"	c
TrieNode	src/chain/state/merkle_trie.rs	/^pub struct TrieNode {$/;"	s
UnaryOp	src/smart_contract/types.rs	/^    UnaryOp { op: UnaryOperator, expr: Box<Expression> },$/;"	e	enum:Expression
UnaryOperator	src/smart_contract/types.rs	/^pub enum UnaryOperator {$/;"	g
UnexpectedError	src/error_handling/error.rs	/^    UnexpectedError(String),$/;"	e	enum:Error
UnstakeUpdated	src/chain/governance/staking.rs	/^    UnstakeUpdated {$/;"	e	enum:StakingMessage
UnstakingUpdate	src/chain/governance/governance_engine.rs	/^    UnstakingUpdate(String, u64),$/;"	e	enum:GovernanceMessage
UnsupportedOperation	src/error_handling/network_error.rs	/^    UnsupportedOperation(String),$/;"	e	enum:NetworkError
UpdateConsensusParametersRequest	src/api/models/request/qup_request.rs	/^pub struct UpdateConsensusParametersRequest {$/;"	s
UpdateNetworkConfigRequest	src/api/models/request/network_request.rs	/^pub struct UpdateNetworkConfigRequest {$/;"	s
UsefulWork	src/chain/block.rs	/^pub struct UsefulWork {$/;"	s
UsefulWork	src/qup/hdcomm.rs	/^pub struct UsefulWork {$/;"	s
UsefulWorkConfig	src/qup/config.rs	/^pub struct UsefulWorkConfig {$/;"	s
UsefulWorkError	src/qup/error.rs	/^impl fmt::Display for UsefulWorkError {$/;"	c
UsefulWorkError	src/qup/error.rs	/^impl std::error::Error for UsefulWorkError {}$/;"	c
UsefulWorkError	src/qup/error.rs	/^pub enum UsefulWorkError {$/;"	g
UsefulWorkProblem	src/qup/hdcomm.rs	/^impl UsefulWorkProblem {$/;"	c
UsefulWorkProblem	src/qup/hdcomm.rs	/^pub enum UsefulWorkProblem {$/;"	g
UsefulWorkProblem	src/qup/types.rs	/^pub enum UsefulWorkProblem {$/;"	g
UsefulWorkSolution	src/chain/transaction.rs	/^pub struct UsefulWorkSolution {$/;"	s
UsefulWorkSolution	src/qup/block.rs	/^pub struct UsefulWorkSolution {$/;"	s
UsefulWorkSolution	src/qup/hdcomm.rs	/^impl UsefulWorkSolution {$/;"	c
UsefulWorkSolution	src/qup/hdcomm.rs	/^pub enum UsefulWorkSolution {$/;"	g
UsefulWorkSolution	src/qup/types.rs	/^pub enum UsefulWorkSolution {$/;"	g
User	src/api/middleware/authentication.rs	/^    User,$/;"	e	enum:Role
User	src/secure_core/access_control.rs	/^    User,$/;"	e	enum:Role
ValidationError	src/chain/validation.rs	/^pub enum ValidationError {$/;"	g
ValidationErrorResponse	src/api/middleware/request_validator.rs	/^struct ValidationErrorResponse {$/;"	s
Validator	src/api/routes/consensus.rs	/^struct Validator {$/;"	s
Validator	src/chain/validator/validator.rs	/^impl Validator {$/;"	c
Validator	src/chain/validator/validator.rs	/^pub struct Validator {$/;"	s
ValidatorInfo	src/api/handlers/qup_handler.rs	/^impl ValidatorInfo {$/;"	c
ValidatorInfo	src/api/handlers/qup_handler.rs	/^struct ValidatorInfo {$/;"	s
ValidatorInfo	src/api/models/response/qup_response.rs	/^pub struct ValidatorInfo {$/;"	s
ValidatorSetUpdate	src/chain/governance/governance_engine.rs	/^    ValidatorSetUpdate(Vec<QUPValidator>),$/;"	e	enum:GovernanceMessage
Value	src/smart_contract/types.rs	/^pub enum Value {$/;"	g
Variable	src/smart_contract/types.rs	/^    Variable(String),$/;"	e	enum:Expression
Variable	src/zkp/constraint_system.rs	/^    Variable(Variable),$/;"	e	enum:Expression
Variable	src/zkp/constraint_system.rs	/^pub struct Variable(usize);$/;"	s
Vec	src/hdcmodels/distributed_training/load_balancing.rs	/^impl DataItem for Vec<f64> {$/;"	c
VerificationError	src/secure_core/quantum_resistant_signatures.rs	/^    VerificationError(String),$/;"	e	enum:QuantumResistantSignatureError
VerificationFailed	src/crypto/post_quantum.rs	/^    VerificationFailed,$/;"	e	enum:PostQuantumError
VerificationFailed	src/qup/error.rs	/^    VerificationFailed(String),$/;"	e	enum:UsefulWorkError
VertexCover	src/qup/hdcomm.rs	/^    VertexCover(VertexCoverProblem),$/;"	e	enum:UsefulWorkProblem
VertexCover	src/qup/hdcomm.rs	/^    VertexCover(VertexCoverSolution),$/;"	e	enum:UsefulWorkSolution
VertexCover	src/qup/types.rs	/^    VertexCover(VertexCoverProblem),$/;"	e	enum:UsefulWorkProblem
VertexCover	src/qup/types.rs	/^    VertexCover(VertexCoverSolution),$/;"	e	enum:UsefulWorkSolution
VertexCoverProblem	src/qup/types.rs	/^pub struct VertexCoverProblem {$/;"	s
VertexCoverSolution	src/qup/types.rs	/^pub struct VertexCoverSolution {$/;"	s
Vote	src/chain/governance/voting.rs	/^pub struct Vote {$/;"	s
VoteCollection	src/chain/quantum_voting/vote_collection.rs	/^impl VoteCollection {$/;"	c
VoteCollection	src/chain/quantum_voting/vote_collection.rs	/^pub struct VoteCollection {}$/;"	s
VoteCollectionFailed	src/chain/quantum_voting/types.rs	/^    VoteCollectionFailed,$/;"	e	enum:VotingError
VoteDecryptionError	src/chain/quantum_voting/error.rs	/^    VoteDecryptionError,$/;"	e	enum:VotingError
VoteInfo	src/api/handlers/governance_handler.rs	/^impl VoteInfo {$/;"	c
VoteInfo	src/api/handlers/governance_handler.rs	/^struct VoteInfo {$/;"	s
VoteInfo	src/api/routes/governance.rs	/^struct VoteInfo {$/;"	s
VoteIntegrityError	src/chain/quantum_voting/error.rs	/^    VoteIntegrityError,$/;"	e	enum:VotingError
VoteStorageError	src/chain/quantum_voting/error.rs	/^    VoteStorageError,$/;"	e	enum:VotingError
VoteTallying	src/chain/quantum_voting/vote_tallying.rs	/^impl VoteTallying {$/;"	c
VoteTallying	src/chain/quantum_voting/vote_tallying.rs	/^pub struct VoteTallying {}$/;"	s
VoteType	src/api/models/request/governance_request.rs	/^pub enum VoteType {$/;"	g
VoteType	src/chain/governance/voting.rs	/^pub enum VoteType {$/;"	g
VoteVerificationFailed	src/chain/quantum_voting/types.rs	/^    VoteVerificationFailed,$/;"	e	enum:VotingError
Voting	src/chain/governance/voting.rs	/^impl Voting {$/;"	c
Voting	src/chain/governance/voting.rs	/^pub struct Voting {$/;"	s
VotingAlreadyInProgress	src/chain/quantum_voting/error.rs	/^    VotingAlreadyInProgress,$/;"	e	enum:VotingError
VotingError	src/chain/quantum_voting/error.rs	/^impl From<QuantumCompressionError> for VotingError {$/;"	c
VotingError	src/chain/quantum_voting/error.rs	/^impl From<QuantumHardwareError> for VotingError {$/;"	c
VotingError	src/chain/quantum_voting/error.rs	/^impl From<QuantumNoiseSimulationError> for VotingError {$/;"	c
VotingError	src/chain/quantum_voting/error.rs	/^pub enum VotingError {$/;"	g
VotingError	src/chain/quantum_voting/types.rs	/^pub enum VotingError {$/;"	g
VotingPower	src/api/handlers/governance_handler.rs	/^struct VotingPower {$/;"	s
VotingPower	src/api/routes/governance.rs	/^struct VotingPower {$/;"	s
VotingProtocols	src/chain/quantum_voting/voting_protocols.rs	/^impl VotingProtocols {$/;"	c
VotingProtocols	src/chain/quantum_voting/voting_protocols.rs	/^pub struct VotingProtocols {$/;"	s
VotingResult	src/chain/quantum_voting/types.rs	/^pub enum VotingResult {$/;"	g
VotingStarted	src/chain/governance/proposal.rs	/^    VotingStarted(u64),$/;"	e	enum:ProposalMessage
VotingState	src/chain/quantum_voting/voting_state.rs	/^impl VotingState {$/;"	c
VotingState	src/chain/quantum_voting/voting_state.rs	/^pub struct VotingState {$/;"	s
Wallet	src/chain/wallet.rs	/^impl Wallet {$/;"	c
Wallet	src/chain/wallet.rs	/^pub struct Wallet {$/;"	s
WalletError	src/chain/wallet.rs	/^pub enum WalletError {$/;"	g
WalletError	src/error_handling/error.rs	/^    WalletError(#[from] WalletError),$/;"	e	enum:Error
WalletError	src/error_handling/error.rs	/^pub enum WalletError {$/;"	g
WalletLocked	src/error_handling/error.rs	/^    WalletLocked,$/;"	e	enum:WalletError
Witness	src/constraint_system.rs	/^type Witness = Vec<u8>; \/\/ Placeholder for the actual Witness type$/;"	t
WriteBlocks	src/api/middleware/authorization.rs	/^    WriteBlocks,$/;"	e	enum:Permission
WriteData	src/secure_core/access_control.rs	/^    WriteData,$/;"	e	enum:Permission
WriteTransactions	src/api/middleware/authorization.rs	/^    WriteTransactions,$/;"	e	enum:Permission
Yes	src/api/models/request/governance_request.rs	/^    Yes,$/;"	e	enum:VoteType
Yes	src/chain/governance/voting.rs	/^    Yes,$/;"	e	enum:VoteType
ZKPVerificationFailed	src/chain/blockchain.rs	/^    ZKPVerificationFailed(usize),$/;"	e	enum:BlockchainError
ZKProofError	src/chain/transaction.rs	/^    ZKProofError(String),$/;"	e	enum:TransactionError
ZKProofVerificationFailed	src/chain/validation.rs	/^    ZKProofVerificationFailed(#[from] ZKProofError),$/;"	e	enum:ValidationError
ZephyrChainCircuit	src/zephyrchain_circuit.rs	/^impl Air for ZephyrChainCircuit {$/;"	c
ZephyrChainCircuit	src/zephyrchain_circuit.rs	/^impl TraceGenerator for ZephyrChainCircuit {$/;"	c
ZephyrChainCircuit	src/zephyrchain_circuit.rs	/^pub struct ZephyrChainCircuit {$/;"	s
ZkStarksProof	src/zkp/zk_starks.rs	/^pub struct ZkStarksProof {$/;"	s
ZkStarksVerifier	src/zkp/zk_starks.rs	/^impl ZkStarksVerifier {$/;"	c
ZkStarksVerifier	src/zkp/zk_starks.rs	/^pub struct ZkStarksVerifier {$/;"	s
a	src/zkp/constraint_system.rs	/^    pub a: Expression,$/;"	m	struct:EqualsConstraint
access_control	src/secure_core/mod.rs	/^mod access_control;$/;"	n
account	src/chain/state/mod.rs	/^mod account;$/;"	n
account_cache	src/chain/state/state_db.rs	/^    account_cache: LruCache<String, Account>,$/;"	m	struct:StateDB
account_cache	src/chain/state/state_manager.rs	/^    account_cache: RwLock<HashMap<String, Account>>,$/;"	m	struct:StateManager
account_exists	src/chain/state/state_db.rs	/^    pub fn account_exists(&self, address: &str) -> bool {$/;"	P	implementation:StateDB
account_exists	src/chain/state/state_manager.rs	/^    pub fn account_exists(&self, address: &str) -> bool {$/;"	P	implementation:StateManager
account_trie	src/chain/state/state_db.rs	/^    account_trie: MerkleTrie,$/;"	m	struct:StateDB
accuracy	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub accuracy: f64,$/;"	m	struct:HDCBenchmarkResult
accuracy	src/hdcmodels/benchmarking/reporting.rs	/^    pub accuracy: f64,$/;"	m	struct:BenchmarkReport
accuracy	src/hdcmodels/hdcmodels.rs	/^    accuracy: f64,$/;"	m	struct:HDCModel
accuracy	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub accuracy: f32,$/;"	m	struct:EvaluationResult
adapt	src/hdcmodels/continuous_learning/online_learning.rs	/^    fn adapt(&mut self, encoded_data: &[f64], label: &str) {$/;"	P	implementation:OnlineLearningHDCModel
adaptation_threshold	src/hdcmodels/continuous_learning/online_learning.rs	/^    adaptation_threshold: f64,$/;"	m	struct:OnlineLearningHDCModel
add	src/zkp/constraint_system.rs	/^    pub fn add(lhs: Expression, rhs: Expression) -> Self {$/;"	P	implementation:Expression
add	src/zkp/math.rs	/^    fn add(self, other: Self) -> Self {$/;"	P	implementation:FieldElement
add_assign	src/zkp/math.rs	/^    fn add_assign(&mut self, other: Self) {$/;"	P	implementation:FieldElement
add_block	src/chain/blockchain.rs	/^    pub async fn add_block(&self, block: Block) -> Result<(), BlockchainError> {$/;"	P	implementation:Blockchain
add_block	src/chain/storage/block_storage.rs	/^    pub fn add_block(&self, block: &Block) -> Result<(), BlockStorageError> {$/;"	P	implementation:BlockStorage
add_hash_function	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    fn add_hash_function(&self, code: &str) -> String {$/;"	P	implementation:SmartContractGenerator
add_item	src/hdcmodels/hdcmodels.rs	/^    pub fn add_item(&mut self, item: DataItem) {$/;"	P	implementation:Dataset
add_key_version	src/secure_core/secure_vault.rs	/^    pub fn add_key_version(&self, sp_key_id: &str, version_id: &str) {$/;"	P	implementation:SecureVault
add_off_chain_transaction_optimized	src/chain/state_channel.rs	/^    pub fn add_off_chain_transaction_optimized($/;"	P	implementation:ChannelManagerOptimized
add_peer	src/network/mod.rs	/^    async fn add_peer(&self, peer: Peer) {$/;"	P	implementation:Network
add_security_measures	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    fn add_security_measures(&self, code: &str) -> String {$/;"	P	implementation:SmartContractGenerator
add_signature_scheme	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    fn add_signature_scheme(&self, code: &str) -> String {$/;"	P	implementation:SmartContractGenerator
add_to_blockchain	src/chain/block.rs	/^    pub fn add_to_blockchain($/;"	P	implementation:Block
add_to_reward_pool	src/chain/governance/rewards.rs	/^    pub async fn add_to_reward_pool($/;"	P	implementation:Rewards
add_transaction	src/chain/shard.rs	/^    pub async fn add_transaction(&mut self, transaction: Transaction) -> Result<(), ShardError> /;"	P	implementation:Shard
add_transaction	src/chain/sharding.rs	/^    pub async fn add_transaction(&self, transaction: Transaction) -> Result<(), ShardingError> {$/;"	P	implementation:Sharding
add_transaction	src/mining/transaction_pool.rs	/^    pub fn add_transaction(&self, transaction: Transaction) -> bool {$/;"	P	implementation:TransactionPool
add_transaction_optimized	src/chain/state_channel.rs	/^    pub fn add_transaction_optimized($/;"	P	implementation:StateChannelOptimized
address	src/api/handlers/network_handler.rs	/^    address: String,$/;"	m	struct:PeerInfo
address	src/api/handlers/smart_contract_handler.rs	/^    address: String,$/;"	m	struct:ContractInfo
address	src/api/models/request/network_request.rs	/^    pub address: String,$/;"	m	struct:PeerInfo
address	src/api/models/request/smart_contract_request.rs	/^    pub address: String,$/;"	m	struct:DeployedContract
address	src/api/models/response/network_response.rs	/^    pub address: String,$/;"	m	struct:PeerInfo
address	src/api/routes/network.rs	/^    address: String,$/;"	m	struct:PeerInfo
address	src/api/routes/smart_contract.rs	/^    address: String,$/;"	m	struct:ContractInfo
address	src/chain/state/account.rs	/^    pub address: String,$/;"	m	struct:Account
address	src/chain/validator/validator.rs	/^    pub address: Address,$/;"	m	struct:Validator
address	src/network/p2p/peer.rs	/^    pub address: String,$/;"	m	struct:Peer
address	src/network/server.rs	/^    address: String,$/;"	m	struct:Server
address	src/qup/delegator.rs	/^    pub address: Address,$/;"	m	struct:QUPDelegator
address	src/qup/validator.rs	/^    pub address: Address,$/;"	m	struct:QUPValidator
address	src/types/mod.rs	/^mod address;$/;"	n
age	src/api/middleware/request_validator.rs	/^    age: u32,$/;"	m	struct:RequestModel
aggregate_data	src/hdcmodels/benchmarking/data_collection.rs	/^    pub async fn aggregate_data($/;"	P	implementation:BenchmarkDataCollector
aggregate_models	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn aggregate_models(&mut self) {$/;"	P	implementation:DistributedTrainingAggregator
aggregate_models	src/hdcmodels/distributed_training/distributed_framework.rs	/^    fn aggregate_models(&self, models: &[Vec<Vec<f64>>]) -> Vec<Vec<f64>> {$/;"	P	implementation:HDCModel
aggregate_models	src/hdcmodels/distributed_training/distributed_framework.rs	/^    fn aggregate_models(&self, models: &[Vec<Vec<f64>>]) -> Vec<Vec<f64>>;$/;"	P	interface:HDCModelExt
aggregation_loop	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn aggregation_loop(&mut self) {$/;"	P	implementation:DistributedTrainingAggregator
aggregator_channel	src/hdcmodels/distributed_training/distributed_framework.rs	/^    aggregator_channel: Option<Sender<DistributedTrainingMessage>>,$/;"	m	struct:DistributedTrainingNode
alloc_input	src/zkp/constraint_system.rs	/^    fn alloc_input(&mut self, value: FieldElement) -> Variable {$/;"	P	implementation:ConstraintSystemImpl
alloc_input	src/zkp/constraint_system.rs	/^    fn alloc_input(&mut self, value: FieldElement) -> Variable;$/;"	P	interface:ConstraintSystem
alloc_variable	src/zkp/constraint_system.rs	/^    fn alloc_variable(&mut self, value: FieldElement) -> Variable {$/;"	P	implementation:ConstraintSystemImpl
alloc_variable	src/zkp/constraint_system.rs	/^    fn alloc_variable(&mut self, value: FieldElement) -> Variable;$/;"	P	interface:ConstraintSystem
allocate	src/chain/governance/treasury.rs	/^    pub fn allocate(&mut self, allocation_id: String, amount: u64) -> Result<(), String> {$/;"	P	implementation:Treasury
allocations	src/chain/governance/treasury.rs	/^    pub allocations: HashMap<String, u64>,$/;"	m	struct:Treasury
allowed_peers	src/network/mod.rs	/^    allowed_peers: HashSet<String>,$/;"	m	struct:Network
amount	src/api/api.rs	/^    amount: f64,$/;"	m	struct:NewTransactionRequest
amount	src/api/handlers/blockchain_handler.rs	/^    amount: f64,$/;"	m	struct:TransactionInfo
amount	src/api/handlers/transaction_handler.rs	/^    amount: f64,$/;"	m	struct:SubmitTransactionRequest
amount	src/api/handlers/transaction_handler.rs	/^    amount: f64,$/;"	m	struct:TransactionInfo
amount	src/api/models/request/blockchain_request.rs	/^    pub amount: f64,$/;"	m	struct:TransactionData
amount	src/api/models/request/transaction_request.rs	/^    pub amount: f64,$/;"	m	struct:SubmitTransactionRequest
amount	src/api/models/request/transaction_request.rs	/^    pub amount: f64,$/;"	m	struct:Transaction
amount	src/api/models/response/blockchain_response.rs	/^    pub amount: f64,$/;"	m	struct:TransactionData
amount	src/api/routes/blockchain.rs	/^    amount: f64,$/;"	m	struct:TransactionInfo
amount	src/api/routes/transaction.rs	/^    amount: f64,$/;"	m	struct:SubmitTransactionRequest
amount	src/api/routes/transaction.rs	/^    amount: f64,$/;"	m	struct:TransactionInfo
amount	src/chain/state_channel.rs	/^    pub amount: f64,$/;"	m	struct:OffChainTransaction
amount	src/chain/transaction.rs	/^    pub amount: f64,$/;"	m	struct:Transaction
amount	src/qup/types.rs	/^    pub amount: u64,$/;"	m	struct:QUPTransaction
amount	src/types/block_reward.rs	/^    pub amount: u64,$/;"	m	struct:BlockReward
analyze	src/hdcmodels/benchmarking/analysis.rs	/^    pub async fn analyze(&self) {$/;"	P	implementation:BenchmarkAnalyzer
analyze_channel_security	src/chain/quantum_voting/security_analysis.rs	/^    pub fn analyze_channel_security($/;"	P	implementation:SecurityAnalysis
analyze_coherence	src/chain/quantum_voting/quantum_voting.rs	/^    fn analyze_coherence(&self, quantum_state: &QuantumState) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
analyze_entanglement	src/chain/quantum_voting/quantum_voting.rs	/^    fn analyze_entanglement(&self, quantum_state: &QuantumState) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
analyze_noise_data_and_simulations	src/chain/quantum_voting/quantum_voting.rs	/^    fn analyze_noise_data_and_simulations($/;"	P	implementation:QuantumVoting
analyze_proposal	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn analyze_proposal(&self, proposal: &Proposal) {$/;"	P	implementation:ConsensusSecurityMonitor
analyze_proposal	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    pub fn analyze_proposal(&self, proposal: &Proposal) -> ProposalAnalysis {$/;"	P	implementation:ProposalAnalyzer
analyze_purity	src/chain/quantum_voting/quantum_voting.rs	/^    fn analyze_purity(&self, quantum_state: &QuantumState) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
analyze_tomography_result	src/chain/quantum_voting/compression.rs	/^    fn analyze_tomography_result($/;"	P	implementation:Compression
analyze_tomography_result	src/chain/quantum_voting/quantum_state_verification.rs	/^    fn analyze_tomography_result($/;"	P	implementation:QuantumStateVerification
analyze_tomography_result	src/chain/quantum_voting/quantum_voting.rs	/^    fn analyze_tomography_result($/;"	P	implementation:QuantumVoting
analyze_vote	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn analyze_vote(&self, vote: &Vote) {$/;"	P	implementation:ConsensusSecurityMonitor
analyze_vote_tomography	src/chain/quantum_voting/vote_collection.rs	/^    fn analyze_vote_tomography($/;"	P	implementation:VoteCollection
analyzer	src/hdcmodels/benchmarking/reporting.rs	/^    analyzer: BenchmarkAnalyzer,$/;"	m	struct:BenchmarkReporter
anomaly_threshold	src/hdcmodels/governance_integration/consensus_security.rs	/^    anomaly_threshold: f64,$/;"	m	struct:ConsensusSecurityMonitor
api	src/api/api.rs	/^pub fn api(blockchain: Arc<Blockchain>) -> impl Filter<Extract = impl Reply, Error = Rejection> /;"	f
api	src/api/mod.rs	/^pub mod api;$/;"	n
api	src/main.rs	/^mod api; \/\/ Handles network requests$/;"	n
apply	src/chain/state/state_transition.rs	/^    pub fn apply(&self, transaction: &Transaction) -> Result<(), String> {$/;"	P	implementation:StateTransition
apply	src/chain/state_transition.rs	/^    pub fn apply(&self, transaction: &Transaction) -> Result<(), StateTransitionError> {$/;"	P	implementation:StateTransition
apply	src/qup/block.rs	/^    pub fn apply(&self, state: &mut QUPState) -> Result<(), Error> {$/;"	P	implementation:QUPBlock
apply_bbpssw_protocol	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn apply_bbpssw_protocol(&self, quantum_state: &mut QuantumState) -> Result<(), VotingError>/;"	P	implementation:EntanglementDistillation
apply_binary_operator	src/smart_contract/interpreter.rs	/^    fn apply_binary_operator(left: &Value, op: &BinaryOperator, right: &Value) -> Result<Value, /;"	P	implementation:Interpreter
apply_block	src/chain/state/state_transition.rs	/^    pub fn apply_block(&self, block: &Block) -> Result<(), String> {$/;"	P	implementation:StateTransition
apply_block	src/chain/state_transition.rs	/^    pub fn apply_block(&self, block: &Block) -> Result<(), StateTransitionError> {$/;"	P	implementation:StateTransition
apply_block	src/qup/state.rs	/^    pub fn apply_block(&mut self, block: &QUPBlock) -> Result<(), Error> {$/;"	P	implementation:QUPState
apply_compression_scheme	src/chain/quantum_voting/compression.rs	/^    fn apply_compression_scheme($/;"	P	implementation:Compression
apply_compression_scheme	src/chain/quantum_voting/quantum_voting.rs	/^    fn apply_compression_scheme($/;"	P	implementation:QuantumVoting
apply_dejmps_protocol	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn apply_dejmps_protocol(&self, quantum_state: &mut QuantumState) -> Result<(), VotingError>/;"	P	implementation:EntanglementDistillation
apply_encoding_gates	src/chain/quantum_voting/quantum_state_encoding.rs	/^    fn apply_encoding_gates(&self, register: &mut QuantumRegister) -> Result<(), VotingError> {$/;"	P	implementation:QuantumStateEncoding
apply_gate	src/crypto/quantum_state.rs	/^    fn apply_gate(&mut self, gate: QuantumGate, target_qubit: usize) -> Result<()> {$/;"	P	implementation:TimeBinState
apply_gate	src/crypto/quantum_state.rs	/^    fn apply_gate(&mut self, gate: QuantumGate, target_qubit: usize) -> Result<()>;$/;"	P	interface:QuantumState
apply_gate	src/crypto/quantum_state.rs	/^    pub fn apply_gate($/;"	P	implementation:TimeBinState
apply_quantum_compression	src/chain/quantum_voting/compression.rs	/^    pub fn apply_quantum_compression($/;"	P	implementation:Compression
apply_quantum_error_correction	src/chain/quantum_voting/error_correction.rs	/^    pub fn apply_quantum_error_correction($/;"	P	implementation:ErrorCorrection
apply_quantum_error_correction	src/chain/quantum_voting/quantum_voting.rs	/^    fn apply_quantum_error_correction($/;"	P	implementation:QuantumVoting
apply_quantum_gate	src/chain/quantum_voting/utils.rs	/^pub fn apply_quantum_gate(state: &mut QuantumState, gate: QuantumGate) -> Result<(), VotingError/;"	f
apply_quantum_gates	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn apply_quantum_gates(&self, register: &mut QuantumRegister) -> Result<(), VotingError> {$/;"	P	implementation:QuantumStatePreparation
apply_quantum_noise	src/chain/quantum_voting/error_correction.rs	/^    fn apply_quantum_noise($/;"	P	implementation:ErrorCorrection
apply_quantum_noise	src/chain/quantum_voting/quantum_voting.rs	/^    fn apply_quantum_noise($/;"	P	implementation:QuantumVoting
apply_quantum_transformation	src/chain/quantum_voting/compression.rs	/^    fn apply_quantum_transformation($/;"	P	implementation:Compression
apply_quantum_transformation	src/chain/quantum_voting/quantum_voting.rs	/^    fn apply_quantum_transformation($/;"	P	implementation:QuantumVoting
apply_to_qup_state	src/chain/transaction.rs	/^    pub fn apply_to_qup_state($/;"	P	implementation:Transaction
apply_to_state	src/chain/transaction.rs	/^    pub fn apply_to_state(&self, state: &mut Arc<RwLock<State>>) -> Result<(), TransactionError>/;"	P	implementation:Transaction
apply_unary_operator	src/smart_contract/interpreter.rs	/^    fn apply_unary_operator(op: &UnaryOperator, value: &Value) -> Result<Value, String> {$/;"	P	implementation:Interpreter
apply_useful_work	src/qup/hdcomm.rs	/^    pub fn apply_useful_work(&self, state: &mut QUPState, useful_work: &UsefulWork) {$/;"	P	implementation:HDCommunication
approve_key_share	src/secure_core/secure_vault.rs	/^    pub fn approve_key_share(&self, sp_key_id: &str, owner_id: &str, target_user_id: &str) -> bo/;"	P	implementation:SecureVault
arbitration	src/chain/state_channel.rs	/^    pub arbitration: Option<Arbitration>,$/;"	m	struct:Dispute
arbitrator_details	src/chain/state_channel.rs	/^    pub arbitrator_details: String,$/;"	m	struct:Arbitration
are_other_block_properties_valid	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn are_other_block_properties_valid(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
are_other_transaction_properties_valid	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn are_other_transaction_properties_valid(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
are_valid_block_transactions	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn are_valid_block_transactions(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
are_valid_transaction_inputs	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn are_valid_transaction_inputs(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
are_valid_transaction_outputs	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn are_valid_transaction_outputs(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
args	src/api/handlers/smart_contract_handler.rs	/^    args: Vec<String>,$/;"	m	struct:CallRequest
args	src/api/routes/smart_contract.rs	/^    args: Vec<String>,$/;"	m	struct:CallRequest
as_bytes	src/crypto/post_quantum.rs	/^    pub fn as_bytes(&self) -> &[u8] {$/;"	P	implementation:DilithiumPublicKey
as_bytes	src/crypto/post_quantum.rs	/^    pub fn as_bytes(&self) -> &[u8] {$/;"	P	implementation:DilithiumSignature
as_bytes	src/crypto/post_quantum.rs	/^    pub fn as_bytes(&self) -> &[u8] {$/;"	P	implementation:KyberPublicKey
as_ref	src/crypto/hash.rs	/^    fn as_ref(&self) -> &[u8] {$/;"	P	implementation:ShardingHash
as_str	src/utils/node_id.rs	/^    pub fn as_str(&self) -> &str {$/;"	P	implementation:NodeId
assess_key_security	src/chain/quantum_voting/security_analysis.rs	/^    pub fn assess_key_security(&self, quantum_key: &QuantumKey) -> Result<bool, VotingError> {$/;"	P	implementation:SecurityAnalysis
assign_role	src/secure_core/access_control.rs	/^    pub fn assign_role(&self, user_id: &str, role: Role) {$/;"	P	implementation:AccessControl
audit_log	src/secure_core/secure_vault.rs	/^    audit_log: Arc<Mutex<Vec<(u64, String)>>>,$/;"	m	struct:SecureVault
audit_operation	src/secure_core/secure_vault.rs	/^    fn audit_operation(&self, operation: &str) {$/;"	P	implementation:SecureVault
author	src/smart_contract/types.rs	/^    pub author: String,$/;"	m	struct:SmartContract
b	src/zkp/constraint_system.rs	/^    pub b: Expression,$/;"	m	struct:EqualsConstraint
backup_sp_key	src/secure_core/secure_vault.rs	/^    async fn backup_sp_key(&self, sp_key_id: &str, encrypted_sp_key: &[u8]) -> Result<(), std::i/;"	P	implementation:SecureVault
balance	src/chain/governance/treasury.rs	/^    pub balance: u64,$/;"	m	struct:Treasury
balance	src/chain/state/account.rs	/^    pub balance: u64,$/;"	m	struct:Account
balance	src/chain/state_channel.rs	/^    pub balance: BTreeMap<String, f64>,$/;"	m	struct:StateChannelOptimized
balance_manager	src/utils/indexing.rs	/^    pub balance_manager: BalanceManager,$/;"	m	struct:BlockchainIndexer
balances	src/utils/indexing.rs	/^    balances: HashMap<String, f64>, \/\/ Cached balances for each address$/;"	m	struct:BalanceManager
ban_duration	src/api/models/request/network_request.rs	/^    pub ban_duration: Option<u64>, \/\/ Duration in seconds$/;"	m	struct:BanPeerRequest
banned_until	src/api/models/response/network_response.rs	/^    pub banned_until: Option<u64>, \/\/ Unix timestamp$/;"	m	struct:PeerInfo
benchmark_model	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    fn benchmark_model(&self, model: &HDCModel, dataset: &Dataset) -> HDCBenchmarkResult {$/;"	P	implementation:HDCBenchmarkSuite
benchmark_suite	src/hdcmodels/benchmarking/data_collection.rs	/^    pub benchmark_suite: HDCBenchmarkSuite,$/;"	m	struct:BenchmarkDataCollector
bitwidth	src/zkp/constraint_system.rs	/^    pub bitwidth: usize,$/;"	m	struct:RangeConstraint
bleu_score	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub bleu_score: f32,$/;"	m	struct:EvaluationResult
blind_quantum_voting	src/chain/quantum_voting/voting_protocols.rs	/^    pub fn blind_quantum_voting($/;"	P	implementation:VotingProtocols
blind_signature	src/chain/quantum_voting/voting_protocols.rs	/^    blind_signature: QuantumBlindSignature,$/;"	m	struct:VotingProtocols
blind_vote_state	src/chain/quantum_voting/voting_protocols.rs	/^    fn blind_vote_state($/;"	P	implementation:VotingProtocols
block	src/api/models/request/blockchain_request.rs	/^    pub block: BlockData,$/;"	m	struct:SubmitBlockRequest
block	src/api/models/response/blockchain_response.rs	/^    pub block: BlockData,$/;"	m	struct:GetBlockResponse
block	src/chain/mod.rs	/^pub(crate) mod block;$/;"	n
block	src/chain/storage/snapshot.rs	/^    pub block: Block,$/;"	m	struct:Snapshot
block	src/qup/lib.rs	/^pub mod block;$/;"	n
block	src/qup/mod.rs	/^pub mod block;$/;"	n
block_hash	src/api/models/request/blockchain_request.rs	/^    pub block_hash: Option<String>,$/;"	m	struct:GetBlockRequest
block_hash	src/api/models/response/blockchain_response.rs	/^    pub block_hash: String,$/;"	m	struct:SubmitBlockResponse
block_hash	src/network/node_message.rs	/^    pub block_hash: Hash,$/;"	m	struct:QUPVote
block_hash	src/qup/types.rs	/^    pub block_hash: Hash,$/;"	m	struct:QUPVote
block_height	src/api/handlers/blockchain_handler.rs	/^    block_height: u64,$/;"	m	struct:TransactionInfo
block_height	src/api/models/request/blockchain_request.rs	/^    pub block_height: Option<u64>,$/;"	m	struct:GetBlockRequest
block_height	src/api/routes/blockchain.rs	/^    block_height: u64,$/;"	m	struct:TransactionInfo
block_number	src/api/handlers/transaction_handler.rs	/^    block_number: Option<u64>,$/;"	m	struct:TransactionStatusResponse
block_number	src/api/handlers/transaction_handler.rs	/^    block_number: u64,$/;"	m	struct:TransactionInfo
block_number	src/api/models/request/transaction_request.rs	/^    pub block_number: Option<u64>,$/;"	m	struct:TransactionStatus
block_number	src/api/models/request/transaction_request.rs	/^    pub block_number: u64,$/;"	m	struct:Transaction
block_number	src/api/routes/transaction.rs	/^    block_number: Option<u64>,$/;"	m	struct:TransactionStatusResponse
block_number	src/api/routes/transaction.rs	/^    block_number: u64,$/;"	m	struct:TransactionInfo
block_producer	src/mining/miner.rs	/^    block_producer: BlockProducer,$/;"	m	struct:Miner
block_producer	src/mining/mod.rs	/^mod block_producer;$/;"	n
block_reward	src/mining/mining_config.rs	/^    block_reward: u64,$/;"	m	struct:MiningConfig
block_reward	src/mining/mining_config.rs	/^    pub fn block_reward(&self) -> u64 {$/;"	P	implementation:MiningConfig
block_reward	src/qup/config.rs	/^    pub block_reward: u64,$/;"	m	struct:QUPConfig
block_reward	src/types/mod.rs	/^mod block_reward;/;"	n
block_storage	src/chain/storage/mod.rs	/^mod block_storage;$/;"	n
block_sync_state	src/network/mod.rs	/^    block_sync_state: RwLock<BlockSyncState>,$/;"	m	struct:Network
block_tests	src/chain/block_tests.rs	/^mod block_tests {$/;"	n
blockchain	src/chain/mod.rs	/^pub(crate) mod blockchain;$/;"	n
blockchain	src/mining/block_producer.rs	/^    blockchain: Arc<Mutex<Blockchain>>,$/;"	m	struct:BlockProducer
blockchain	src/mining/miner.rs	/^    blockchain: Arc<Mutex<Blockchain>>,$/;"	m	struct:Miner
blockchain_routes	src/api/routes/blockchain.rs	/^pub fn blockchain_routes(cfg: &mut web::ServiceConfig) {$/;"	f
blockchain_utils	src/chain/blockchain.rs	/^pub(crate) mod blockchain_utils {$/;"	n
bootstrap_nodes	src/network/config.rs	/^    pub bootstrap_nodes: Vec<String>,$/;"	m	struct:NetworkConfig
bootstrap_nodes	src/network/discovery.rs	/^    bootstrap_nodes: Vec<Multiaddr>,$/;"	m	struct:Discovery
break_cost	src/smart_contract/gas.rs	/^    pub break_cost: u64,$/;"	m	struct:GasCost
broadcast	src/network/discovery.rs	/^    pub async fn broadcast(&mut self, message: ProtocolMessage) -> Result<(), NetworkError> {$/;"	P	implementation:Discovery
broadcast	src/network/mod.rs	/^    pub async fn broadcast(&self, message: Message) {$/;"	P	implementation:Network
broadcast_aggregated_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn broadcast_aggregated_model(&mut self, aggregated_model: Vec<Vec<f64>>) {$/;"	P	implementation:DistributedTrainingAggregator
broadcast_message	src/network/network_manager.rs	/^    pub async fn broadcast_message(&self, message: Message) -> Result<()> {$/;"	P	implementation:NetworkManager
broadcast_training_complete	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn broadcast_training_complete(&mut self) {$/;"	P	implementation:DistributedTrainingAggregator
build_level	src/zkp/crypto.rs	/^    fn build_level(prev_level: &[FieldElement]) -> Vec<FieldElement> {$/;"	P	implementation:QuantumResistantMerkleTree
build_merkle_tree	src/utils/merkle_tree.rs	/^    fn build_merkle_tree(leaves: &[Hash]) -> Hash {$/;"	P	implementation:MerkleTree
by_receiver	src/utils/indexing.rs	/^    by_receiver: HashMap<String, HashSet<String>>, \/\/ Maps receiver address to transaction IDs$/;"	m	struct:TransactionIndex
by_sender	src/utils/indexing.rs	/^    by_sender: HashMap<String, HashSet<String>>,   \/\/ Maps sender address to transaction IDs$/;"	m	struct:TransactionIndex
bytecode	src/api/handlers/smart_contract_handler.rs	/^    bytecode: String,$/;"	m	struct:ContractInfo
bytecode	src/api/handlers/smart_contract_handler.rs	/^    bytecode: String,$/;"	m	struct:DeployRequest
bytecode	src/api/models/request/smart_contract_request.rs	/^    pub bytecode: String,$/;"	m	struct:DeployContractRequest
bytecode	src/api/models/request/smart_contract_request.rs	/^    pub bytecode: String,$/;"	m	struct:DeployedContract
bytecode	src/api/routes/smart_contract.rs	/^    bytecode: String,$/;"	m	struct:ContractInfo
bytecode	src/api/routes/smart_contract.rs	/^    bytecode: String,$/;"	m	struct:DeployRequest
ca_public_key	src/chain/certificate_authority.rs	/^    ca_public_key: PublicKey,$/;"	m	struct:CertificateAuthorityClient
calculate_accuracy	src/hdcmodels/hdcmodels.rs	/^    fn calculate_accuracy(&self, encoded_data: &[Vec<f64>], trained_model: &[Vec<f64>]) -> f64 {$/;"	P	implementation:HDCModel
calculate_accuracy	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    fn calculate_accuracy(&self, input_tokens: &[String], output_tokens: &[String]) -> f32 {$/;"	P	implementation:Evaluator
calculate_bleu_score	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    fn calculate_bleu_score(&self, input_tokens: &[String], output_tokens: &[String]) -> f32 {$/;"	P	implementation:Evaluator
calculate_block_hash	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn calculate_block_hash(&self, block: &Block) -> Hash {$/;"	P	implementation:ConsensusSecurityMonitor
calculate_block_hash	src/qup/utils.rs	/^pub fn calculate_block_hash(block_header: &QUPBlockHeader) -> Hash {$/;"	f
calculate_block_size	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn calculate_block_size(&self, block: &Block) -> usize {$/;"	P	implementation:ConsensusSecurityMonitor
calculate_candidate_qubits	src/chain/quantum_voting/quantum_state_encoding.rs	/^    fn calculate_candidate_qubits(&self, candidate: &Candidate) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumStateEncoding
calculate_contract_cost	src/smart_contract/gas.rs	/^pub fn calculate_contract_cost(operations: &[Operation], gas_cost: &GasCost) -> u64 {$/;"	f
calculate_delegator_rewards	src/qup/reward.rs	/^    fn calculate_delegator_rewards($/;"	P	implementation:RewardDistributor
calculate_difficulty	src/mining/block_producer.rs	/^    fn calculate_difficulty(&self) -> u64 {$/;"	P	implementation:BlockProducer
calculate_efficiency	src/hdcmodels/hdcmodels.rs	/^    fn calculate_efficiency(&self, training_time: std::time::Duration) -> f64 {$/;"	P	implementation:HDCModel
calculate_expected_difficulty	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn calculate_expected_difficulty(&self, previous_block_hash: &Hash) -> u64 {$/;"	P	implementation:ConsensusSecurityMonitor
calculate_expression_cost	src/smart_contract/gas.rs	/^pub fn calculate_expression_cost(expression: &Expression, gas_cost: &GasCost) -> u64 {$/;"	f
calculate_generalizability	src/hdcmodels/hdcmodels.rs	/^    fn calculate_generalizability($/;"	P	implementation:HDCModel
calculate_hash	src/chain/block.rs	/^    pub fn calculate_hash(&self) -> String {$/;"	P	implementation:Block
calculate_hash	src/chain/governance/proposal.rs	/^    pub fn calculate_hash(&self) -> Vec<u8> {$/;"	P	implementation:Proposal
calculate_loss	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    fn calculate_loss(&self, input_tokens: &[String], output_tokens: &[String]) -> f32 {$/;"	P	implementation:Evaluator
calculate_max_qubit_overhead	src/chain/quantum_voting/quantum_voting.rs	/^    fn calculate_max_qubit_overhead($/;"	P	implementation:QuantumVoting
calculate_mean	src/utils/mod.rs	/^pub fn calculate_mean(values: &[f64]) -> f64 {$/;"	f
calculate_merkle_root	src/chain/block.rs	/^    fn calculate_merkle_root(&self) -> Result<String, BlockError> {$/;"	P	implementation:Block
calculate_merkle_root	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn calculate_merkle_root(&self, transactions: &[Transaction]) -> Hash {$/;"	P	implementation:ConsensusSecurityMonitor
calculate_min_error_correction_rate	src/chain/quantum_voting/quantum_voting.rs	/^    fn calculate_min_error_correction_rate($/;"	P	implementation:QuantumVoting
calculate_operation_cost	src/smart_contract/gas.rs	/^pub fn calculate_operation_cost(operation: &Operation, gas_cost: &GasCost) -> u64 {$/;"	f
calculate_perplexity	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    fn calculate_perplexity(&self, input_tokens: &[String], output_tokens: &[String]) -> f32 {$/;"	P	implementation:Evaluator
calculate_reward	src/chain/governance/staking.rs	/^    pub fn calculate_reward(&self, staker: &str) -> Option<u64> {$/;"	P	implementation:Staking
calculate_reward_per_participant	src/chain/governance/rewards.rs	/^    fn calculate_reward_per_participant(&self, total_participation: u64) -> u64 {$/;"	P	implementation:Rewards
calculate_rewards	src/qup/state.rs	/^    pub fn calculate_rewards(&self, block: &QUPBlock) -> Result<HashMap<Address, u64>, Error> {$/;"	P	implementation:QUPState
calculate_robustness	src/hdcmodels/hdcmodels.rs	/^    fn calculate_robustness(&self, encoded_data: &[Vec<f64>], trained_model: &[Vec<f64>]) -> f64/;"	P	implementation:HDCModel
calculate_shard_for_transaction	src/chain/shard.rs	/^    fn calculate_shard_for_transaction(&self, transaction: &Transaction) -> u64 {$/;"	P	implementation:Shard
calculate_shard_for_transaction	src/chain/sharding.rs	/^    fn calculate_shard_for_transaction(&self, transaction: &Transaction) -> u64 {$/;"	P	implementation:Sharding
calculate_similarity	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    fn calculate_similarity(&self, encoded_data: &[f64], label: &str) -> f64 {$/;"	P	implementation:IncrementalLearningHDCModel
calculate_similarity	src/hdcmodels/continuous_learning/online_learning.rs	/^    fn calculate_similarity(&self, encoded_data: &[f64], label: &str) -> f64 {$/;"	P	implementation:OnlineLearningHDCModel
calculate_standard_deviation	src/utils/mod.rs	/^pub fn calculate_standard_deviation(values: &[f64]) -> f64 {$/;"	f
calculate_total_reward	src/qup/reward.rs	/^    fn calculate_total_reward(&self, block_header: &QUPBlockHeader) -> u64 {$/;"	P	implementation:RewardDistributor
calculate_transaction_hash	src/qup/utils.rs	/^pub fn calculate_transaction_hash(transaction: &QUPTransaction) -> Hash {$/;"	f
calculate_validator_reward	src/qup/reward.rs	/^    fn calculate_validator_reward(&self, total_reward: u64) -> u64 {$/;"	P	implementation:RewardDistributor
calculate_vote_qubits	src/chain/quantum_voting/quantum_state_encoding.rs	/^    fn calculate_vote_qubits(&self, vote: &Vote) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumStateEncoding
calculate_voting_qubits_required	src/chain/quantum_voting/quantum_voting.rs	/^    fn calculate_voting_qubits_required(&self) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumVoting
call	src/api/middleware/authorization.rs	/^    fn call(&self, req: ServiceRequest) -> Self::Future {$/;"	f
call	src/api/middleware/rate_limiter.rs	/^    fn call(&self, req: ServiceRequest) -> Self::Future {$/;"	f
call	src/api/middleware/request_validator.rs	/^    fn call(&self, req: ServiceRequest) -> Self::Future {$/;"	f
call_contract	src/api/handlers/smart_contract_handler.rs	/^pub async fn call_contract($/;"	f
call_contract	src/api/routes/smart_contract.rs	/^async fn call_contract($/;"	f
can_accept_inbound_peer	src/network/mod.rs	/^    fn can_accept_inbound_peer(&self) -> bool {$/;"	P	implementation:Network
candidates	src/chain/quantum_voting/voting_state.rs	/^    candidates: RwLock<Vec<Candidate>>,$/;"	m	struct:VotingState
capacity	src/mining/transaction_pool.rs	/^    capacity: usize,$/;"	m	struct:TransactionPool
capacity	src/qup/types.rs	/^    pub capacity: u64,$/;"	m	struct:KnapsackProblem
capture_error	src/error_handling/error_reporter.rs	/^    fn capture_error<E: fmt::Debug + fmt::Display>(&self, error: E, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
cast_vote	src/chain/governance/voting.rs	/^    pub fn cast_vote(&mut self, vote: Vote) -> Result<(), String> {$/;"	P	implementation:Voting
certificate	src/network/tls.rs	/^    pub certificate: Certificate,$/;"	m	struct:PostQuantumTLSConfig
certificate_authority	src/chain/mod.rs	/^mod certificate_authority;$/;"	n
certificate_authority	src/chain/node.rs	/^    certificate_authority: Arc<CertificateAuthority>,$/;"	m	struct:Node
chain	src/chain/blockchain.rs	/^    chain: Arc<RwLock<Vec<Arc<Block>>>>,$/;"	m	struct:Blockchain
chain	src/main.rs	/^mod chain; \/\/ Core blockchain functionality and data structures$/;"	n
changes	src/smart_contract/types.rs	/^    pub changes: HashMap<String, Value>,$/;"	m	struct:TransactionContext
channels	src/chain/state_channel.rs	/^    pub channels: Arc<RwLock<HashMap<String, StateChannelOptimized>>>,$/;"	m	struct:ChannelManagerOptimized
check_balance_ui	src/ui.rs	/^fn check_balance_ui(blockchain: &Arc<Mutex<Blockchain>>) {$/;"	f
check_channel_security	src/chain/quantum_voting/security_analysis.rs	/^    fn check_channel_security($/;"	P	implementation:SecurityAnalysis
check_node_heartbeats	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn check_node_heartbeats(&mut self) {$/;"	P	implementation:FaultTolerantDistributedTrainingAggregator
check_permission	src/secure_core/access_control.rs	/^    pub fn check_permission(&self, user_id: &str, permission: Permission) -> bool {$/;"	P	implementation:AccessControl
check_rate_limit	src/api/middleware/rate_limiter.rs	/^    fn check_rate_limit(&self, client_id: &str) -> Result<(), Error> {$/;"	P	implementation:RateLimiter
check_vote_integrity	src/chain/quantum_voting/security_analysis.rs	/^    fn check_vote_integrity(&self, vote_state: &QuantumState) -> Result<bool, VotingError> {$/;"	P	implementation:SecurityAnalysis
children	src/chain/state/merkle_trie.rs	/^    pub children: HashMap<u8, Arc<TrieNode>>,$/;"	m	struct:TrieNode
choose_error_correction_code	src/chain/quantum_voting/error_correction.rs	/^    fn choose_error_correction_code(&self) -> Result<QuantumErrorCorrectionCode, VotingError> {$/;"	P	implementation:ErrorCorrection
choose_error_correction_code	src/chain/quantum_voting/quantum_voting.rs	/^    fn choose_error_correction_code(&self) -> Result<QuantumErrorCorrectionCode, VotingError> {$/;"	P	implementation:QuantumVoting
choose_quantum_compression_scheme	src/chain/quantum_voting/compression.rs	/^    fn choose_quantum_compression_scheme(&self) -> Result<QuantumCompressionScheme, VotingError>/;"	P	implementation:Compression
ciphertext	src/secure_core/secure_communication.rs	/^    pub ciphertext: Vec<u8>,$/;"	m	struct:SecureMessage
ciphertext	src/secure_core/secure_storage.rs	/^    pub ciphertext: Vec<u8>,$/;"	m	struct:EncryptedData
circuit	src/chain/quantum_voting/quantum_state_encoding.rs	/^    circuit: QuantumCircuit,$/;"	m	struct:QuantumStateEncoding
circuit	src/chain/quantum_voting/quantum_state_preparation.rs	/^    circuit: QuantumCircuit,$/;"	m	struct:QuantumStatePreparation
claim_reward	src/chain/governance/rewards.rs	/^    pub async fn claim_reward($/;"	P	implementation:Rewards
claim_rewards	src/qup/delegator.rs	/^    pub fn claim_rewards(&mut self) -> Result<u64, Error> {$/;"	P	implementation:QUPDelegator
clear	src/mining/transaction_pool.rs	/^    pub fn clear(&self) {$/;"	P	implementation:TransactionPool
clear_state	src/smart_contract/execution_context.rs	/^    pub fn clear_state(&mut self) {$/;"	P	implementation:ExecutionContext
client	src/network/lib.rs	/^pub mod client;$/;"	n
client	src/network/mod.rs	/^mod client;$/;"	n
client_buckets	src/api/middleware/rate_limiter.rs	/^    client_buckets: Arc<Mutex<HashMap<String, ClientBucket>>>,$/;"	m	struct:RateLimiter
clone_state	src/crypto/quantum_state.rs	/^    fn clone_state(&self) -> Arc<dyn QuantumState> {$/;"	P	implementation:TimeBinState
clone_state	src/crypto/quantum_state.rs	/^    fn clone_state(&self) -> Arc<dyn QuantumState>;$/;"	P	interface:QuantumState
clone_subsystem	src/crypto/quantum_state.rs	/^    pub fn clone_subsystem(&self, node: usize) -> Result<TimeBinState> {$/;"	P	implementation:TimeBinState
close_channel	src/chain/state_channel.rs	/^    pub async fn close_channel(&mut self, blockchain: &mut Blockchain) -> Result<(), StateChanne/;"	P	implementation:StateChannelOptimized
close_channel	src/chain/state_channel.rs	/^    pub async fn close_channel(&mut self, channel_id: &str, blockchain: &mut Blockchain) -> Resu/;"	P	implementation:ChannelManagerOptimized
close_connection	src/chain/quantum_entropy.rs	/^    pub async fn close_connection(&self, node_id: &str) -> Result<(), QuantumEntropyError> {$/;"	P	implementation:QuantumResistantConnectionManager
close_quantum_resistant_connection	src/chain/quantum_entropy.rs	/^pub async fn close_quantum_resistant_connection($/;"	f
closed	src/chain/state_channel.rs	/^    pub closed: bool,$/;"	m	struct:StateChannelOptimized
cluster_proposals	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    pub fn cluster_proposals(&self, proposals: &[Proposal]) -> Vec<Vec<Proposal>> {$/;"	P	implementation:ProposalAnalyzer
code	src/smart_contract/types.rs	/^    pub code: String,$/;"	m	struct:SmartContract
code_vector	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    code_vector: Vec<f64>,$/;"	m	struct:ProposalAnalysis
coefficients	src/zkp/math.rs	/^    pub coefficients: Vec<FieldElement>,$/;"	m	struct:PolynomialCommitment
collect_data	src/hdcmodels/benchmarking/data_collection.rs	/^    pub async fn collect_data(&self) -> HashMap<String, Vec<HDCBenchmarkResult>> {$/;"	P	implementation:BenchmarkDataCollector
collect_votes	src/chain/quantum_voting/vote_collection.rs	/^    pub fn collect_votes(&self) -> Result<HashMap<String, Vec<String>>, VotingError> {$/;"	P	implementation:VoteCollection
combine_generated_code	src/hdcmodels/model_integration/hybrid_models.rs	/^    fn combine_generated_code(&self, code1: &str, code2: &str) -> String {$/;"	P	implementation:HybridModel
commit	src/chain/blockchain.rs	/^    pub async fn commit(&self) -> Result<(), BlockchainError> {$/;"	P	implementation:Blockchain
commit	src/chain/state/state_manager.rs	/^    pub fn commit(&self) {$/;"	P	implementation:StateManager
commit_block	src/qup/consensus.rs	/^    pub fn commit_block(&mut self, block: QUPBlock) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
commit_phase_merkle_roots	src/zkp/zk_starks.rs	/^    pub commit_phase_merkle_roots: Vec<FieldElement>,$/;"	m	struct:FriProof
commit_qup_shard_block	src/network/shard_message.rs	/^    async fn commit_qup_shard_block(&mut self, shard_id: u64, block_header: QUPBlockHeader) -> R/;"	f
commit_transaction	src/smart_contract/execution_context.rs	/^    pub fn commit_transaction(&mut self) {$/;"	P	implementation:ExecutionContext
commitments	src/zkp/zk_starks.rs	/^    pub commitments: Vec<PolynomialCommitment>,$/;"	m	struct:ZkStarksProof
communication	src/chain/quantum_voting/mod.rs	/^    communication: QuantumCommunication,$/;"	m	struct:QuantumVoting
compare_hashes	src/secure_core/security_utils.rs	/^    pub fn compare_hashes(hash1: &[u8], hash2: &[u8]) -> bool {$/;"	P	implementation:SecurityUtils
compare_proposals	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    pub fn compare_proposals(&self, proposal1: &Proposal, proposal2: &Proposal) -> f64 {$/;"	P	implementation:ProposalAnalyzer
compare_quantum_states	src/chain/quantum_voting/utils.rs	/^pub fn compare_quantum_states($/;"	f
compress_and_store_transaction	src/chain/shard.rs	/^    fn compress_and_store_transaction(&mut self, transaction: Transaction) -> Result<(), ShardEr/;"	P	implementation:Shard
compress_data	src/utils/compression.rs	/^pub fn compress_data(data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
compress_data_lz4	src/utils/compression.rs	/^pub fn compress_data_lz4(data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
compress_data_zstd	src/utils/compression.rs	/^pub fn compress_data_zstd(data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
compression	src/utils/mod.rs	/^mod compression;$/;"	n
compute_load	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn compute_load(&self) -> f64 {$/;"	P	implementation:HDCModel
compute_load	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn compute_load(&self) -> f64 {$/;"	P	implementation:MyDataType
compute_load	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn compute_load(&self) -> f64 {$/;"	P	implementation:String
compute_load	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn compute_load(&self) -> f64 {$/;"	P	implementation:Vec
compute_load	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn compute_load(&self) -> f64;$/;"	P	interface:DataItem
concatenate_and_hash	src/secure_core/security_utils.rs	/^    pub fn concatenate_and_hash(data1: &[u8], data2: &[u8]) -> Vec<u8> {$/;"	P	implementation:SecurityUtils
conclude_arbitration	src/chain/state_channel.rs	/^    pub fn conclude_arbitration(&mut self, resolution: DisputeResolution) -> Result<(), StateCha/;"	P	implementation:StateChannelOptimized
conclude_voting	src/chain/quantum_voting/quantum_voting.rs	/^    pub fn conclude_voting(&self) -> VotingResult {$/;"	P	implementation:QuantumVoting
conclude_voting	src/chain/quantum_voting/voting_state.rs	/^    pub fn conclude_voting(&self) -> Result<(), VotingError> {$/;"	P	implementation:VotingState
config	src/api/models/response/network_response.rs	/^    pub config: NetworkConfig,$/;"	m	struct:GetNetworkConfigResponse
config	src/chain/certificate_authority.rs	/^    config: Arc<CertificateAuthorityConfig>,$/;"	m	struct:CertificateAuthority
config	src/mining/block_producer.rs	/^    config: MiningConfig,$/;"	m	struct:BlockProducer
config	src/network/lib.rs	/^    pub config: NetworkConfig,$/;"	m	struct:Network
config	src/network/lib.rs	/^pub mod config;$/;"	n
config	src/network/mod.rs	/^mod config;$/;"	n
config	src/network/network_manager.rs	/^    config: Arc<NetworkConfig>,$/;"	m	struct:NetworkManager
config	src/qup/consensus.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:QUPConsensus
config	src/qup/crypto.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:QUPCrypto
config	src/qup/delegator.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:QUPDelegator
config	src/qup/hdcomm.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:HDCommunication
config	src/qup/lib.rs	/^pub mod config;$/;"	n
config	src/qup/mod.rs	/^pub mod config;$/;"	n
config	src/qup/reward.rs	/^    config: QUPConfig,$/;"	m	struct:RewardDistributor
config	src/qup/state.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:QUPState
config	src/qup/validator.rs	/^    pub config: Arc<QUPConfig>,$/;"	m	struct:QUPValidator
connect	src/network/lib.rs	/^    pub fn connect(&mut self, address: &str) -> Result<(), NetworkError> {$/;"	P	implementation:Network
connect	src/network/mod.rs	/^    pub async fn connect(&self, address: &str) -> Result<(), PeerError> {$/;"	P	implementation:Network
connect_to_bootstrap_nodes	src/network/network_manager.rs	/^    async fn connect_to_bootstrap_nodes(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
connection	src/network/tls.rs	/^    connection: ClientConnection,$/;"	m	struct:PostQuantumTLSConnection
connection_manager	src/chain/governance/governance_engine.rs	/^    connection_manager: Arc<QuantumResistantConnectionManager>,$/;"	m	struct:GovernanceEngine
connection_manager	src/chain/node.rs	/^    connection_manager: Arc<QuantumResistantConnectionManager>,$/;"	m	struct:Node
connection_manager	src/chain/sharding.rs	/^    connection_manager: Arc<QuantumResistantConnectionManager>,$/;"	m	struct:Sharding
connection_manager	src/chain/state_channel.rs	/^    connection_manager: Arc<QuantumResistantConnectionManager>,$/;"	m	struct:ChannelManagerOptimized
connections	src/chain/quantum_entropy.rs	/^    connections: Arc<QuantumResistantConnection>,$/;"	m	struct:QuantumResistantConnectionManager
consensus	src/main.rs	/^mod consensus; \/\/ Consensus mechanisms$/;"	n
consensus	src/network/mod.rs	/^    consensus: Arc<dyn Consensus>,$/;"	m	struct:Network
consensus	src/network/sync/state_sync.rs	/^    consensus: Arc<dyn Consensus>,$/;"	m	struct:StateSync
consensus	src/qup/lib.rs	/^pub mod consensus;$/;"	n
consensus	src/qup/mod.rs	/^pub mod consensus;$/;"	n
consensus_config	src/chain/shard.rs	/^    consensus_config: ConsensusConfig,$/;"	m	struct:Shard
consensus_config	src/qup/config.rs	/^    pub consensus_config: ConsensusConfig,$/;"	m	struct:QUPConfig
consensus_routes	src/api/routes/consensus.rs	/^pub fn consensus_routes(cfg: &mut web::ServiceConfig) {$/;"	f
consensus_type	src/api/routes/consensus.rs	/^    consensus_type: String,$/;"	m	struct:ConsensusState
constant	src/zkp/constraint_system.rs	/^    pub fn constant(value: FieldElement) -> Self {$/;"	P	implementation:Expression
constraint_system	src/zkp/mod.rs	/^mod constraint_system;$/;"	n
constraints	src/zkp/constraint_system.rs	/^    pub constraints: Vec<(Expression, Expression)>,$/;"	m	struct:ConstraintSystemImpl
constructor_args	src/api/handlers/smart_contract_handler.rs	/^    constructor_args: Vec<String>,$/;"	m	struct:ContractInfo
constructor_args	src/api/handlers/smart_contract_handler.rs	/^    constructor_args: Vec<String>,$/;"	m	struct:DeployRequest
constructor_args	src/api/models/request/smart_contract_request.rs	/^    pub constructor_args: Vec<ContractFunctionInput>,$/;"	m	struct:DeployedContract
constructor_args	src/api/models/request/smart_contract_request.rs	/^    pub constructor_args: Vec<String>,$/;"	m	struct:DeployContractRequest
constructor_args	src/api/routes/smart_contract.rs	/^    constructor_args: Vec<String>,$/;"	m	struct:ContractInfo
constructor_args	src/api/routes/smart_contract.rs	/^    constructor_args: Vec<String>,$/;"	m	struct:DeployRequest
contains	src/mining/transaction_pool.rs	/^    pub fn contains(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:TransactionPool
context	src/zephyrchain_circuit.rs	/^    fn context(&self) -> &AirContext<Self::BaseField> {$/;"	P	implementation:ZephyrChainCircuit
context	src/zephyrchain_circuit.rs	/^    pub context: AirContext<BaseElement>,$/;"	m	struct:ZephyrChainCircuit
continue_cost	src/smart_contract/gas.rs	/^    pub continue_cost: u64,$/;"	m	struct:GasCost
contract_address	src/api/models/request/smart_contract_request.rs	/^    pub contract_address: String,$/;"	m	struct:CallContractRequest
contract_address	src/api/models/request/smart_contract_request.rs	/^    pub contract_address: String,$/;"	m	struct:GetContractRequest
contract_address	src/api/models/request/smart_contract_request.rs	/^    pub contract_address: String,$/;"	m	struct:GetContractStateRequest
contract_storage	src/chain/storage/mod.rs	/^mod contract_storage;$/;"	n
correct_errors	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn correct_errors($/;"	P	implementation:QUPErrorCorrection
cosine_similarity	src/hdcmodels/similarity.rs	/^pub fn cosine_similarity(vec1: &[f64], vec2: &[f64]) -> f64 {$/;"	f
cosine_similarity	src/utils/mod.rs	/^pub fn cosine_similarity(vec1: &[f64], vec2: &[f64]) -> f64 {$/;"	f
cosine_similarity_gpu	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    fn cosine_similarity_gpu(&self, a: &Array<f64>, b: &Array<f64>) -> f64 {$/;"	P	implementation:GPUHDCModel
create_block_template	src/mining/block_producer.rs	/^    pub fn create_block_template(&self, transactions: Vec<Transaction>) -> Block {$/;"	P	implementation:BlockProducer
create_channel	src/chain/state_channel.rs	/^    pub fn create_channel(&mut self, id: String, party1: String, party2: String) -> Result<(), S/;"	P	implementation:ChannelManagerOptimized
create_channel_route	src/chain/state_channel.rs	/^fn create_channel_route($/;"	f
create_directory_if_not_exists	src/utils/mod.rs	/^pub fn create_directory_if_not_exists(path: &str) -> Result<(), std::io::Error> {$/;"	f
create_proposal	src/chain/governance/governance_engine.rs	/^    pub async fn create_proposal(&self, proposal: Proposal) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
create_proposal_transaction	src/chain/governance/proposal.rs	/^    pub fn create_proposal_transaction(&self) -> ProposalTransaction {$/;"	P	implementation:Proposal
created_at	src/chain/governance/proposal.rs	/^    pub created_at: Timestamp,$/;"	m	struct:Proposal
crypto	src/main.rs	/^mod crypto;$/;"	n
crypto	src/network/client.rs	/^    crypto: Arc<QUPCrypto>,$/;"	m	struct:Client
crypto	src/network/discovery.rs	/^    crypto: QUPCrypto,$/;"	m	struct:Discovery
crypto	src/network/network_manager.rs	/^    crypto: QUPCrypto,$/;"	m	struct:NetworkManager
crypto	src/network/node_message.rs	/^    crypto: QUPCrypto,$/;"	m	struct:NodeMessageHandler
crypto	src/network/server.rs	/^    crypto: Arc<QUPCrypto>,$/;"	m	struct:Server
crypto	src/network/shard_message.rs	/^    crypto: QUPCrypto,$/;"	m	struct:ShardMessageHandler
crypto	src/qup/lib.rs	/^pub mod crypto;$/;"	n
crypto	src/qup/mod.rs	/^pub mod crypto;$/;"	n
crypto	src/zkp/mod.rs	/^mod crypto;$/;"	n
cryptography	src/chain/quantum_voting/mod.rs	/^    cryptography: QuantumCryptography,$/;"	m	struct:QuantumVoting
current_epoch	src/api/handlers/qup_handler.rs	/^    current_epoch: u64,$/;"	m	struct:QUPState
current_epoch	src/api/models/response/qup_response.rs	/^    pub current_epoch: u64,$/;"	m	struct:QUPState
current_epoch	src/api/routes/consensus.rs	/^    current_epoch: u64,$/;"	m	struct:QDPoSState
current_round	src/api/routes/consensus.rs	/^    current_round: u64,$/;"	m	struct:PoUWState
data	src/chain/storage/database.rs	/^    data: HashMap<Vec<u8>, Vec<u8>>,$/;"	m	struct:MemoryDatabase
data	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub data: Vec<(Vec<f64>, String)>,$/;"	m	struct:Dataset
data_collector	src/hdcmodels/benchmarking/analysis.rs	/^    data_collector: BenchmarkDataCollector,$/;"	m	struct:BenchmarkAnalyzer
data_type	src/api/models/request/smart_contract_request.rs	/^    pub data_type: String,$/;"	m	struct:ContractFunctionInput
database	src/chain/storage/mod.rs	/^mod database;/;"	n
dataset	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    dataset: &'a CodeDataset,$/;"	m	struct:Evaluator
dataset	src/optimization_problems/hdc_code_generation/mod.rs	/^mod dataset;$/;"	n
dataset_id	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub dataset_id: String,$/;"	m	struct:HDCBenchmarkResult
dataset_id	src/hdcmodels/benchmarking/reporting.rs	/^    pub dataset_id: String,$/;"	m	struct:BenchmarkReport
datasets	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    datasets: Vec<Dataset>,$/;"	m	struct:HDCBenchmarkSuite
db	src/chain/state/state_db.rs	/^    db: DB,$/;"	m	struct:StateDB
db	src/chain/storage/block_storage.rs	/^    db: Box<dyn Database>,$/;"	m	struct:BlockStorage
db	src/chain/storage/contract_storage.rs	/^    db: Box<dyn Database>,$/;"	m	struct:ContractStorage
deallocate	src/chain/governance/treasury.rs	/^    pub fn deallocate(&mut self, allocation_id: &str) -> Result<(), String> {$/;"	P	implementation:Treasury
decode	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn decode(&self, encoded_data: &[f64]) -> Result<Vec<f64>, QuantumErrorCorrectionError> /;"	P	implementation:QUPErrorCorrection
decode_and_correct_state	src/chain/quantum_voting/error_correction.rs	/^    fn decode_and_correct_state($/;"	P	implementation:ErrorCorrection
decode_and_correct_state	src/chain/quantum_voting/quantum_voting.rs	/^    fn decode_and_correct_state($/;"	P	implementation:QuantumVoting
decode_block	src/qup/hdcomm.rs	/^    pub fn decode_block(&self, encoded_block: &[f64]) -> QUPBlock {$/;"	P	implementation:HDCommunication
decode_candidate	src/chain/quantum_voting/quantum_state_decoding.rs	/^    pub fn decode_candidate($/;"	P	implementation:QuantumStateDecoding
decode_candidate_data	src/chain/quantum_voting/quantum_state_decoding.rs	/^    fn decode_candidate_data($/;"	P	implementation:QuantumStateDecoding
decode_natural_language	src/hdcmodels/qup_integration/qup_decoding.rs	/^    pub fn decode_natural_language(&self, encoded_text: &[f64]) -> String {$/;"	P	implementation:QUPDecoding
decode_rust_code	src/hdcmodels/model_integration/hybrid_models.rs	/^    fn decode_rust_code(&self, tensor: &Tensor) -> String {$/;"	P	implementation:HybridModel
decode_rust_code	src/hdcmodels/model_integration/transfer_learning.rs	/^    fn decode_rust_code(&self, tensor: &Tensor) -> String {$/;"	P	implementation:TransferLearningModel
decode_rust_code	src/hdcmodels/qup_integration/qup_decoding.rs	/^    pub fn decode_rust_code(&self, encoded_code: &[f64]) -> String {$/;"	P	implementation:QUPDecoding
decode_smart_contract	src/hdcmodels/qup_integration/qup_decoding.rs	/^    pub fn decode_smart_contract(&self, encoded_contract: &[f64]) -> String {$/;"	P	implementation:QUPDecoding
decode_transaction	src/qup/hdcomm.rs	/^    fn decode_transaction(&self, encoded_tx: &mut Vec<f64>) -> Transaction {$/;"	P	implementation:HDCommunication
decode_transactional_data	src/hdcmodels/qup_integration/qup_decoding.rs	/^    pub fn decode_transactional_data(&self, encoded_data: &[f64]) -> Vec<Transaction> {$/;"	P	implementation:QUPDecoding
decode_useful_work	src/qup/hdcomm.rs	/^    fn decode_useful_work(&self, encoded_useful_work: &mut Vec<f64>) -> UsefulWork {$/;"	P	implementation:HDCommunication
decode_vote	src/chain/quantum_voting/quantum_state_decoding.rs	/^    pub fn decode_vote(&self, vote_register: &QuantumRegister) -> Result<Vote, VotingError> {$/;"	P	implementation:QuantumStateDecoding
decode_vote_data	src/chain/quantum_voting/quantum_state_decoding.rs	/^    fn decode_vote_data(&self, vote_measurement: &QuantumMeasurement) -> Result<Vote, VotingErro/;"	P	implementation:QuantumStateDecoding
decompress_and_decrypt_data	src/chain/shard.rs	/^    fn decompress_and_decrypt_data(&self, compressed_data: &[u8], secure_vault: &SecureVault) ->/;"	P	implementation:Shard
decompress_data	src/utils/compression.rs	/^pub fn decompress_data(compressed_data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
decompress_data_lz4	src/utils/compression.rs	/^pub fn decompress_data_lz4(compressed_data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
decompress_data_zstd	src/utils/compression.rs	/^pub fn decompress_data_zstd(compressed_data: &[u8]) -> Result<Vec<u8>, CompressionError> {$/;"	f
decrypt	src/crypto/post_quantum.rs	/^    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, PostQuantumError> {$/;"	P	implementation:KyberKeypair
decrypt	src/crypto/post_quantum.rs	/^    pub fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, PostQuantumError> {$/;"	P	implementation:KyberSecretKey
decrypt	src/qup/crypto.rs	/^    fn decrypt(&self, encrypted_message: &[u8], secret_key: &Self::SecretKey) -> Vec<u8> {$/;"	P	implementation:QUPCrypto
decrypt	src/qup/crypto.rs	/^    pub fn decrypt(&self, encrypted_message: &[u8], secret_key: &KyberSecretKey) -> Vec<u8> {$/;"	P	implementation:QUPCrypto
decrypt	src/secure_core/secure_storage.rs	/^    pub fn decrypt<T: DeserializeOwned>(&self, encrypted_data: &EncryptedData, key: &[u8; 32]) -/;"	P	implementation:SecureStorage
decrypt_aes_256_gcm	src/utils/encryption.rs	/^pub fn decrypt_aes_256_gcm($/;"	f
decrypt_chacha20_poly1305	src/utils/encryption.rs	/^pub fn decrypt_chacha20_poly1305($/;"	f
decrypt_details	src/chain/transaction.rs	/^    pub fn decrypt_details(&self, key: &[u8]) -> Result<Self, TransactionError> {$/;"	P	implementation:Transaction
decrypt_message	src/network/quantum_resistant.rs	/^    fn decrypt_message(&self, encrypted_message: &[u8]) -> Result<Vec<u8>, NetworkError> {$/;"	P	implementation:QuantumResistantConnection
decrypt_message	src/secure_core/secure_communication.rs	/^    pub fn decrypt_message($/;"	P	implementation:SecureCommunication
decrypt_vote	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn decrypt_vote($/;"	P	implementation:QuantumCryptography
decrypt_vote	src/chain/quantum_voting/vote_collection.rs	/^    fn decrypt_vote($/;"	P	implementation:VoteCollection
decrypt_with_master_key	src/secure_core/secure_vault.rs	/^    fn decrypt_with_master_key(&self, data: &[u8]) -> Result<Vec<u8>, AesGcmError> {$/;"	P	implementation:SecureVault
default	src/api/middleware/request_validator.rs	/^    fn default() -> Self {$/;"	P	implementation:RequestModel
default	src/chain/state/account.rs	/^    fn default() -> Self {$/;"	P	implementation:Account
default	src/mining/mining_config.rs	/^    fn default() -> Self {$/;"	P	implementation:MiningConfig
default	src/network/config.rs	/^    fn default() -> Self {$/;"	P	implementation:NetworkConfig
default	src/smart_contract/gas.rs	/^    fn default() -> Self {$/;"	P	implementation:GasCost
define_desired_code_properties	src/chain/quantum_voting/error_correction.rs	/^    fn define_desired_code_properties($/;"	P	implementation:ErrorCorrection
define_desired_code_properties	src/chain/quantum_voting/quantum_voting.rs	/^    fn define_desired_code_properties($/;"	P	implementation:QuantumVoting
delegate	src/qup/delegator.rs	/^    pub fn delegate(&mut self, validator: &Address, amount: u64) -> Result<(), Error> {$/;"	P	implementation:QUPDelegator
delegate	src/qup/validator.rs	/^    pub fn delegate(&mut self, delegator: &Address, amount: u64) {$/;"	P	implementation:QUPValidator
delegated_stake	src/qup/validator.rs	/^    pub delegated_stake: u64,$/;"	m	struct:QUPValidator
delegated_to	src/qup/delegator.rs	/^    pub delegated_to: Option<Address>,$/;"	m	struct:QUPDelegator
delegator	src/qup/lib.rs	/^pub mod delegator;$/;"	n
delegator	src/qup/mod.rs	/^pub mod delegator;$/;"	n
delegator_reward_ratio	src/api/models/response/qup_response.rs	/^    pub delegator_reward_ratio: f64,$/;"	m	struct:QUPParameters
delegators	src/qup/state.rs	/^    pub delegators: HashMap<Address, QUPDelegator>,$/;"	m	struct:QUPState
delete	src/chain/governance/proposal.rs	/^    pub async fn delete(&self, storage: &Arc<ProposalStorage>) -> Result<(), GovernanceError> {$/;"	P	implementation:Proposal
delete	src/chain/storage/database.rs	/^    fn delete(&self, key: &[u8]) -> Result<(), DatabaseError> {$/;"	P	implementation:MemoryDatabase
delete	src/chain/storage/database.rs	/^    fn delete(&self, key: &[u8]) -> Result<(), DatabaseError>;$/;"	P	interface:Database
delete	src/chain/storage/snapshot.rs	/^    pub fn delete(path: &Path) -> Result<(), SnapshotError> {$/;"	P	implementation:Snapshot
delete_contract	src/chain/storage/contract_storage.rs	/^    pub fn delete_contract(&self, contract_id: &str) -> Result<(), ContractStorageError> {$/;"	P	implementation:ContractStorage
deploy_contract	src/api/handlers/smart_contract_handler.rs	/^pub async fn deploy_contract($/;"	f
deploy_contract	src/api/routes/smart_contract.rs	/^async fn deploy_contract($/;"	f
deploy_contract	src/chain/storage/contract_storage.rs	/^    pub fn deploy_contract(&self, contract: &SmartContract) -> Result<(), ContractStorageError> /;"	P	implementation:ContractStorage
deposit	src/chain/governance/treasury.rs	/^    pub fn deposit(&mut self, amount: u64) {$/;"	P	implementation:Treasury
derive_aes_key	src/secure_core/secure_communication.rs	/^    fn derive_aes_key(&self, shared_secret: &[u8; 32]) -> [u8; 32] {$/;"	P	implementation:SecureCommunication
derive_key	src/secure_core/security_utils.rs	/^    pub fn derive_key(password: &str, salt: &[u8], iterations: u32, key_length: usize) -> Vec<u8/;"	P	implementation:SecurityUtils
derive_shared_secret	src/secure_core/secure_communication.rs	/^    pub fn derive_shared_secret($/;"	P	implementation:SecureCommunication
description	src/api/handlers/governance_handler.rs	/^    description: String,$/;"	m	struct:ProposalInfo
description	src/api/models/request/governance_request.rs	/^    pub description: String,$/;"	m	struct:SubmitProposalRequest
description	src/api/routes/governance.rs	/^    description: String,$/;"	m	struct:ProposalInfo
description	src/chain/governance/proposal.rs	/^    pub description: String,$/;"	m	struct:Proposal
description_vector	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    description_vector: Vec<f64>,$/;"	m	struct:ProposalAnalysis
deserialize	src/network/node_message.rs	/^    pub fn deserialize(data: &[u8], crypto: &QUPCrypto) -> Result<Self, NodeMessageError> {$/;"	P	implementation:NodeMessage
deserialize	src/network/p2p/message.rs	/^    pub fn deserialize(data: &[u8]) -> Result<Self, bincode::Error> {$/;"	P	implementation:Message
deserialize	src/network/protocol.rs	/^    pub fn deserialize(data: &[u8], crypto: &QUPCrypto) -> Result<Self, ProtocolError> {$/;"	P	implementation:ProtocolMessage
deserialize	src/network/shard_message.rs	/^    pub fn deserialize(data: &[u8], crypto: &QUPCrypto) -> Result<Self, NetworkError> {$/;"	P	implementation:ShardMessage
deserialize_account	src/chain/state/state_db.rs	/^fn deserialize_account(data: &[u8]) -> Option<Account> {$/;"	f
deserialize_vote	src/chain/quantum_voting/utils.rs	/^pub fn deserialize_vote(serialized_vote: &[u8]) -> Result<Vote, VotingError> {$/;"	f
detect_eavesdropping	src/chain/quantum_voting/security_analysis.rs	/^    pub fn detect_eavesdropping($/;"	P	implementation:SecurityAnalysis
detect_errors	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn detect_errors(&self, encoded_data: &[f64]) -> bool {$/;"	P	implementation:QUPErrorCorrection
determine_desired_compression_ratio	src/chain/quantum_voting/compression.rs	/^    fn determine_desired_compression_ratio(&self) -> Result<CompressionRatio, VotingError> {$/;"	P	implementation:Compression
determine_desired_error_correction_rate	src/chain/quantum_voting/error_correction.rs	/^    fn determine_desired_error_correction_rate(&self) -> Result<f64, VotingError> {$/;"	P	implementation:ErrorCorrection
determine_desired_error_correction_rate	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_desired_error_correction_rate(&self) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
determine_distillation_protocol	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn determine_distillation_protocol($/;"	P	implementation:EntanglementDistillation
determine_hardware_compatibility	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_hardware_compatibility(&self) -> Result<Vec<String>, VotingError> {$/;"	P	implementation:QuantumVoting
determine_max_computational_complexity	src/chain/quantum_voting/compression.rs	/^    fn determine_max_computational_complexity($/;"	P	implementation:Compression
determine_max_computational_complexity	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_max_computational_complexity(&self) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumVoting
determine_max_decoding_time	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_max_decoding_time(&self) -> Result<std::time::Duration, VotingError> {$/;"	P	implementation:QuantumVoting
determine_max_qubit_overhead	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_max_qubit_overhead(&self) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumVoting
determine_necessary_transformations	src/chain/quantum_voting/compression.rs	/^    fn determine_necessary_transformations($/;"	P	implementation:Compression
determine_necessary_transformations	src/chain/quantum_voting/quantum_voting.rs	/^    fn determine_necessary_transformations($/;"	P	implementation:QuantumVoting
determine_num_qubits	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn determine_num_qubits(&self, vote: &Vote) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumStatePreparation
determine_num_qubits_candidate	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn determine_num_qubits_candidate(&self, candidate: &Candidate) -> Result<usize, VotingError/;"	P	implementation:QuantumStatePreparation
difficulty	src/api/handlers/blockchain_handler.rs	/^    difficulty: u64,$/;"	m	struct:ChainStatus
difficulty	src/api/models/request/blockchain_request.rs	/^    pub difficulty: u64,$/;"	m	struct:BlockHeader
difficulty	src/api/models/response/blockchain_response.rs	/^    pub difficulty: u64,$/;"	m	struct:BlockHeader
difficulty	src/api/models/response/blockchain_response.rs	/^    pub difficulty: u64,$/;"	m	struct:GetChainInfoResponse
difficulty	src/api/routes/blockchain.rs	/^    difficulty: u64,$/;"	m	struct:ChainStatus
difficulty	src/chain/block.rs	/^    pub difficulty: u64,$/;"	m	struct:Block
difficulty	src/qup/types.rs	/^    pub difficulty: u64,$/;"	m	struct:QUPBlockHeader
difficulty_adjustment_interval	src/api/routes/consensus.rs	/^    difficulty_adjustment_interval: u64,$/;"	m	struct:PoUWParameters
digital_signature	src/chain/quantum_voting/quantum_cryptography.rs	/^    digital_signature: QuantumDigitalSignature,$/;"	m	struct:QuantumCryptography
dilithium	src/chain/quantum_entropy.rs	/^    dilithium: Arc<Dilithium>,$/;"	m	struct:QuantumEntropySource
dilithium_signature	src/qup/crypto.rs	/^    pub dilithium_signature: DilithiumSignature,$/;"	m	struct:QUPSignature
dimension	src/hdcmodels/hdcmodels.rs	/^    dimension: usize,$/;"	m	struct:HDCModel
dimension	src/hdcmodels/mod.rs	/^    dimension: usize,$/;"	m	struct:HDCModel
discover_neighbors	src/network/network_manager.rs	/^    async fn discover_neighbors(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
discover_peer	src/network/discovery.rs	/^    async fn discover_peer(&mut self, peer_id: PeerId) {$/;"	P	implementation:Discovery
discover_peers	src/network/discovery.rs	/^    async fn discover_peers(&mut self) -> Result<(), NetworkError> {$/;"	P	implementation:Discovery
discovery	src/network/lib.rs	/^    pub discovery: Discovery,$/;"	m	struct:Network
discovery	src/network/lib.rs	/^pub mod discovery;$/;"	n
discovery	src/network/mod.rs	/^mod discovery;$/;"	n
dispute	src/chain/state_channel.rs	/^    pub dispute: Option<Dispute>,$/;"	m	struct:StateChannelOptimized
disputed_transaction	src/chain/state_channel.rs	/^    pub disputed_transaction: OffChainTransaction,$/;"	m	struct:Dispute
distillation_protocol	src/chain/quantum_voting/entanglement_distillation.rs	/^    distillation_protocol: EntanglementDistillationProtocol,$/;"	m	struct:EntanglementDistillation
distribute_candidate_keys	src/chain/quantum_voting/quantum_key_distribution.rs	/^    pub fn distribute_candidate_keys($/;"	P	implementation:QuantumKeyDistribution
distribute_delegator_rewards	src/qup/reward.rs	/^    fn distribute_delegator_rewards($/;"	P	implementation:RewardDistributor
distribute_entangled_state	src/network/quantum_resistant.rs	/^    async fn distribute_entangled_state($/;"	P	implementation:QuantumResistantConnection
distribute_entangled_state	src/network/quantum_resistant.rs	/^    async fn distribute_entangled_state($/;"	P	interface:QuantumResistantConnectionManager
distribute_entangled_state	src/network/quantum_resistant.rs	/^    pub async fn distribute_entangled_state($/;"	P	implementation:QuantumResistantConnection
distribute_quantum_state	src/network/network_manager.rs	/^    pub async fn distribute_quantum_state(&self, state: QuantumState) -> Result<()> {$/;"	P	implementation:NetworkManager
distribute_quantum_states	src/chain/quantum_voting/quantum_key_management.rs	/^    pub fn distribute_quantum_states($/;"	P	implementation:QuantumKeyManagement
distribute_rewards	src/chain/governance/governance_engine.rs	/^    pub async fn distribute_rewards(&mut self) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
distribute_rewards	src/chain/governance/rewards.rs	/^    pub async fn distribute_rewards($/;"	P	implementation:Rewards
distribute_rewards	src/chain/governance/staking.rs	/^    pub async fn distribute_rewards($/;"	P	implementation:Staking
distribute_rewards	src/qup/consensus.rs	/^    fn distribute_rewards(&mut self, block: &QUPBlock) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
distribute_rewards	src/qup/reward.rs	/^    pub fn distribute_rewards(&self, state: &mut State, block_header: &QUPBlockHeader) {$/;"	P	implementation:RewardDistributor
distribute_training_data	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn distribute_training_data(&mut self, dataset: Dataset) {$/;"	P	implementation:DistributedTrainingAggregator
distribute_transaction	src/chain/sharding.rs	/^    pub async fn distribute_transaction(&self, transaction: Transaction) {$/;"	P	implementation:Sharding
distribute_validator_reward	src/qup/reward.rs	/^    fn distribute_validator_reward($/;"	P	implementation:RewardDistributor
distribute_voter_keys	src/chain/quantum_voting/quantum_key_distribution.rs	/^    pub fn distribute_voter_keys($/;"	P	implementation:QuantumKeyDistribution
efficiency	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub efficiency: f64,$/;"	m	struct:HDCBenchmarkResult
efficiency	src/hdcmodels/benchmarking/reporting.rs	/^    pub efficiency: f64,$/;"	m	struct:BenchmarkReport
efficiency	src/hdcmodels/hdcmodels.rs	/^    efficiency: f64,$/;"	m	struct:HDCModel
email	src/api/middleware/request_validator.rs	/^    email: String,$/;"	m	struct:RequestModel
encode	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn encode(&self, data: &[f64]) -> Vec<f64> {$/;"	P	implementation:QUPErrorCorrection
encode_block	src/qup/hdcomm.rs	/^    pub fn encode_block(&self, block: &QUPBlock) -> Vec<f64> {$/;"	P	implementation:HDCommunication
encode_candidate	src/chain/quantum_voting/quantum_state_encoding.rs	/^    pub fn encode_candidate(&self, candidate: &Candidate) -> Result<QuantumRegister, VotingError/;"	P	implementation:QuantumStateEncoding
encode_candidate	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn encode_candidate($/;"	P	implementation:QuantumStatePreparation
encode_candidate_data	src/chain/quantum_voting/quantum_state_encoding.rs	/^    fn encode_candidate_data($/;"	P	implementation:QuantumStateEncoding
encode_consensus_message	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn encode_consensus_message(&self, message: &ConsensusMessage) -> Vec<f64> {$/;"	P	implementation:ConsensusSecurityMonitor
encode_consensus_state	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn encode_consensus_state(&self, state: &ConsensusState) -> Vec<f64> {$/;"	P	implementation:ConsensusSecurityMonitor
encode_data_batch	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^    fn encode_data_batch(&self, data: &[Vec<f64>]) -> Array2<f64> {$/;"	P	implementation:OptimizedHDCModel
encode_data_batch	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^fn encode_data_batch(data: &[Vec<f64>], dimension: usize) -> Array2<f64> {$/;"	f
encode_data_gpu	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    fn encode_data_gpu(&self, data: &[Vec<f64>]) -> Array<f64> {$/;"	P	implementation:GPUHDCModel
encode_knapsack_problem	src/qup/hdcomm.rs	/^fn encode_knapsack_problem(problem: &KnapsackProblem) -> Vec<f64> {$/;"	f
encode_natural_language	src/hdcmodels/encoding.rs	/^pub fn encode_natural_language(text: &str, dimension: usize) -> Vec<f64> {$/;"	f
encode_natural_language	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn encode_natural_language(&self, text: &str, dimension: usize) -> Vec<f64> {$/;"	P	implementation:QUPEncoding
encode_proposal_code	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    fn encode_proposal_code(&self, code: &str) -> Vec<f64> {$/;"	P	implementation:ProposalAnalyzer
encode_proposal_description	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    fn encode_proposal_description(&self, description: &str) -> Vec<f64> {$/;"	P	implementation:ProposalAnalyzer
encode_quantum_state	src/chain/quantum_voting/quantum_voting.rs	/^    fn encode_quantum_state($/;"	P	implementation:QuantumVoting
encode_rust_code	src/hdcmodels/encoding.rs	/^pub fn encode_rust_code(code: &str, dimension: usize) -> Vec<f64> {$/;"	f
encode_rust_code	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn encode_rust_code(&self, code: &str, dimension: usize) -> Vec<f64> {$/;"	P	implementation:QUPEncoding
encode_smart_contract	src/hdcmodels/encoding.rs	/^pub fn encode_smart_contract(contract: &str, dimension: usize, n: usize) -> Vec<f64> {$/;"	f
encode_smart_contract	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn encode_smart_contract(&self, contract: &str, dimension: usize, n: usize) -> Vec<f64> /;"	P	implementation:QUPEncoding
encode_smart_contract	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    pub fn encode_smart_contract(&self, smart_contract: &str) -> Vec<f64> {$/;"	P	implementation:SmartContractSpecEncoder
encode_specification	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    pub fn encode_specification(&self, specification: &str) -> Vec<f64> {$/;"	P	implementation:SmartContractSpecEncoder
encode_state_transition	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub fn encode_state_transition(&self, state_transition: &StateTransition) -> Vec<f64> {$/;"	P	implementation:TransactionEncoder
encode_state_with_error_correction	src/chain/quantum_voting/error_correction.rs	/^    fn encode_state_with_error_correction($/;"	P	implementation:ErrorCorrection
encode_state_with_error_correction	src/chain/quantum_voting/quantum_voting.rs	/^    fn encode_state_with_error_correction($/;"	P	implementation:QuantumVoting
encode_transaction	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub fn encode_transaction(&self, transaction: &Transaction) -> Vec<f64> {$/;"	P	implementation:TransactionEncoder
encode_transaction	src/qup/hdcomm.rs	/^    fn encode_transaction(&self, tx: &Transaction) -> Vec<f64> {$/;"	P	implementation:HDCommunication
encode_transactional_data	src/hdcmodels/encoding.rs	/^pub fn encode_transactional_data(data: &[Transaction], dimension: usize) -> Vec<f64> {$/;"	f
encode_transactional_data	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn encode_transactional_data(&self, data: &[Transaction], dimension: usize) -> Vec<f64> /;"	P	implementation:QUPEncoding
encode_useful_work	src/qup/hdcomm.rs	/^    fn encode_useful_work(&self, useful_work: &UsefulWork) -> Vec<f64> {$/;"	P	implementation:HDCommunication
encode_vertex_cover_problem	src/qup/hdcomm.rs	/^fn encode_vertex_cover_problem(problem: &VertexCoverProblem) -> Vec<f64> {$/;"	f
encode_vote	src/chain/quantum_voting/quantum_state_encoding.rs	/^    pub fn encode_vote(&self, vote: &Vote) -> Result<QuantumRegister, VotingError> {$/;"	P	implementation:QuantumStateEncoding
encode_vote	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn encode_vote($/;"	P	implementation:QuantumStatePreparation
encode_vote_data	src/chain/quantum_voting/quantum_state_encoding.rs	/^    fn encode_vote_data($/;"	P	implementation:QuantumStateEncoding
encoder	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    encoder: TransactionEncoder,$/;"	m	struct:TransactionOptimizer
encoding	src/hdcmodels/mod.rs	/^pub mod encoding;$/;"	n
encrypt	src/crypto/post_quantum.rs	/^    pub fn encrypt(&self, message: &[u8]) -> Result<Vec<u8>, PostQuantumError> {$/;"	P	implementation:KyberKeypair
encrypt	src/crypto/post_quantum.rs	/^    pub fn encrypt(&self, message: &[u8]) -> Result<Vec<u8>, PostQuantumError> {$/;"	P	implementation:KyberPublicKey
encrypt	src/qup/crypto.rs	/^    fn encrypt(&self, message: &[u8], public_key: &Self::PublicKey) -> Vec<u8> {$/;"	P	implementation:QUPCrypto
encrypt	src/qup/crypto.rs	/^    pub fn encrypt(&self, message: &[u8], public_key: &KyberPublicKey) -> Vec<u8> {$/;"	P	implementation:QUPCrypto
encrypt	src/secure_core/secure_storage.rs	/^    pub fn encrypt<T: Serialize>(&self, data: &T, key: &[u8; 32]) -> Result<EncryptedData, Secur/;"	P	implementation:SecureStorage
encrypt_aes_256_gcm	src/utils/encryption.rs	/^pub fn encrypt_aes_256_gcm($/;"	f
encrypt_and_compress_transaction	src/chain/shard.rs	/^    fn encrypt_and_compress_transaction(&self, transaction: Transaction, secure_vault: &SecureVa/;"	P	implementation:Shard
encrypt_chacha20_poly1305	src/utils/encryption.rs	/^pub fn encrypt_chacha20_poly1305($/;"	f
encrypt_details	src/chain/transaction.rs	/^    pub fn encrypt_details(&mut self, key: &[u8]) -> Result<(), TransactionError> {$/;"	P	implementation:Transaction
encrypt_message	src/secure_core/secure_communication.rs	/^    pub fn encrypt_message($/;"	P	implementation:SecureCommunication
encrypt_vote	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn encrypt_vote($/;"	P	implementation:QuantumCryptography
encrypt_with_master_key	src/secure_core/secure_vault.rs	/^    fn encrypt_with_master_key(&self, data: &[u8]) -> Result<Vec<u8>, AesGcmError> {$/;"	P	implementation:SecureVault
encrypted_details	src/chain/transaction.rs	/^    pub encrypted_details: Vec<u8>,$/;"	m	struct:Transaction
encryption	src/chain/quantum_voting/quantum_cryptography.rs	/^    encryption: QuantumEncryption,$/;"	m	struct:QuantumCryptography
encryption	src/utils/mod.rs	/^pub(crate) mod encryption;$/;"	n
encryption_key	src/chain/shard.rs	/^    encryption_key: Arc<RwLock<EncryptionKey>>,$/;"	m	struct:Shard
encryption_key_pair	src/qup/crypto.rs	/^    pub encryption_key_pair: KyberKeyPair,$/;"	m	struct:QUPKeyPair
end_block	src/api/models/request/blockchain_request.rs	/^    pub end_block: Option<u64>,$/;"	m	struct:GetTransactionsRequest
end_block	src/api/models/request/transaction_request.rs	/^    pub end_block: Option<u64>,$/;"	m	struct:GetTransactionsRequest
end_time	src/api/models/request/governance_request.rs	/^    pub end_time: Option<u64>,$/;"	m	struct:GetProposalsRequest
end_time	src/chain/governance/proposal.rs	/^    pub end_time: Timestamp,$/;"	m	struct:Proposal
enforce	src/zkp/constraint_system.rs	/^    pub fn enforce(&self, cs: &mut impl ConstraintSystem) {$/;"	P	implementation:EqualsConstraint
enforce	src/zkp/constraint_system.rs	/^    pub fn enforce(&self, cs: &mut impl ConstraintSystem) {$/;"	P	implementation:RangeConstraint
enforce_constraint	src/zkp/constraint_system.rs	/^    fn enforce_constraint(&mut self, lhs: Expression, rhs: Expression) {$/;"	P	implementation:ConstraintSystemImpl
enforce_constraint	src/zkp/constraint_system.rs	/^    fn enforce_constraint(&mut self, lhs: Expression, rhs: Expression);$/;"	P	interface:ConstraintSystem
entries	src/optimization_problems/hdc_code_generation/dataset.rs	/^    entries: Vec<StackEntry>,$/;"	m	struct:CodeDataset
epoch_length	src/api/handlers/qup_handler.rs	/^    epoch_length: u64,$/;"	m	struct:QUPParameters
epoch_length	src/api/models/request/qup_request.rs	/^    pub epoch_length: u64,$/;"	m	struct:QUPParameters
epoch_length	src/api/models/response/qup_response.rs	/^    pub epoch_length: u64,$/;"	m	struct:QUPParameters
epoch_length	src/api/routes/consensus.rs	/^    epoch_length: u64,$/;"	m	struct:QDPoSParameters
error	src/error_handling/mod.rs	/^mod error;$/;"	n
error	src/network/lib.rs	/^pub mod error;$/;"	n
error	src/network/mod.rs	/^mod error;$/;"	n
error	src/qup/lib.rs	/^pub mod error;$/;"	n
error_correction	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    error_correction: QuantumErrorCorrection,$/;"	m	struct:QUPErrorCorrection
error_handling	src/main.rs	/^mod error_handling;$/;"	n
error_reporter	src/error_handling/mod.rs	/^mod error_reporter;$/;"	n
error_utils	src/error_handling/mod.rs	/^mod error_utils;$/;"	n
errors	src/api/middleware/request_validator.rs	/^    errors: Vec<String>,$/;"	m	struct:ValidationErrorResponse
establish	src/network/quantum_resistant.rs	/^    async fn establish(&mut self, node_id: &str) -> Result<(PublicKey, SecretKey), NetworkError>/;"	P	implementation:QuantumResistantConnection
establish	src/network/quantum_resistant.rs	/^    async fn establish(&mut self, node_id: &str) -> Result<(PublicKey, SecretKey), NetworkError>/;"	P	interface:QuantumResistantConnectionManager
establish	src/network/quantum_resistant.rs	/^    pub async fn establish($/;"	P	implementation:QuantumResistantConnection
establish_connection	src/chain/quantum_entropy.rs	/^    pub async fn establish_connection(&self, node_id: &str) -> Result<Keypair, QuantumEntropyErr/;"	P	implementation:QuantumResistantConnectionManager
establish_quantum_channel	src/chain/quantum_voting/quantum_communication.rs	/^    pub fn establish_quantum_channel($/;"	P	implementation:QuantumCommunication
establish_quantum_channel	src/chain/quantum_voting/quantum_state_transmission.rs	/^    fn establish_quantum_channel($/;"	P	implementation:QuantumStateTransmission
establish_quantum_channel	src/chain/quantum_voting/vote_collection.rs	/^    fn establish_quantum_channel($/;"	P	implementation:VoteCollection
establish_quantum_channel	src/network/discovery.rs	/^    async fn establish_quantum_channel(&mut self, peer_id: &PeerId) -> Result<(), NetworkError> /;"	P	implementation:Discovery
establish_quantum_resistant_connection	src/chain/quantum_entropy.rs	/^pub async fn establish_quantum_resistant_connection($/;"	f
evaluate	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub fn evaluate(&self, model: &CodeGenerationModel) -> Result<EvaluationResult, String> {$/;"	P	implementation:Evaluator
evaluate	src/zkp/constraint_system.rs	/^    fn evaluate(&self, expression: &Expression) -> FieldElement {$/;"	P	implementation:ConstraintSystemImpl
evaluate	src/zkp/constraint_system.rs	/^    fn evaluate(&self, expression: &Expression) -> FieldElement;$/;"	P	interface:ConstraintSystem
evaluate	src/zkp/math.rs	/^    pub fn evaluate(&self, point: &FieldElement) -> FieldElement {$/;"	P	implementation:PolynomialCommitment
evaluate_accuracy	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^fn evaluate_accuracy(model: &HDCModel, data: &[Vec<f64>], labels: &[String]) -> f64 {$/;"	f
evaluate_expression	src/smart_contract/interpreter.rs	/^    fn evaluate_expression($/;"	P	implementation:Interpreter
evaluate_transition_constraints	src/zephyrchain_circuit.rs	/^    fn evaluate_transition_constraints<E: FieldElement<BaseField = Self::BaseField>>($/;"	P	implementation:ZephyrChainCircuit
evaluate_vote_integrity	src/chain/quantum_voting/security_analysis.rs	/^    pub fn evaluate_vote_integrity(&self, vote_state: &QuantumState) -> Result<bool, VotingError/;"	P	implementation:SecurityAnalysis
evaluations	src/zkp/zk_starks.rs	/^    pub evaluations: Vec<FieldElement>,$/;"	m	struct:ZkStarksProof
evaluator	src/optimization_problems/hdc_code_generation/mod.rs	/^mod evaluator;/;"	n
execute	src/chain/governance/proposal.rs	/^    pub async fn execute($/;"	P	implementation:Proposal
execute_contract	src/smart_contract/lib.rs	/^pub fn execute_contract(contract: &SmartContract, gas_limit: u64) -> Result<HashMap<String, Valu/;"	f
execute_operation	src/smart_contract/interpreter.rs	/^    pub fn execute_operation($/;"	P	implementation:Interpreter
execute_operations	src/smart_contract/interpreter.rs	/^    fn execute_operations($/;"	P	implementation:Interpreter
execute_proposal	src/chain/governance/governance_engine.rs	/^    pub async fn execute_proposal(&self, proposal_id: u64) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
execute_smart_contracts	src/chain/block.rs	/^    fn execute_smart_contracts($/;"	P	implementation:Block
execution_context	src/smart_contract/lib.rs	/^pub mod execution_context;$/;"	n
execution_context	src/smart_contract/mod.rs	/^mod execution_context;$/;"	n
execution_time	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub execution_time: std::time::Duration,$/;"	m	struct:HDCBenchmarkResult
execution_time	src/hdcmodels/benchmarking/reporting.rs	/^    pub execution_time: f64,$/;"	m	struct:BenchmarkReport
exists	src/chain/storage/snapshot.rs	/^    pub fn exists(path: &Path) -> bool {$/;"	P	implementation:Snapshot
exp	src/api/middleware/authentication.rs	/^    exp: usize,$/;"	m	struct:Claims
exp	src/api/middleware/authentication.rs	/^    exp: usize,$/;"	m	struct:RefreshTokenClaims
fft	src/utils/mod.rs	/^mod fft;$/;"	n
field1	src/hdcmodels/distributed_training/load_balancing.rs	/^    field1: String,$/;"	m	struct:MyDataType
field2	src/hdcmodels/distributed_training/load_balancing.rs	/^    field2: Vec<f64>,$/;"	m	struct:MyDataType
field3	src/hdcmodels/distributed_training/load_balancing.rs	/^    field3: HDCModel,$/;"	m	struct:MyDataType
field_size	src/zkp/zk_starks.rs	/^    pub field_size: FieldElement,$/;"	m	struct:ZkStarksVerifier
filter_codes_by_properties	src/chain/quantum_voting/quantum_voting.rs	/^    fn filter_codes_by_properties($/;"	P	implementation:QuantumVoting
filter_schemes_by_criteria	src/chain/quantum_voting/compression.rs	/^    fn filter_schemes_by_criteria($/;"	P	implementation:Compression
final_poly_merkle_root	src/zkp/zk_starks.rs	/^    pub final_poly_merkle_root: FieldElement,$/;"	m	struct:FriProof
finalize	src/qup/crypto.rs	/^    fn finalize(self) -> Hash {$/;"	P	implementation:QUPCrypto
finalize	src/zkp/crypto.rs	/^    fn finalize(self) -> FieldElement {$/;"	P	implementation:Blake3bHasher
finalize	src/zkp/crypto.rs	/^    fn finalize(self) -> FieldElement;$/;"	P	interface:Hasher
finalize_block	src/qup/state.rs	/^    pub fn finalize_block(&mut self, block: &QUPBlock) -> Result<(), Error> {$/;"	P	implementation:QUPState
find_similar_contracts	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    pub fn find_similar_contracts($/;"	P	implementation:SmartContractSpecEncoder
find_similar_state_transitions	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub fn find_similar_state_transitions($/;"	P	implementation:TransactionEncoder
find_similar_transactions	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub fn find_similar_transactions($/;"	P	implementation:TransactionEncoder
fine_tune	src/hdcmodels/model_integration/transfer_learning.rs	/^    pub fn fine_tune($/;"	P	implementation:TransferLearningModel
fmt	src/crypto/post_quantum.rs	/^    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {$/;"	P	implementation:DilithiumKeypair
fmt	src/crypto/post_quantum.rs	/^    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {$/;"	P	implementation:KyberKeypair
fmt	src/network/error.rs	/^    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {$/;"	P	implementation:NetworkError
fmt	src/qup/error.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	P	implementation:QUPError
fmt	src/qup/error.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	P	implementation:UsefulWorkError
fmt	src/types/address.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {$/;"	P	implementation:Address
fmt	src/utils/node_id.rs	/^    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {$/;"	P	implementation:NodeId
forward_transaction	src/chain/sharding.rs	/^    async fn forward_transaction(&self, encrypted_transaction: Vec<u8>, shard_id: u64) {$/;"	P	implementation:Sharding
fri	src/zkp/mod.rs	/^mod fri;$/;"	n
fri_proof	src/zkp/zk_starks.rs	/^    pub fri_proof: FriProof,$/;"	m	struct:ZkStarksProof
from	src/api/middleware/authentication.rs	/^    fn from(role: &str) -> Self {$/;"	P	implementation:Role
from	src/api/middleware/request_validator.rs	/^    fn from(validation_error: ValidationError) -> Self {$/;"	P	implementation:String
from	src/chain/quantum_voting/error.rs	/^    fn from(_: QuantumCompressionError) -> Self {$/;"	P	implementation:VotingError
from	src/chain/quantum_voting/error.rs	/^    fn from(_: QuantumHardwareError) -> Self {$/;"	P	implementation:VotingError
from	src/chain/quantum_voting/error.rs	/^    fn from(_: QuantumNoiseSimulationError) -> Self {$/;"	P	implementation:VotingError
from	src/crypto/hash.rs	/^    fn from(bytes: Vec<u8>) -> Self {$/;"	P	implementation:ShardingHash
from	src/hdcmodels/benchmarking/reporting.rs	/^    fn from(result: &HDCBenchmarkResult) -> Self {$/;"	P	implementation:BenchmarkReport
from	src/network/error.rs	/^    fn from(err: libp2p::core::transport::TransportError) -> Self {$/;"	P	implementation:NetworkError
from	src/network/error.rs	/^    fn from(err: libp2p::core::upgrade::ProtocolError) -> Self {$/;"	P	implementation:NetworkError
from	src/network/error.rs	/^    fn from(err: libp2p::identity::error::SigningError) -> Self {$/;"	P	implementation:NetworkError
from	src/network/error.rs	/^    fn from(err: libp2p::kad::KademliaError) -> Self {$/;"	P	implementation:NetworkError
from	src/network/error.rs	/^    fn from(err: serde_json::Error) -> Self {$/;"	P	implementation:NetworkError
from	src/network/error.rs	/^    fn from(err: std::io::Error) -> Self {$/;"	P	implementation:NetworkError
from	src/network/p2p/peer.rs	/^    fn from(error: tls::TLSError) -> Self {$/;"	P	implementation:PeerError
from	src/qup/types.rs	/^    pub from: Vec<u8>,$/;"	m	struct:QUPTransaction
from_block	src/api/handlers/blockchain_handler.rs	/^    fn from_block(block: &Block) -> Self {$/;"	P	implementation:BlockInfo
from_bytes	src/crypto/post_quantum.rs	/^    pub fn from_bytes(bytes: &[u8]) -> Result<Self, PostQuantumError> {$/;"	P	implementation:DilithiumPublicKey
from_bytes	src/crypto/post_quantum.rs	/^    pub fn from_bytes(bytes: &[u8]) -> Result<Self, PostQuantumError> {$/;"	P	implementation:KyberPublicKey
from_bytes	src/optimization_problems/problem_solution.rs	/^    pub fn from_bytes(bytes: &[u8]) -> Result<Self, bincode::Error> {$/;"	P	implementation:ProblemSolution
from_file	src/quantum_entropy/config.rs	/^    pub fn from_file(file_path: &str) -> Result<Self, ConfigError> {$/;"	P	implementation:QRNGConfig
from_hex	src/types/address.rs	/^    pub fn from_hex(hex: &str) -> Result<Self, AddressError> {$/;"	P	implementation:Address
from_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    fn from_model(model: Vec<Vec<f64>>) -> Self {$/;"	P	implementation:HDCModel
from_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    fn from_model(model: Vec<Vec<f64>>) -> Self;$/;"	P	interface:HDCModelExt
from_peer	src/api/handlers/network_handler.rs	/^    fn from_peer(peer: &Peer) -> Self {$/;"	P	implementation:PeerInfo
from_proposal	src/api/handlers/governance_handler.rs	/^    fn from_proposal(proposal: &Proposal) -> Self {$/;"	P	implementation:ProposalInfo
from_request	src/api/middleware/authentication.rs	/^    fn from_request(req: &ServiceRequest, _: &mut actix_web::dev::Payload) -> Self::Future {$/;"	P	implementation:AuthenticatedUser
from_str	src/utils/node_id.rs	/^    fn from_str(s: &str) -> Result<Self, Self::Err> {$/;"	P	implementation:NodeId
from_str	src/utils/node_id.rs	/^    pub fn from_str(id: &str) -> Result<Self, NodeIdError> {$/;"	P	implementation:NodeId
from_transaction	src/api/handlers/blockchain_handler.rs	/^    fn from_transaction($/;"	P	implementation:TransactionInfo
from_transaction	src/api/handlers/transaction_handler.rs	/^    fn from_transaction(tx: &Transaction) -> Self {$/;"	P	implementation:TransactionInfo
from_validator	src/api/handlers/qup_handler.rs	/^    fn from_validator(validator: &QUPValidator) -> Self {$/;"	P	implementation:ValidatorInfo
from_vec	src/hdcmodels/parallel_processing.rs	/^    fn from_vec(data: Vec<DataItem>) -> Self {$/;"	P	implementation:Dataset
from_vec	src/hdcmodels/parallel_processing.rs	/^    fn from_vec(data: Vec<DataItem>) -> Self;$/;"	P	interface:DatasetExt
from_vote	src/api/handlers/governance_handler.rs	/^    fn from_vote(vote: &Vote) -> Self {$/;"	P	implementation:VoteInfo
func_call_cost	src/smart_contract/gas.rs	/^    pub func_call_cost: u64,$/;"	m	struct:GasCost
function_args	src/api/models/request/smart_contract_request.rs	/^    pub function_args: Vec<String>,$/;"	m	struct:CallContractRequest
function_name	src/api/models/request/smart_contract_request.rs	/^    pub function_name: String,$/;"	m	struct:CallContractRequest
gadgets	src/zkp/mod.rs	/^mod gadgets;$/;"	n
gas	src/smart_contract/lib.rs	/^pub mod gas;$/;"	n
gas	src/smart_contract/mod.rs	/^mod gas;$/;"	n
gas_cost	src/smart_contract/interpreter.rs	/^    pub gas_cost: GasCost,$/;"	m	struct:Interpreter
gas_limit	src/smart_contract/execution_context.rs	/^    pub gas_limit: u64,$/;"	m	struct:ExecutionContext
gas_limit	src/smart_contract/types.rs	/^    pub gas_limit: u64,$/;"	m	struct:SmartContract
gas_used	src/smart_contract/execution_context.rs	/^    pub gas_used: u64,$/;"	m	struct:ExecutionContext
generalizability	src/hdcmodels/hdcmodels.rs	/^    generalizability: f64,$/;"	m	struct:HDCModel
generate	src/crypto/post_quantum.rs	/^    pub fn generate() -> Result<Self, PostQuantumError> {$/;"	P	implementation:DilithiumKeypair
generate	src/crypto/post_quantum.rs	/^    pub fn generate() -> Result<Self, PostQuantumError> {$/;"	P	implementation:DilithiumSecretKey
generate	src/crypto/post_quantum.rs	/^    pub fn generate() -> Result<Self, PostQuantumError> {$/;"	P	implementation:KyberKeypair
generate	src/crypto/post_quantum.rs	/^    pub fn generate() -> Result<Self, PostQuantumError> {$/;"	P	implementation:KyberSecretKey
generate	src/qup/hdcomm.rs	/^    pub fn generate(state: &QUPState) -> Self {$/;"	P	implementation:UsefulWorkProblem
generate	src/zephyrchain_circuit.rs	/^    fn generate(&self) -> Result<TraceTable<BaseElement>, StarkError> {$/;"	P	implementation:ZephyrChainCircuit
generate_accuracy_report	src/hdcmodels/benchmarking/analysis.rs	/^    fn generate_accuracy_report(&self, aggregated_data: &HashMap<String, HDCBenchmarkResult>) {$/;"	P	implementation:BenchmarkAnalyzer
generate_certificate	src/chain/certificate_authority.rs	/^    pub async fn generate_certificate($/;"	P	implementation:CertificateAuthority
generate_efficiency_report	src/hdcmodels/benchmarking/analysis.rs	/^    fn generate_efficiency_report(&self, aggregated_data: &HashMap<String, HDCBenchmarkResult>) /;"	P	implementation:BenchmarkAnalyzer
generate_entangled_state	src/crypto/quantum_state.rs	/^    pub fn generate_entangled_state(&mut self) -> Result<()> {$/;"	P	implementation:TimeBinState
generate_key	src/utils/encryption.rs	/^pub fn generate_key() -> Result<EncryptionKey, EncryptionError> {$/;"	f
generate_key_pair	src/qup/crypto.rs	/^    pub fn generate_key_pair(&self) -> QUPKeyPair {$/;"	P	implementation:QUPCrypto
generate_key_pair	src/secure_core/secure_communication.rs	/^    pub fn generate_key_pair(&self) -> Result<(RistrettoPoint, Scalar), SecureCommunicationError/;"	P	implementation:SecureCommunication
generate_key_pair	src/secure_core/secure_vault.rs	/^    pub fn generate_key_pair(&mut self) -> Result<(PublicKey, PrivateKey, PostQuantumKeyPair), S/;"	P	implementation:SecureVault
generate_keypair	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn generate_keypair(&self) -> Result<(PublicKey, SigningKey), QuantumResistantSignatureE/;"	P	implementation:QuantumResistantSigner
generate_nonce	src/secure_core/secure_communication.rs	/^    fn generate_nonce(&self) -> Nonce {$/;"	P	implementation:SecureCommunication
generate_nonce	src/secure_core/secure_storage.rs	/^    fn generate_nonce(&self) -> Nonce {$/;"	P	implementation:SecureStorage
generate_performance_report	src/hdcmodels/benchmarking/analysis.rs	/^    fn generate_performance_report(&self, aggregated_data: &HashMap<String, HDCBenchmarkResult>)/;"	P	implementation:BenchmarkAnalyzer
generate_post_quantum_certificate_signing_request	src/chain/node.rs	/^    pub async fn generate_post_quantum_certificate_signing_request($/;"	P	implementation:Node
generate_post_quantum_keypair	src/chain/node.rs	/^    pub async fn generate_post_quantum_keypair(&self) -> Result<(), NodeError> {$/;"	P	implementation:Node
generate_post_quantum_keypair	src/chain/quantum_entropy.rs	/^    pub fn generate_post_quantum_keypair(&self) -> Result<Keypair, QuantumEntropyError> {$/;"	P	implementation:QuantumEntropySource
generate_proof	src/chain/state/merkle_trie.rs	/^    pub fn generate_proof(&self, key: &[u8]) -> Option<Vec<Vec<u8>>> {$/;"	P	implementation:MerkleTrie
generate_proof	src/utils/merkle_tree.rs	/^    pub fn generate_proof(&self, transaction: &QUPTransaction) -> Option<Vec<Hash>> {$/;"	P	implementation:MerkleTree
generate_proof_for_index	src/utils/merkle_tree.rs	/^    fn generate_proof_for_index(index: usize, leaves: &[Hash]) -> Vec<Hash> {$/;"	P	implementation:MerkleTree
generate_proof_recursive	src/chain/state/merkle_trie.rs	/^    fn generate_proof_recursive($/;"	P	implementation:MerkleTrie
generate_quantum_keys	src/chain/quantum_voting/quantum_key_distribution.rs	/^    pub fn generate_quantum_keys($/;"	P	implementation:QuantumKeyDistribution
generate_quantum_keys	src/chain/quantum_voting/quantum_key_management.rs	/^    pub fn generate_quantum_keys(&self) -> Result<HashMap<String, QuantumKey>, VotingError> {$/;"	P	implementation:QuantumKeyManagement
generate_random_bytes	src/quantum_entropy/qrng.rs	/^    pub fn generate_random_bytes(&self, num_bytes: usize) -> Result<Vec<u8>, QRNGError> {$/;"	P	implementation:QuantumEntropy
generate_random_knapsack_problem	src/qup/utils.rs	/^pub fn generate_random_knapsack_problem() -> KnapsackProblem {$/;"	f
generate_random_useful_work_problem	src/qup/utils.rs	/^pub fn generate_random_useful_work_problem() -> UsefulWorkProblem {$/;"	f
generate_random_vertex_cover_problem	src/qup/utils.rs	/^pub fn generate_random_vertex_cover_problem() -> VertexCoverProblem {$/;"	f
generate_refresh_token	src/api/middleware/authentication.rs	/^fn generate_refresh_token(user_id: &str) -> String {$/;"	f
generate_report	src/hdcmodels/benchmarking/reporting.rs	/^    pub async fn generate_report(&self) -> HashMap<String, BenchmarkReport> {$/;"	P	implementation:BenchmarkReporter
generate_rust_code	src/hdcmodels/hdcmodels.rs	/^    pub fn generate_rust_code($/;"	P	implementation:HDCModel
generate_rust_code	src/hdcmodels/mod.rs	/^    pub fn generate_rust_code(&self, natural_language_query: &str, trained_model: &[Vec<f64>]) -/;"	P	implementation:HDCModel
generate_rust_code	src/hdcmodels/model_integration/hybrid_models.rs	/^    pub fn generate_rust_code(&self, natural_language_query: &str) -> String {$/;"	P	implementation:HybridModel
generate_rust_code	src/hdcmodels/model_integration/transfer_learning.rs	/^    pub fn generate_rust_code(&self, natural_language_query: &str) -> String {$/;"	P	implementation:TransferLearningModel
generate_salt	src/secure_core/security_utils.rs	/^    pub fn generate_salt(length: usize) -> Vec<u8> {$/;"	P	implementation:SecurityUtils
generate_secure_random_bytes	src/secure_core/security_utils.rs	/^    pub fn generate_secure_random_bytes(length: usize) -> Vec<u8> {$/;"	P	implementation:SecurityUtils
generate_seed	src/quantum_entropy/qrng.rs	/^    pub fn generate_seed(&self, seed_len: usize) -> Result<Vec<u8>, QRNGError> {$/;"	P	implementation:QuantumEntropy
generate_smart_contract	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    pub fn generate_smart_contract($/;"	P	implementation:SmartContractGenerator
generate_smart_contract	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    pub fn generate_smart_contract($/;"	P	implementation:SmartContractSpecEncoder
generate_sp_key	src/secure_core/secure_vault.rs	/^    pub fn generate_sp_key(&self, user_ids: Vec<String>) -> Result<String, rand::Error> {$/;"	P	implementation:SecureVault
generate_state_proof	src/chain/state/state_db.rs	/^    pub fn generate_state_proof(&self, address: &str) -> Option<Vec<Vec<u8>>> {$/;"	P	implementation:StateDB
generate_state_proof	src/chain/state/state_manager.rs	/^    pub fn generate_state_proof(&self, address: &str) -> Option<Vec<Vec<u8>>> {$/;"	P	implementation:StateManager
generate_stealth_address	src/chain/wallet.rs	/^    pub fn generate_stealth_address(&self, view_key: &[u8]) -> Result<StealthAddress, WalletErro/;"	P	implementation:Wallet
generate_unique_id	src/chain/quantum_voting/utils.rs	/^pub fn generate_unique_id() -> String {$/;"	f
generate_useful_work	src/qup/hdcomm.rs	/^    pub fn generate_useful_work(&self, state: &QUPState) -> UsefulWork {$/;"	P	implementation:HDCommunication
generate_voter_key	src/chain/quantum_voting/quantum_key_distribution.rs	/^    fn generate_voter_key(&self, quantum_keys: &[QuantumKey]) -> Result<QuantumKey, VotingError>/;"	P	implementation:QuantumKeyDistribution
generator	src/zkp/math.rs	/^    pub fn generator(modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
generator	src/zkp/zk_starks.rs	/^    pub generator: FieldElement,$/;"	m	struct:ZkStarksVerifier
get	src/chain/state/merkle_trie.rs	/^    pub fn get(&self, key: &[u8]) -> Option<Arc<[u8]>> {$/;"	P	implementation:MerkleTrie
get	src/chain/storage/database.rs	/^    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, DatabaseError> {$/;"	P	implementation:MemoryDatabase
get	src/chain/storage/database.rs	/^    fn get(&self, key: &[u8]) -> Result<Option<Vec<u8>>, DatabaseError>;$/;"	P	interface:Database
get_account	src/chain/state/state_db.rs	/^    pub fn get_account(&mut self, address: &str) -> Option<Account> {$/;"	P	implementation:StateDB
get_account	src/chain/state/state_manager.rs	/^    pub fn get_account(&self, address: &str) -> Option<Account> {$/;"	P	implementation:StateManager
get_account	src/qup/state.rs	/^    pub fn get_account(&self, address: &Address) -> Result<Account, Error> {$/;"	P	implementation:QUPState
get_all_contracts	src/chain/storage/contract_storage.rs	/^    pub fn get_all_contracts(&self) -> Result<Vec<SmartContract>, ContractStorageError> {$/;"	P	implementation:ContractStorage
get_all_shard_states	src/chain/sharding.rs	/^    pub async fn get_all_shard_states(&self) -> Vec<ShardState> {$/;"	P	implementation:Sharding
get_allocation	src/chain/governance/treasury.rs	/^    pub fn get_allocation(&self, allocation_id: &str) -> Option<u64> {$/;"	P	implementation:Treasury
get_assertions	src/zephyrchain_circuit.rs	/^    fn get_assertions(&self) -> Result<Vec<Assertion<Self::BaseField>>, StarkError> {$/;"	P	implementation:ZephyrChainCircuit
get_available_compression_schemes	src/chain/quantum_voting/compression.rs	/^    fn get_available_compression_schemes($/;"	P	implementation:Compression
get_available_error_correction_codes	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_available_error_correction_codes($/;"	P	implementation:QuantumVoting
get_balance	src/chain/state/account.rs	/^    pub fn get_balance(&self) -> u64 {$/;"	P	implementation:Account
get_balance	src/utils/indexing.rs	/^    pub fn get_balance(&self, address: &str) -> f64 {$/;"	P	implementation:BalanceManager
get_batches	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub fn get_batches(&self, batch_size: usize) -> Vec<Vec<String>> {$/;"	P	implementation:CodeDataset
get_block	src/api/handlers/blockchain_handler.rs	/^pub async fn get_block($/;"	f
get_block	src/api/routes/blockchain.rs	/^async fn get_block(blockchain: web::Data<Blockchain>, height: web::Path<u64>) -> impl Responder /;"	f
get_block	src/network/node_message.rs	/^    async fn get_block(&mut self, hash: Hash) -> Result<Block, NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
get_block_by_hash	src/chain/storage/block_storage.rs	/^    pub fn get_block_by_hash(&self, block_hash: &str) -> Result<Option<Block>, BlockStorageError/;"	P	implementation:BlockStorage
get_block_by_height	src/chain/blockchain.rs	/^    pub async fn get_block_by_height(&self, height: u64) -> Option<Block> {$/;"	P	implementation:Blockchain
get_block_by_height	src/chain/storage/block_storage.rs	/^    pub fn get_block_by_height(&self, height: u64) -> Result<Option<Block>, BlockStorageError> {$/;"	P	implementation:BlockStorage
get_block_validator_address	src/qup/reward.rs	/^    fn get_block_validator_address(&self, block_header: &QUPBlockHeader) -> Vec<u8> {$/;"	P	implementation:RewardDistributor
get_blocks	src/api/handlers/blockchain_handler.rs	/^pub async fn get_blocks(blockchain: web::Data<Blockchain>) -> impl Responder {$/;"	f
get_blocks	src/api/routes/blockchain.rs	/^async fn get_blocks(blockchain: web::Data<Blockchain>) -> impl Responder {$/;"	f
get_candidates	src/chain/quantum_voting/voting_state.rs	/^    pub fn get_candidates(&self) -> Vec<Candidate> {$/;"	P	implementation:VotingState
get_chain_length	src/chain/blockchain.rs	/^    pub fn get_chain_length(&self) -> u64 {$/;"	P	implementation:Blockchain
get_chain_status	src/api/handlers/blockchain_handler.rs	/^pub async fn get_chain_status($/;"	f
get_chain_status	src/api/routes/blockchain.rs	/^async fn get_chain_status(blockchain: web::Data<Blockchain>) -> impl Responder {$/;"	f
get_client_bucket	src/api/middleware/rate_limiter.rs	/^    fn get_client_bucket(&self, client_id: &str) -> ClientBucket {$/;"	P	implementation:RateLimiter
get_code_snippets	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub fn get_code_snippets(&self) -> Vec<String> {$/;"	P	implementation:CodeDataset
get_consensus_parameters	src/api/handlers/qup_handler.rs	/^pub async fn get_consensus_parameters(qup_consensus: web::Data<QUPConsensus>) -> impl Responder /;"	f
get_consensus_parameters	src/api/routes/consensus.rs	/^async fn get_consensus_parameters($/;"	f
get_consensus_state	src/api/handlers/qup_handler.rs	/^pub async fn get_consensus_state(qup_consensus: web::Data<QUPConsensus>) -> impl Responder {$/;"	f
get_consensus_state	src/api/routes/consensus.rs	/^async fn get_consensus_state(consensus_engine: web::Data<ConsensusEngine>) -> impl Responder {$/;"	f
get_contract	src/api/handlers/smart_contract_handler.rs	/^pub async fn get_contract($/;"	f
get_contract	src/api/routes/smart_contract.rs	/^async fn get_contract($/;"	f
get_contract	src/chain/storage/contract_storage.rs	/^    pub fn get_contract(&self, contract_id: &str) -> Result<Option<SmartContract>, ContractStora/;"	P	implementation:ContractStorage
get_contract_state	src/api/handlers/smart_contract_handler.rs	/^pub async fn get_contract_state($/;"	f
get_contract_state	src/api/routes/smart_contract.rs	/^async fn get_contract_state($/;"	f
get_cost	src/smart_contract/gas.rs	/^    pub get_cost: u64,$/;"	m	struct:GasCost
get_current_accuracy_benchmark	src/hdcmodels/benchmark.rs	/^    pub fn get_current_accuracy_benchmark(&self) -> Result<f64> {$/;"	P	implementation:AccuracyBenchmark
get_current_block_id	src/chain/blockchain.rs	/^    pub fn get_current_block_id(&self) -> Option<usize> {$/;"	P	implementation:Blockchain
get_current_timestamp	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn get_current_timestamp(&self) -> u64 {$/;"	P	implementation:ConsensusSecurityMonitor
get_dataset_path	src/datasets/mod.rs	/^fn get_dataset_path(block_id: u64, file_name: &str) -> String {$/;"	f
get_delegated_validator	src/qup/delegator.rs	/^    pub fn get_delegated_validator(&self) -> Option<Address> {$/;"	P	implementation:QUPDelegator
get_delegator	src/qup/state.rs	/^    pub fn get_delegator(&self, address: &Address) -> Option<&QUPDelegator> {$/;"	P	implementation:QUPState
get_desired_security_level	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_desired_security_level(&self) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
get_domain	src/zkp/math.rs	/^    pub fn get_domain(size: usize, modulus: &BigUint) -> Vec<FieldElement> {$/;"	P	implementation:FieldElement
get_entries	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub fn get_entries(&self) -> &[StackEntry] {$/;"	P	implementation:CodeDataset
get_error_rate	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn get_error_rate(&self, encoded_data: &[f64]) -> f64 {$/;"	P	implementation:QUPErrorCorrection
get_expected_noise_level	src/chain/quantum_voting/error_correction.rs	/^    fn get_expected_noise_level(&self) -> Result<f64, VotingError> {$/;"	P	implementation:ErrorCorrection
get_expected_noise_level	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_expected_noise_level(&self) -> Result<f64, VotingError> {$/;"	P	implementation:QuantumVoting
get_governance_parameters	src/api/handlers/governance_handler.rs	/^pub async fn get_governance_parameters($/;"	f
get_governance_parameters	src/api/routes/governance.rs	/^async fn get_governance_parameters($/;"	f
get_historical_noise_data	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_historical_noise_data(&self) -> Result<Vec<f64>, VotingError> {$/;"	P	implementation:QuantumVoting
get_key	src/secure_core/secure_vault.rs	/^    pub fn get_key(&self, id: &str) -> Option<PrivateKey> {$/;"	P	implementation:SecureVault
get_latest_block	src/chain/blockchain.rs	/^    pub async fn get_latest_block(&self) -> Option<Block> {$/;"	P	implementation:Blockchain
get_latest_block	src/chain/storage/block_storage.rs	/^    pub fn get_latest_block(&self) -> Result<Option<Block>, BlockStorageError> {$/;"	P	implementation:BlockStorage
get_latest_block_height	src/chain/storage/block_storage.rs	/^    pub fn get_latest_block_height(&self) -> Result<Option<u64>, BlockStorageError> {$/;"	P	implementation:BlockStorage
get_latest_key_version	src/secure_core/secure_vault.rs	/^    pub fn get_latest_key_version(&self, sp_key_id: &str) -> Option<String> {$/;"	P	implementation:SecureVault
get_network_config	src/api/handlers/network_handler.rs	/^pub async fn get_network_config(network: web::Data<Network>) -> impl Responder {$/;"	f
get_network_config	src/api/routes/network.rs	/^async fn get_network_config(network: web::Data<Network>) -> impl Responder {$/;"	f
get_network_stats	src/api/handlers/network_handler.rs	/^pub async fn get_network_stats(network: web::Data<Network>) -> impl Responder {$/;"	f
get_network_stats	src/api/routes/network.rs	/^async fn get_network_stats(network: web::Data<Network>) -> impl Responder {$/;"	f
get_node_id	src/hdcmodels/benchmarking/data_collection.rs	/^    fn get_node_id(&self) -> String {$/;"	P	implementation:BenchmarkDataCollector
get_nonce	src/chain/state/account.rs	/^    pub fn get_nonce(&self) -> u64 {$/;"	P	implementation:Account
get_num_representatives	src/chain/quantum_voting/voting_state.rs	/^    pub fn get_num_representatives(&self) -> usize {$/;"	P	implementation:VotingState
get_num_voters	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_num_voters(&self) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumVoting
get_peers	src/api/handlers/network_handler.rs	/^pub async fn get_peers(network: web::Data<Network>) -> impl Responder {$/;"	f
get_peers	src/api/routes/network.rs	/^async fn get_peers(network: web::Data<Network>) -> impl Responder {$/;"	f
get_peers	src/network/node_message.rs	/^    async fn get_peers(&mut self, node_id: NodeId) -> Result<Vec<NodeId>, NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
get_post_quantum_key	src/secure_core/secure_vault.rs	/^    pub fn get_post_quantum_key(&self, id: &str) -> Result<PostQuantumKeyPair, String> {$/;"	P	implementation:SecureVault
get_proposal	src/api/handlers/governance_handler.rs	/^pub async fn get_proposal($/;"	f
get_proposal	src/api/routes/governance.rs	/^async fn get_proposal($/;"	f
get_proposal_votes	src/api/handlers/governance_handler.rs	/^pub async fn get_proposal_votes($/;"	f
get_proposal_votes	src/api/routes/governance.rs	/^async fn get_proposal_votes($/;"	f
get_proposals	src/api/handlers/governance_handler.rs	/^pub async fn get_proposals($/;"	f
get_proposals	src/api/routes/governance.rs	/^async fn get_proposals(governance_engine: web::Data<GovernanceEngine>) -> impl Responder {$/;"	f
get_public_key	src/chain/certificate_authority.rs	/^    pub fn get_public_key(&self) -> PublicKey {$/;"	P	implementation:CertificateAuthority
get_public_key	src/chain/node.rs	/^    pub async fn get_public_key(&self) -> Option<PublicKey> {$/;"	P	implementation:Node
get_public_key	src/chain/quantum_entropy.rs	/^    pub fn get_public_key(&self, keypair: &Keypair) -> PublicKey {$/;"	P	implementation:QuantumEntropySource
get_public_key_from_address	src/qup/utils.rs	/^fn get_public_key_from_address(address: &[u8]) -> Vec<u8> {$/;"	f
get_quantum_hardware_characteristics	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_quantum_hardware_characteristics(&self) -> Result<QuantumHardware, VotingError> {$/;"	P	implementation:QuantumVoting
get_qup_state	src/chain/state/state_manager.rs	/^    pub fn get_qup_state(&self) -> Arc<RwLock<QUPState>> {$/;"	P	implementation:StateManager
get_random_peers	src/network/discovery.rs	/^    pub async fn get_random_peers(&self, count: usize) -> Vec<PeerId> {$/;"	P	implementation:Discovery
get_root	src/utils/merkle_tree.rs	/^    pub fn get_root(&self) -> &Hash {$/;"	P	implementation:MerkleTree
get_secret_key	src/chain/node.rs	/^    pub async fn get_secret_key(&self) -> Option<Secret<SecretKey>> {$/;"	P	implementation:Node
get_secret_key	src/chain/quantum_entropy.rs	/^    pub fn get_secret_key(&self, keypair: &Keypair) -> Secret<SecretKey> {$/;"	P	implementation:QuantumEntropySource
get_shard_peer_id	src/chain/sharding.rs	/^    async fn get_shard_peer_id(&self, shard_id: u64) -> Result<String, ShardingError> {$/;"	P	implementation:Sharding
get_shard_state	src/chain/sharding.rs	/^    pub async fn get_shard_state(&self, shard_id: u64) -> Result<ShardState, ShardingError> {$/;"	P	implementation:Sharding
get_shard_state	src/network/shard_message.rs	/^    async fn get_shard_state(&mut self, shard_id: u64) -> Result<ShardState, NetworkError> {$/;"	f
get_sp_key	src/secure_core/secure_vault.rs	/^    pub fn get_sp_key(&self, sp_key_id: &str, user_id: &str) -> Option<Vec<u8>> {$/;"	P	implementation:SecureVault
get_staked_amount	src/chain/governance/staking.rs	/^    pub fn get_staked_amount(&self, staker: &str) -> Option<&u64> {$/;"	P	implementation:Staking
get_state	src/network/node_message.rs	/^    async fn get_state(&mut self, node_id: NodeId) -> Result<Vec<u8>, NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
get_state_root	src/chain/state/state_db.rs	/^    pub fn get_state_root(&self) -> Vec<u8> {$/;"	P	implementation:StateDB
get_state_root	src/chain/state/state_manager.rs	/^    pub fn get_state_root(&self) -> Vec<u8> {$/;"	P	implementation:StateManager
get_storage	src/chain/state/account.rs	/^    pub fn get_storage(&self, key: &str) -> Option<&String> {$/;"	P	implementation:Account
get_timing	src/hdcmodels/performance_optimization/profiling.rs	/^    pub fn get_timing(&self, label: &str) -> Option<Duration> {$/;"	P	implementation:Profiler
get_total_available_qubits	src/chain/quantum_voting/quantum_voting.rs	/^    fn get_total_available_qubits(&self) -> Result<usize, VotingError> {$/;"	P	implementation:QuantumVoting
get_transaction	src/api/handlers/blockchain_handler.rs	/^pub async fn get_transaction($/;"	f
get_transaction	src/api/routes/blockchain.rs	/^async fn get_transaction($/;"	f
get_transaction_history	src/api/handlers/transaction_handler.rs	/^pub async fn get_transaction_history($/;"	f
get_transaction_history	src/api/routes/transaction.rs	/^async fn get_transaction_history(blockchain: web::Data<Blockchain>) -> impl Responder {$/;"	f
get_transaction_status	src/api/handlers/transaction_handler.rs	/^pub async fn get_transaction_status($/;"	f
get_transaction_status	src/api/routes/transaction.rs	/^async fn get_transaction_status($/;"	f
get_transactions	src/api/handlers/blockchain_handler.rs	/^pub async fn get_transactions($/;"	f
get_transactions	src/api/routes/blockchain.rs	/^async fn get_transactions(blockchain: web::Data<Blockchain>) -> impl Responder {$/;"	f
get_transactions	src/mining/transaction_pool.rs	/^    pub fn get_transactions(&self) -> Vec<Transaction> {$/;"	P	implementation:TransactionPool
get_transactions_for_address	src/utils/indexing.rs	/^    pub fn get_transactions_for_address(&self, address: &str) -> HashSet<String> {$/;"	P	implementation:TransactionIndex
get_unclaimed_reward	src/chain/governance/rewards.rs	/^    pub fn get_unclaimed_reward(&self, participant: &str) -> Option<&u64> {$/;"	P	implementation:Rewards
get_user_permissions	src/secure_core/access_control.rs	/^    pub fn get_user_permissions(&self, user_id: &str) -> Vec<Permission> {$/;"	P	implementation:AccessControl
get_validator	src/qup/state.rs	/^    pub fn get_validator(&self, address: &Address) -> Option<&QUPValidator> {$/;"	P	implementation:QUPState
get_validator_state	src/chain/state/state_manager.rs	/^    pub fn get_validator_state(&self, validator_id: &str) -> Option<QUPValidator> {$/;"	P	implementation:StateManager
get_validators	src/api/handlers/qup_handler.rs	/^pub async fn get_validators(qup_consensus: web::Data<QUPConsensus>) -> impl Responder {$/;"	f
get_validators	src/api/routes/consensus.rs	/^async fn get_validators(consensus_engine: web::Data<ConsensusEngine>) -> impl Responder {$/;"	f
get_value	src/smart_contract/execution_context.rs	/^    pub fn get_value(&self, key: &str) -> Option<&Value> {$/;"	P	implementation:ExecutionContext
get_vote_counts	src/chain/governance/voting.rs	/^    pub fn get_vote_counts(&self, proposal_id: u64) -> (u64, u64, u64) {$/;"	P	implementation:Voting
get_vote_counts	src/chain/quantum_voting/voting_state.rs	/^    pub fn get_vote_counts(&self) -> HashMap<String, usize> {$/;"	P	implementation:VotingState
get_voting_duration	src/chain/quantum_voting/voting_state.rs	/^    pub fn get_voting_duration(&self) -> u64 {$/;"	P	implementation:VotingState
get_voting_power	src/api/handlers/governance_handler.rs	/^pub async fn get_voting_power($/;"	f
get_voting_power	src/api/routes/governance.rs	/^async fn get_voting_power(governance_engine: web::Data<GovernanceEngine>) -> impl Responder {$/;"	f
get_voting_power	src/qup/delegator.rs	/^    pub fn get_voting_power(&self) -> u64 {$/;"	P	implementation:QUPDelegator
get_voting_result	src/chain/governance/voting.rs	/^    pub fn get_voting_result(&self, proposal: &Proposal) -> ProposalStatus {$/;"	P	implementation:Voting
governance	src/chain/mod.rs	/^mod governance;$/;"	n
governance_engine	src/chain/governance/mod.rs	/^mod governance_engine;/;"	n
governance_routes	src/api/routes/governance.rs	/^pub fn governance_routes(cfg: &mut web::ServiceConfig) {$/;"	f
grant_permission	src/secure_core/access_control.rs	/^    pub fn grant_permission(&self, role: Role, permission: Permission) {$/;"	P	implementation:AccessControl
graph	src/qup/types.rs	/^    pub graph: Vec<Vec<usize>>,$/;"	m	struct:VertexCoverProblem
hamming_distance	src/hdcmodels/similarity.rs	/^pub fn hamming_distance(vec1: &[f64], vec2: &[f64]) -> usize {$/;"	f
hamming_distance	src/utils/mod.rs	/^pub fn hamming_distance(vec1: &[f64], vec2: &[f64]) -> u64 {$/;"	f
handle_anomaly	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn handle_anomaly(&self, state: &ConsensusState, message: &ConsensusMessage) {$/;"	P	implementation:ConsensusSecurityMonitor
handle_block	src/mining/miner.rs	/^    pub fn handle_block(&mut self, block: Block) {$/;"	P	implementation:Miner
handle_block	src/network/handler.rs	/^    fn handle_block(&self, peer: &Peer, block: Block) {$/;"	P	implementation:HandlerImpl
handle_block	src/network/handler.rs	/^    fn handle_block(&self, peer: &Peer, block: Block);$/;"	P	interface:Handler
handle_block	src/network/mod.rs	/^    async fn handle_block(&self, peer_addr: &str, block: Block) {$/;"	P	implementation:Network
handle_block_broadcast	src/network/node_message.rs	/^    async fn handle_block_broadcast(&mut self, block: Block, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_block_request	src/network/node_message.rs	/^    async fn handle_block_request(&mut self, hash: Hash, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_block_response	src/network/node_message.rs	/^    async fn handle_block_response(&mut self, block: Block, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_blocks	src/network/mod.rs	/^    async fn handle_blocks(&self, peer_addr: &str, blocks: Vec<Block>) {$/;"	P	implementation:Network
handle_connection	src/network/network_manager.rs	/^    async fn handle_connection($/;"	P	implementation:NetworkManager
handle_connection	src/network/p2p/peer.rs	/^    pub async fn handle_connection(mut stream: TLSStream, mut peer: Peer) {$/;"	P	implementation:Peer
handle_connection	src/network/server.rs	/^async fn handle_connection($/;"	f
handle_double_spending	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn handle_double_spending(&self, block: &Block) {$/;"	P	implementation:ConsensusSecurityMonitor
handle_error_response	src/network/node_message.rs	/^    async fn handle_error_response(&mut self, error: NodeMessageError, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_get_blocks	src/network/mod.rs	/^    async fn handle_get_blocks(&self, peer_addr: &str, hash: Hasher) {$/;"	P	implementation:Network
handle_get_state	src/network/mod.rs	/^    async fn handle_get_state(&self, peer_addr: &str, height: u64) {$/;"	P	implementation:Network
handle_ineligible_proposer	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn handle_ineligible_proposer(&self, proposer: &Proposer) {$/;"	P	implementation:ConsensusSecurityMonitor
handle_invalid_block	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn handle_invalid_block(&self, block: &Block) {$/;"	P	implementation:ConsensusSecurityMonitor
handle_measurement_results_message	src/network/node_message.rs	/^    async fn handle_measurement_results_message(&mut self, results: Vec<bool>, sender: &NodeId) /;"	P	implementation:NodeMessageHandler
handle_message	src/chain/node.rs	/^    pub async fn handle_message(&self, message: NodeMessage) {$/;"	P	implementation:Node
handle_message	src/chain/sharding.rs	/^    pub async fn handle_message(&mut self, shard_id: u64, message: ShardMessage) {$/;"	P	implementation:Sharding
handle_message	src/network/handler.rs	/^    fn handle_message(&self, peer: &Peer, message: Message) {$/;"	P	implementation:HandlerImpl
handle_message	src/network/handler.rs	/^    fn handle_message(&self, peer: &Peer, message: Message);$/;"	P	interface:Handler
handle_message	src/network/mod.rs	/^    pub async fn handle_message(&self, peer_addr: &str, message: Message) {$/;"	P	implementation:Network
handle_message	src/network/node_message.rs	/^    pub async fn handle_message($/;"	P	implementation:NodeMessageHandler
handle_message	src/network/shard_message.rs	/^    pub async fn handle_message(&mut self, shard_id: u64, serialized_message: Vec<u8>) {$/;"	P	implementation:ShardMessageHandler
handle_messages	src/network/network_manager.rs	/^    async fn handle_messages(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
handle_model_update	src/hdcmodels/distributed_training/synchronization.rs	/^    pub async fn handle_model_update(&self, peer: &Peer, message: ModelUpdateMessage) {$/;"	P	implementation:Synchronizer
handle_node_failure	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn handle_node_failure(&mut self) {$/;"	P	implementation:FaultTolerantDistributedTrainingNode
handle_node_failure	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn handle_node_failure(&mut self, node_id: usize) {$/;"	P	implementation:FaultTolerantDistributedTrainingAggregator
handle_other_security_issues	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn handle_other_security_issues(&self, proposal: &Proposal) {$/;"	P	implementation:ConsensusSecurityMonitor
handle_peer_discovery	src/network/handler.rs	/^    fn handle_peer_discovery(&self, peer: &Peer, peer_addresses: Vec<String>) {$/;"	P	implementation:HandlerImpl
handle_peer_discovery	src/network/handler.rs	/^    fn handle_peer_discovery(&self, peer: &Peer, peer_addresses: Vec<String>);$/;"	P	interface:Handler
handle_peer_request	src/network/node_message.rs	/^    async fn handle_peer_request(&mut self, node_id: NodeId, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_peer_response	src/network/node_message.rs	/^    async fn handle_peer_response(&mut self, peers: Vec<NodeId>, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_ping	src/network/mod.rs	/^    async fn handle_ping(&self, peer_addr: &str) {$/;"	P	implementation:Network
handle_ping	src/network/node_message.rs	/^    async fn handle_ping(&mut self, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_pong	src/network/mod.rs	/^    async fn handle_pong(&self, peer_addr: &str) {$/;"	P	implementation:Network
handle_pong	src/network/node_message.rs	/^    async fn handle_pong(&mut self, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_post_quantum_certificate_request	src/chain/node.rs	/^    async fn handle_post_quantum_certificate_request($/;"	P	implementation:Node
handle_post_quantum_certificate_response	src/chain/node.rs	/^    async fn handle_post_quantum_certificate_response(&self, certificate: X509Certificate) {$/;"	P	implementation:Node
handle_qkd_key_confirmation	src/network/client.rs	/^    async fn handle_qkd_key_confirmation(&mut self) {$/;"	P	implementation:Client
handle_qkd_key_confirmation	src/network/node_message.rs	/^    async fn handle_qkd_key_confirmation(&mut self, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qkd_key_confirmation	src/network/server.rs	/^async fn handle_qkd_key_confirmation($/;"	f
handle_qkd_key_confirmation_shard	src/network/shard_message.rs	/^    async fn handle_qkd_key_confirmation_shard(&mut self, shard_id: u64) {$/;"	f
handle_qkd_key_request	src/network/client.rs	/^    async fn handle_qkd_key_request(&mut self) {$/;"	P	implementation:Client
handle_qkd_key_request	src/network/node_message.rs	/^    async fn handle_qkd_key_request(&mut self, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qkd_key_request	src/network/server.rs	/^async fn handle_qkd_key_request($/;"	f
handle_qkd_key_request_shard	src/network/shard_message.rs	/^    async fn handle_qkd_key_request_shard(&mut self, shard_id: u64) {$/;"	f
handle_qkd_key_response	src/network/client.rs	/^    async fn handle_qkd_key_response(&mut self, key: QKDKey) {$/;"	P	implementation:Client
handle_qkd_key_response	src/network/node_message.rs	/^    async fn handle_qkd_key_response(&mut self, key: QKDKey, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qkd_key_response	src/network/server.rs	/^async fn handle_qkd_key_response($/;"	f
handle_qkd_key_response_shard	src/network/shard_message.rs	/^    async fn handle_qkd_key_response_shard(&mut self, shard_id: u64, public_key: QKDPublicKey) {$/;"	f
handle_quantum_state_distribution	src/network/client.rs	/^    async fn handle_quantum_state_distribution(&mut self, state: QuantumState) {$/;"	P	implementation:Client
handle_quantum_state_distribution	src/network/node_message.rs	/^    async fn handle_quantum_state_distribution(&mut self, state: QuantumState, sender: &NodeId) /;"	P	implementation:NodeMessageHandler
handle_quantum_state_distribution	src/network/server.rs	/^async fn handle_quantum_state_distribution($/;"	f
handle_quantum_state_distribution_shard	src/network/shard_message.rs	/^    async fn handle_quantum_state_distribution_shard(&mut self, shard_id: u64, state: QuantumSta/;"	f
handle_quantum_state_measurement_results	src/network/client.rs	/^    async fn handle_quantum_state_measurement_results(&mut self, results: Vec<bool>) {$/;"	P	implementation:Client
handle_quantum_state_measurement_results	src/network/node_message.rs	/^    async fn handle_quantum_state_measurement_results($/;"	P	implementation:NodeMessageHandler
handle_quantum_state_measurement_results	src/network/server.rs	/^async fn handle_quantum_state_measurement_results($/;"	f
handle_quantum_state_measurement_results_shard	src/network/shard_message.rs	/^    async fn handle_quantum_state_measurement_results_shard(&mut self, shard_id: u64, results: V/;"	f
handle_quantum_state_message	src/network/node_message.rs	/^    async fn handle_quantum_state_message(&mut self, state: TimeBinState, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_query_block	src/api/api.rs	/^async fn handle_query_block($/;"	f
handle_qup_block_commit	src/network/node_message.rs	/^    async fn handle_qup_block_commit(&mut self, block: QUPBlock, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qup_block_proposal	src/network/node_message.rs	/^    async fn handle_qup_block_proposal(&mut self, block: QUPBlock, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qup_key_exchange	src/network/node_message.rs	/^    async fn handle_qup_key_exchange(&mut self, key_exchange: QUPKeyExchange, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qup_message	src/network/network_manager.rs	/^    pub async fn handle_qup_message(&self, message: QUPMessage) -> Result<()> {$/;"	P	implementation:NetworkManager
handle_qup_shard_block_commit	src/network/shard_message.rs	/^    async fn handle_qup_shard_block_commit($/;"	f
handle_qup_shard_block_proposal	src/network/shard_message.rs	/^    async fn handle_qup_shard_block_proposal($/;"	f
handle_qup_shard_useful_work	src/network/shard_message.rs	/^    async fn handle_qup_shard_useful_work(&mut self, shard_id: u64, useful_work: QUPUsefulWork) /;"	f
handle_qup_shard_vote	src/network/shard_message.rs	/^    async fn handle_qup_shard_vote(&mut self, shard_id: u64, vote: QUPVote) {$/;"	f
handle_qup_useful_work	src/network/node_message.rs	/^    async fn handle_qup_useful_work(&mut self, useful_work: QUPUsefulWork, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_qup_vote	src/network/node_message.rs	/^    async fn handle_qup_vote(&mut self, vote: QUPVote, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_rejection	src/api/api.rs	/^async fn handle_rejection(err: Rejection) -> Result<impl Reply, Rejection> {$/;"	f
handle_shard_message	src/chain/shard.rs	/^    async fn handle_shard_message(&mut self, message: ShardMessage) -> Result<(), ShardError> {$/;"	P	implementation:Shard
handle_state	src/network/mod.rs	/^    async fn handle_state(&self, peer_addr: &str, state: Vec<u8>) {$/;"	P	implementation:Network
handle_state_request	src/network/node_message.rs	/^    async fn handle_state_request(&mut self, node_id: NodeId, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_state_request	src/network/shard_message.rs	/^    async fn handle_state_request(&mut self, shard_id: u64) {$/;"	f
handle_state_request	src/network/sync/state_sync.rs	/^    async fn handle_state_request(&self, shard_id: u64) -> Result<(), StateSyncError> {$/;"	P	implementation:StateSync
handle_state_response	src/chain/sharding.rs	/^    async fn handle_state_response(&mut self, shard_id: u64, encrypted_state: Vec<u8>) {$/;"	P	implementation:Sharding
handle_state_response	src/chain/sharding.rs	/^    async fn handle_state_response(&mut self, shard_id: u64, state: ShardState) {$/;"	P	implementation:Sharding
handle_state_response	src/network/node_message.rs	/^    async fn handle_state_response(&mut self, state: Vec<u8>, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_state_response	src/network/shard_message.rs	/^    async fn handle_state_response(&mut self, shard_id: u64, state: ShardState) {$/;"	f
handle_state_response	src/network/sync/state_sync.rs	/^    async fn handle_state_response($/;"	P	implementation:StateSync
handle_state_sync	src/network/handler.rs	/^    fn handle_state_sync(&self, peer: &Peer, state_sync_message: StateSyncMessage) {$/;"	P	implementation:HandlerImpl
handle_state_sync	src/network/handler.rs	/^    fn handle_state_sync(&self, peer: &Peer, state_sync_message: StateSyncMessage);$/;"	P	interface:Handler
handle_submit_transaction	src/api/api.rs	/^async fn handle_submit_transaction($/;"	f
handle_transaction	src/mining/miner.rs	/^    pub fn handle_transaction(&mut self, transaction: Transaction) {$/;"	P	implementation:Miner
handle_transaction	src/network/handler.rs	/^    fn handle_transaction(&self, peer: &Peer, transaction: Transaction) {$/;"	P	implementation:HandlerImpl
handle_transaction	src/network/handler.rs	/^    fn handle_transaction(&self, peer: &Peer, transaction: Transaction);$/;"	P	interface:Handler
handle_transaction	src/network/mod.rs	/^    async fn handle_transaction(&self, peer_addr: &str, tx: Transaction) {$/;"	P	implementation:Network
handle_transaction_broadcast	src/network/node_message.rs	/^    async fn handle_transaction_broadcast(&mut self, tx: Transaction, sender: &NodeId) {$/;"	P	implementation:NodeMessageHandler
handle_transaction_message	src/chain/sharding.rs	/^    async fn handle_transaction_message(&mut self, shard_id: u64, encrypted_transaction: Vec<u8>/;"	P	implementation:Sharding
handle_transaction_message	src/network/shard_message.rs	/^    async fn handle_transaction_message(&mut self, shard_id: u64, transaction: Transaction) {$/;"	f
handle_useful_work_request	src/qup/consensus.rs	/^    pub fn handle_useful_work_request($/;"	P	implementation:QUPConsensus
handler	src/network/client.rs	/^    handler: Arc<dyn Handler>,$/;"	m	struct:Client
handler	src/network/lib.rs	/^    pub handler: Arc<dyn Handler>,$/;"	m	struct:Network
handler	src/network/lib.rs	/^pub mod handler;$/;"	n
handler	src/network/mod.rs	/^mod handler;$/;"	n
handler	src/network/server.rs	/^    handler: Arc<dyn Handler>,$/;"	m	struct:Server
handlers	src/api/mod.rs	/^pub mod handlers;$/;"	n
handshake_timeout	src/network/config.rs	/^    pub handshake_timeout: Duration,$/;"	m	struct:NetworkConfig
has_double_spending	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn has_double_spending(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
has_local_entropy_source	src/chain/node.rs	/^    pub has_local_entropy_source: bool,$/;"	m	struct:NodeConfig
has_other_security_issues	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn has_other_security_issues(&self, proposal: &Proposal) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
has_permission	src/api/middleware/authentication.rs	/^    pub fn has_permission(&self, required_role: Role) -> bool {$/;"	P	implementation:AuthenticatedUser
has_storage_key	src/chain/state/account.rs	/^    pub fn has_storage_key(&self, key: &str) -> bool {$/;"	P	implementation:Account
has_value	src/smart_contract/execution_context.rs	/^    pub fn has_value(&self, key: &str) -> bool {$/;"	P	implementation:ExecutionContext
hash	src/api/handlers/blockchain_handler.rs	/^    hash: String,$/;"	m	struct:BlockInfo
hash	src/api/handlers/blockchain_handler.rs	/^    hash: String,$/;"	m	struct:TransactionInfo
hash	src/api/handlers/transaction_handler.rs	/^    hash: String,$/;"	m	struct:TransactionInfo
hash	src/api/handlers/transaction_handler.rs	/^    hash: String,$/;"	m	struct:TransactionStatusResponse
hash	src/api/models/request/transaction_request.rs	/^    pub hash: String,$/;"	m	struct:Transaction
hash	src/api/models/response/blockchain_response.rs	/^    pub hash: String,$/;"	m	struct:TransactionData
hash	src/api/routes/blockchain.rs	/^    hash: String,$/;"	m	struct:BlockInfo
hash	src/api/routes/blockchain.rs	/^    hash: String,$/;"	m	struct:TransactionInfo
hash	src/api/routes/transaction.rs	/^    hash: String,$/;"	m	struct:TransactionInfo
hash	src/api/routes/transaction.rs	/^    hash: String,$/;"	m	struct:TransactionStatusResponse
hash	src/chain/block.rs	/^    pub hash: String,$/;"	m	struct:Block
hash	src/chain/governance/proposal.rs	/^    fn hash(&self) -> Vec<u8> {$/;"	P	implementation:Proposal
hash	src/chain/quantum_voting/quantum_cryptography.rs	/^    hash: QuantumHash,$/;"	m	struct:QuantumCryptography
hash	src/chain/shard.rs	/^    fn hash<H: Hasher>(&self, state: &mut H) {$/;"	P	implementation:ShardState
hash	src/chain/state/merkle_trie.rs	/^    pub fn hash(&self) -> Vec<u8> {$/;"	P	implementation:TrieNode
hash	src/crypto/mod.rs	/^pub(crate) mod hash;$/;"	n
hash	src/qup/block.rs	/^    pub fn hash(&self) -> Hash {$/;"	P	implementation:QUPBlock
hash	src/qup/crypto.rs	/^    pub fn hash(&self, data: &[u8]) -> Hash {$/;"	P	implementation:QUPCrypto
hash	src/utils/node_id.rs	/^    fn hash<H: Hasher>(&self, state: &mut H) {$/;"	P	implementation:NodeId
hash_blake3	src/crypto/hash.rs	/^pub fn hash_blake3(data: &[u8]) -> Vec<u8> {$/;"	f
hash_data	src/secure_core/security_utils.rs	/^    pub fn hash_data(data: &[u8]) -> Vec<u8> {$/;"	P	implementation:SecurityUtils
hash_function	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    hash_function: QuantumSecureHashFunction,$/;"	m	struct:SmartContractGenerator
hash_pair	src/utils/merkle_tree.rs	/^fn hash_pair(left: &Hash, right: &Hash) -> Hash {$/;"	f
hash_qup	src/crypto/hash.rs	/^pub fn hash_qup(data: &[u8]) -> Vec<u8> {$/;"	f
hash_sha256	src/crypto/hash.rs	/^pub fn hash_sha256(data: &[u8]) -> Vec<u8> {$/;"	f
hash_sha3_256	src/crypto/hash.rs	/^pub fn hash_sha3_256(data: &[u8]) -> Vec<u8> {$/;"	f
hash_sha3_512	src/crypto/hash.rs	/^pub fn hash_sha3_512(data: &[u8]) -> Vec<u8> {$/;"	f
hash_sha512	src/crypto/hash.rs	/^pub fn hash_sha512(data: &[u8]) -> Vec<u8> {$/;"	f
hash_transaction	src/utils/merkle_tree.rs	/^pub fn hash_transaction(transaction: &QUPTransaction) -> Hash {$/;"	f
hash_vote	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn hash_vote(&self, vote: &Vote) -> Result<QuantumHash, VotingError> {$/;"	P	implementation:QuantumCryptography
hasher	src/qup/config.rs	/^    pub fn hasher(&self) -> Arc<dyn Hasher> {$/;"	P	implementation:QUPConfig
hdc_code_generation	src/optimization_problems/mod.rs	/^mod hdc_code_generation;/;"	n
hdc_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    hdc_model: Arc<HDCModel>,$/;"	m	struct:DistributedTrainingAggregator
hdc_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    hdc_model: Arc<HDCModel>,$/;"	m	struct:DistributedTrainingNode
hdc_model	src/hdcmodels/governance_integration/consensus_security.rs	/^    hdc_model: HDCModel,$/;"	m	struct:ConsensusSecurityMonitor
hdc_model	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    hdc_model: HDCModel,$/;"	m	struct:ProposalAnalyzer
hdc_model	src/hdcmodels/model_integration/hybrid_models.rs	/^    hdc_model: HDCModel,$/;"	m	struct:HybridModel
hdc_model	src/hdcmodels/model_integration/transfer_learning.rs	/^    hdc_model: HDCModel,$/;"	m	struct:TransferLearningModel
hdc_model	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    hdc_model: HDCModel,$/;"	m	struct:SmartContractSpecEncoder
hdc_model	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    hdc_model: HDCModel,$/;"	m	struct:TransactionEncoder
hdc_optimize	src/qup/hdcomm.rs	/^fn hdc_optimize(encoded_problem: &[f64], num_dimensions: usize) -> Vec<f64> {$/;"	f
hdc_optimizer	src/qup/consensus.rs	/^    pub hdc_optimizer: HDCOptimizer,$/;"	m	struct:QUPConsensus
hdc_to_neural_network	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn hdc_to_neural_network(hdc_vectors: &[Vec<f64>], output_size: usize) -> Tensor {$/;"	P	implementation:DataConverter
hdc_to_transformer	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn hdc_to_transformer(hdc_vectors: &[Vec<f64>], max_length: usize) -> Tensor {$/;"	P	implementation:DataConverter
hdcomm	src/qup/lib.rs	/^pub mod hdcomm;$/;"	n
hdcomm	src/qup/mod.rs	/^pub mod hdcomm;$/;"	n
header	src/api/models/request/blockchain_request.rs	/^    pub header: BlockHeader,$/;"	m	struct:BlockData
header	src/api/models/response/blockchain_response.rs	/^    pub header: BlockHeader,$/;"	m	struct:BlockData
heartbeat_interval	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    heartbeat_interval: Duration,$/;"	m	struct:FaultTolerantDistributedTrainingAggregator
heartbeat_interval	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    heartbeat_interval: Duration,$/;"	m	struct:FaultTolerantDistributedTrainingNode
height	src/api/handlers/blockchain_handler.rs	/^    height: u64,$/;"	m	struct:BlockInfo
height	src/api/handlers/blockchain_handler.rs	/^    height: u64,$/;"	m	struct:ChainStatus
height	src/api/models/response/blockchain_response.rs	/^    pub height: u64,$/;"	m	struct:GetChainInfoResponse
height	src/api/routes/blockchain.rs	/^    height: u64,$/;"	m	struct:BlockInfo
height	src/api/routes/blockchain.rs	/^    height: u64,$/;"	m	struct:ChainStatus
height	src/qup/block.rs	/^    pub height: u64,$/;"	m	struct:QUPBlock
homomorphic_aggregate_votes	src/chain/quantum_voting/voting_protocols.rs	/^    fn homomorphic_aggregate_votes($/;"	P	implementation:VotingProtocols
homomorphic_decrypt_vote	src/chain/quantum_voting/voting_protocols.rs	/^    fn homomorphic_decrypt_vote($/;"	P	implementation:VotingProtocols
homomorphic_encrypt_votes	src/chain/quantum_voting/voting_protocols.rs	/^    fn homomorphic_encrypt_votes($/;"	P	implementation:VotingProtocols
homomorphic_quantum_voting	src/chain/quantum_voting/voting_protocols.rs	/^    pub fn homomorphic_quantum_voting($/;"	P	implementation:VotingProtocols
hv_dimension	src/chain/block.rs	/^    pub hv_dimension: u64,$/;"	m	struct:Block
id	src/api/handlers/governance_handler.rs	/^    id: u64,$/;"	m	struct:ProposalInfo
id	src/api/handlers/network_handler.rs	/^    id: String,$/;"	m	struct:PeerInfo
id	src/api/models/request/network_request.rs	/^    pub id: String,$/;"	m	struct:PeerInfo
id	src/api/models/response/network_response.rs	/^    pub id: String,$/;"	m	struct:PeerInfo
id	src/api/routes/governance.rs	/^    id: u64,$/;"	m	struct:ProposalInfo
id	src/api/routes/network.rs	/^    id: String,$/;"	m	struct:PeerInfo
id	src/chain/governance/proposal.rs	/^    pub id: u64,$/;"	m	struct:Proposal
id	src/chain/node.rs	/^    id: NodeId,$/;"	m	struct:Node
id	src/chain/quantum_voting/types.rs	/^    pub id: String,$/;"	m	struct:Candidate
id	src/chain/state_channel.rs	/^    pub id: String,$/;"	m	struct:StateChannelOptimized
id	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub id: String,$/;"	m	struct:Dataset
id	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub id: String,$/;"	m	struct:StackEntry
identify_cost_reductions	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn identify_cost_reductions(&self, transactions: &[Transaction]) -> Vec<Transaction> {$/;"	P	implementation:TransactionOptimizer
identify_performance_improvements	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn identify_performance_improvements($/;"	P	implementation:TransactionOptimizer
identify_security_enhancements	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn identify_security_enhancements(&self, transactions: &[Transaction]) -> Vec<Transactio/;"	P	implementation:TransactionOptimizer
if_cost	src/smart_contract/gas.rs	/^    pub if_cost: u64,$/;"	m	struct:GasCost
im	src/crypto/quantum_state.rs	/^    pub im: f64,$/;"	m	struct:Complex64
incoming_messages	src/chain/shard.rs	/^    pub incoming_messages: Receiver<NetworkMessage>,$/;"	m	struct:Shard
incoming_peers	src/api/handlers/network_handler.rs	/^    incoming_peers: usize,$/;"	m	struct:NetworkStats
incoming_peers	src/api/models/response/network_response.rs	/^    pub incoming_peers: usize,$/;"	m	struct:NetworkStats
incoming_peers	src/api/routes/network.rs	/^    incoming_peers: usize,$/;"	m	struct:NetworkStats
increment	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    fn increment(&mut self, encoded_data: &[f64], label: &str) {$/;"	P	implementation:IncrementalLearningHDCModel
increment_nonce	src/chain/state/account.rs	/^    pub fn increment_nonce(&mut self) {$/;"	P	implementation:Account
index_transaction	src/utils/indexing.rs	/^    pub fn index_transaction(&mut self, transaction: &Transaction) {$/;"	P	implementation:TransactionIndex
infer	src/hdcmodels/parallel_processing.rs	/^    pub fn infer($/;"	P	implementation:ParallelHDCInference
init	src/error_handling/error_reporter.rs	/^    pub fn init(&self) {$/;"	P	implementation:ErrorReporter
init_shards	src/chain/sharding.rs	/^    pub async fn init_shards(&self) {$/;"	P	implementation:Sharding
initialize_peers	src/network/network_manager.rs	/^    async fn initialize_peers(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
initialize_voting	src/chain/quantum_voting/voting_state.rs	/^    pub fn initialize_voting($/;"	P	implementation:VotingState
initiate_dispute	src/chain/state_channel.rs	/^    pub fn initiate_dispute(&mut self, channel_id: &str, transaction: OffChainTransaction, reaso/;"	P	implementation:ChannelManagerOptimized
initiate_dispute	src/chain/state_channel.rs	/^    pub fn initiate_dispute(&mut self, transaction: OffChainTransaction, reason: String) -> Resu/;"	P	implementation:StateChannelOptimized
inputs	src/zkp/constraint_system.rs	/^    pub inputs: Vec<FieldElement>,$/;"	m	struct:ConstraintSystemImpl
insert	src/chain/state/merkle_trie.rs	/^    pub fn insert(&mut self, key: &[u8], value: &[u8]) {$/;"	P	implementation:MerkleTrie
interpreter	src/smart_contract/lib.rs	/^pub mod interpreter;$/;"	n
interpreter	src/smart_contract/mod.rs	/^mod interpreter;$/;"	n
invalidate_sp_key	src/secure_core/secure_vault.rs	/^    pub fn invalidate_sp_key(&self, sp_key_id: &str) -> bool {$/;"	P	implementation:SecureVault
is_active	src/chain/governance/proposal.rs	/^    pub fn is_active(&self) -> bool {$/;"	P	implementation:Proposal
is_allowed	src/network/mod.rs	/^    fn is_allowed(&self, peer_addr: &str) -> bool {$/;"	P	implementation:Network
is_eligible_proposer	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_eligible_proposer(&self, proposer: &Proposer) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_empty	src/chain/state/account.rs	/^    pub fn is_empty(&self) -> bool {$/;"	P	implementation:Account
is_empty	src/mining/transaction_pool.rs	/^    pub fn is_empty(&self) -> bool {$/;"	P	implementation:TransactionPool
is_expired	src/chain/governance/proposal.rs	/^    pub fn is_expired(&self) -> bool {$/;"	P	implementation:Proposal
is_leaf	src/chain/state/merkle_trie.rs	/^    pub fn is_leaf(&self) -> bool {$/;"	P	implementation:TrieNode
is_outbound	src/api/handlers/network_handler.rs	/^    is_outbound: bool,$/;"	m	struct:PeerInfo
is_outbound	src/api/models/request/network_request.rs	/^    pub is_outbound: bool,$/;"	m	struct:PeerInfo
is_outbound	src/api/models/response/network_response.rs	/^    pub is_outbound: bool,$/;"	m	struct:PeerInfo
is_outbound	src/api/routes/network.rs	/^    is_outbound: bool,$/;"	m	struct:PeerInfo
is_token_revoked	src/api/middleware/authentication.rs	/^fn is_token_revoked(token: &str) -> bool {$/;"	f
is_valid_block	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_difficulty	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_difficulty(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_hash	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_hash(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_merkle_root	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_merkle_root(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_signature	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_signature(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_size	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_size(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_timestamp	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_timestamp(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_block_version	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_block_version(&self, block: &Block) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_transaction_signature	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn is_valid_transaction_signature(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:ConsensusSecurityMonitor
is_valid_vertex_cover	src/qup/hdcomm.rs	/^fn is_valid_vertex_cover(graph: &Vec<Vec<usize>>, vertex_cover: &Vec<usize>) -> bool {$/;"	f
is_valid_vote	src/chain/governance/voting.rs	/^    fn is_valid_vote(&self, vote: &Vote) -> bool {$/;"	P	implementation:Voting
is_voting_ongoing	src/chain/quantum_voting/voting_state.rs	/^    pub fn is_voting_ongoing(&self) -> bool {$/;"	P	implementation:VotingState
items	src/hdcmodels/hdcmodels.rs	/^    items: Vec<DataItem>,$/;"	m	struct:Dataset
iter	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub fn iter(&self) -> std::slice::Iter<(Vec<f64>, String)> {$/;"	P	implementation:Dataset
iter	src/hdcmodels/hdcmodels.rs	/^    pub fn iter(&self) -> std::slice::Iter<DataItem> {$/;"	P	implementation:Dataset
iterate	src/chain/storage/database.rs	/^    fn iterate(&self) -> Result<Vec<(Vec<u8>, Vec<u8>)>, DatabaseError> {$/;"	P	implementation:MemoryDatabase
iterate	src/chain/storage/database.rs	/^    fn iterate(&self) -> Result<Vec<(Vec<u8>, Vec<u8>)>, DatabaseError>;$/;"	P	interface:Database
iterate_with_prefix	src/chain/storage/database.rs	/^    fn iterate_with_prefix(&self, prefix: &[u8]) -> Result<Vec<(Vec<u8>, Vec<u8>)>, DatabaseErro/;"	P	implementation:MemoryDatabase
iterate_with_prefix	src/chain/storage/database.rs	/^    fn iterate_with_prefix(&self, prefix: &[u8]) -> Result<Vec<(Vec<u8>, Vec<u8>)>, DatabaseErro/;"	P	interface:Database
justification	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub justification: String,$/;"	m	struct:SecureHDCModelUpdateProposal
key	src/chain/state/merkle_trie.rs	/^    pub key: Arc<[u8]>,$/;"	m	struct:TrieNode
key_distribution	src/chain/quantum_voting/mod.rs	/^    key_distribution: QuantumKeyDistribution,$/;"	m	struct:QuantumVoting
key_distribution_protocol	src/chain/quantum_voting/security_analysis.rs	/^    key_distribution_protocol: QuantumKeyDistributionProtocol,$/;"	m	struct:SecurityAnalysis
key_expiry_times	src/secure_core/secure_vault.rs	/^    key_expiry_times: Arc<Mutex<HashMap<String, SystemTime>>>,$/;"	m	struct:SecureVault
key_generator	src/chain/quantum_voting/quantum_key_distribution.rs	/^    key_generator: QuantumKeyGenerator,$/;"	m	struct:QuantumKeyDistribution
key_pair	src/qup/consensus.rs	/^    pub key_pair: QUPKeyPair,$/;"	m	struct:QUPConsensus
key_pair	src/qup/validator.rs	/^    pub key_pair: QUPKeyPair,$/;"	m	struct:QUPValidator
key_versions	src/secure_core/secure_vault.rs	/^    key_versions: Arc<Mutex<HashMap<String, Vec<String>>>>,$/;"	m	struct:SecureVault
keypair	src/network/quantum_resistant.rs	/^    keypair: Arc<Keypair>,$/;"	m	struct:QuantumResistantConnection
keypair	src/zkp/crypto.rs	/^    keypair: Keypair, \/\/ Add this line to store the Keypair$/;"	m	struct:QuantumResistantMerkleTree
keys	src/secure_core/secure_vault.rs	/^    keys: Arc<Mutex<HashMap<String, PrivateKey>>>,$/;"	m	struct:SecureVault
known_peers	src/network/discovery.rs	/^    known_peers: Arc<RwLock<HashSet<PeerId>>>,$/;"	m	struct:Discovery
last_prune_time	src/chain/shard.rs	/^    last_prune_time: Instant,$/;"	m	struct:Shard
last_refill	src/api/middleware/rate_limiter.rs	/^    last_refill: Instant,$/;"	m	struct:ClientBucket
last_seen	src/api/models/response/network_response.rs	/^    pub last_seen: u64, \/\/ Unix timestamp$/;"	m	struct:PeerInfo
latest_block_hash	src/qup/state.rs	/^    pub latest_block_hash: Hash,$/;"	m	struct:QUPState
latest_block_height	src/qup/state.rs	/^    pub latest_block_height: u64,$/;"	m	struct:QUPState
learning_rate	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    learning_rate: f64,$/;"	m	struct:IncrementalLearningHDCModel
learning_rate	src/hdcmodels/continuous_learning/online_learning.rs	/^    learning_rate: f64,$/;"	m	struct:OnlineLearningHDCModel
leaves	src/utils/merkle_tree.rs	/^    leaves: Vec<Hash>,$/;"	m	struct:MerkleTree
len	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub fn len(&self) -> usize {$/;"	P	implementation:Dataset
len	src/hdcmodels/parallel_processing.rs	/^    fn len(&self) -> usize {$/;"	P	implementation:Dataset
len	src/hdcmodels/parallel_processing.rs	/^    fn len(&self) -> usize;$/;"	P	interface:DatasetExt
len	src/mining/transaction_pool.rs	/^    pub fn len(&self) -> usize {$/;"	P	implementation:TransactionPool
levels	src/zkp/crypto.rs	/^    levels: Vec<Vec<FieldElement>>,$/;"	m	struct:QuantumResistantMerkleTree
lib	src/network/mod.rs	/^mod lib;$/;"	n
lib	src/smart_contract/mod.rs	/^mod lib;/;"	n
lib	src/zkp/mod.rs	/^mod lib;/;"	n
listen	src/network/network_manager.rs	/^    async fn listen(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
listen_addr	src/api/handlers/network_handler.rs	/^    listen_addr: String,$/;"	m	struct:NetworkConfig
listen_addr	src/api/models/request/network_request.rs	/^    pub listen_addr: Option<String>,$/;"	m	struct:UpdateNetworkConfigRequest
listen_addr	src/api/models/request/network_request.rs	/^    pub listen_addr: String,$/;"	m	struct:NetworkConfig
listen_addr	src/api/models/response/network_response.rs	/^    pub listen_addr: String,$/;"	m	struct:NetworkConfig
listen_addr	src/api/routes/network.rs	/^    listen_addr: String,$/;"	m	struct:NetworkConfig
listen_address	src/network/config.rs	/^    pub listen_address: String,$/;"	m	struct:NetworkConfig
load	src/chain/governance/proposal.rs	/^    pub async fn load(id: u64, storage: &Arc<ProposalStorage>) -> Result<Self, GovernanceError> /;"	P	implementation:Proposal
load	src/chain/storage/snapshot.rs	/^    pub fn load(path: &Path) -> Result<Self, SnapshotError> {$/;"	P	implementation:Snapshot
load	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub fn load(id: &str) -> Self {$/;"	P	implementation:Dataset
load_balancer	src/hdcmodels/distributed_training/load_balancing.rs	/^    load_balancer: T,$/;"	m	struct:LoadBalancedDistributedTrainingAggregator
load_client_config	src/network/tls_config.rs	/^pub fn load_client_config(cert_path: &str, post_quantum_cert_path: &str) -> Result<Arc<ClientCon/;"	f
load_dataset	src/datasets/mod.rs	/^pub fn load_dataset(block_id: u64) -> Result<(Vec<String>, Vec<String>), DatasetError> {$/;"	f
load_natural_language_descriptions	src/datasets/mod.rs	/^fn load_natural_language_descriptions(block_id: u64) -> Result<Vec<String>, DatasetError> {$/;"	f
load_pretrained_hdc_model	src/hdcmodels/model_integration/transfer_learning.rs	/^pub fn load_pretrained_hdc_model(model_path: &str) -> HDCModel {$/;"	f
load_pretrained_model	src/hdcmodels/model_integration/transfer_learning.rs	/^    pub fn load_pretrained_model(model_path: &str) -> nn::Sequential {$/;"	P	implementation:TransferLearningModel
load_rust_code_snippets	src/datasets/mod.rs	/^fn load_rust_code_snippets(block_id: u64) -> Result<Vec<String>, DatasetError> {$/;"	f
load_server_config	src/network/tls_config.rs	/^pub fn load_server_config(cert_path: &str, key_path: &str, post_quantum_cert_path: &str) -> Resu/;"	f
load_text_file	src/datasets/mod.rs	/^fn load_text_file(file_path: &str) -> Result<Vec<String>, DatasetError> {$/;"	f
lock_period	src/chain/governance/staking.rs	/^    pub lock_period: u64,$/;"	m	struct:Staking
log_error	src/error_handling/error_reporter.rs	/^    fn log_error<E: fmt::Display>(&self, error: E, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
loop_cost	src/smart_contract/gas.rs	/^    pub loop_cost: u64,$/;"	m	struct:GasCost
loss	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub loss: f32,$/;"	m	struct:EvaluationResult
main	src/main.rs	/^async fn main() {$/;"	f
manage_channels_optimized	src/chain/state_channel.rs	/^    pub async fn manage_channels_optimized(&mut self, blockchain: Arc<RwLock<Blockchain>>) {$/;"	P	implementation:ChannelManagerOptimized
master_key	src/secure_core/secure_vault.rs	/^    master_key: Arc<GenericArray<u8, typenum::U32>>,$/;"	m	struct:SecureVault
math	src/zkp/mod.rs	/^mod math;$/;"	n
max_audit_log_entries	src/secure_core/secure_vault.rs	/^    max_audit_log_entries: usize,$/;"	m	struct:SecureVault
max_connections	src/network/config.rs	/^    pub max_connections: usize,$/;"	m	struct:NetworkConfig
max_frame_size	src/network/config.rs	/^    pub max_frame_size: usize,$/;"	m	struct:NetworkConfig
max_inbound_peers	src/network/mod.rs	/^    max_inbound_peers: usize,$/;"	m	struct:Network
max_length	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    max_length: usize,$/;"	m	struct:Preprocessor
max_message_size	src/network/config.rs	/^    pub max_message_size: usize,$/;"	m	struct:NetworkConfig
max_peers	src/api/handlers/network_handler.rs	/^    max_peers: usize,$/;"	m	struct:NetworkConfig
max_peers	src/api/models/request/network_request.rs	/^    pub max_peers: Option<u32>,$/;"	m	struct:UpdateNetworkConfigRequest
max_peers	src/api/models/request/network_request.rs	/^    pub max_peers: u32,$/;"	m	struct:NetworkConfig
max_peers	src/api/models/response/network_response.rs	/^    pub max_peers: u32,$/;"	m	struct:NetworkConfig
max_peers	src/api/routes/network.rs	/^    max_peers: usize,$/;"	m	struct:NetworkConfig
max_peers	src/network/mod.rs	/^    max_peers: usize,$/;"	m	struct:Network
max_validity_period	src/chain/certificate_authority.rs	/^    pub max_validity_period: chrono::Duration,$/;"	m	struct:CertificateAuthorityConfig
measure	src/crypto/quantum_state.rs	/^    fn measure(&self, qubit: usize) -> Result<bool> {$/;"	P	implementation:TimeBinState
measure	src/crypto/quantum_state.rs	/^    fn measure(&self, qubit: usize) -> Result<bool>;$/;"	P	interface:QuantumState
measure	src/crypto/quantum_state.rs	/^    pub fn measure(&self, node: usize, time_bin: usize) -> Result<bool> {$/;"	P	implementation:TimeBinState
measure_candidate_register	src/chain/quantum_voting/quantum_state_decoding.rs	/^    fn measure_candidate_register($/;"	P	implementation:QuantumStateDecoding
measure_entanglement_quality	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn measure_entanglement_quality($/;"	P	implementation:EntanglementDistillation
measure_quantum_state	src/chain/quantum_voting/quantum_state_preparation.rs	/^    fn measure_quantum_state($/;"	P	implementation:QuantumStatePreparation
measure_quantum_state	src/chain/quantum_voting/utils.rs	/^pub fn measure_quantum_state(state: &QuantumState) -> Result<QuantumMeasurement, VotingError> {$/;"	f
measure_quantum_state	src/network/network_manager.rs	/^    pub async fn measure_quantum_state(&self, state_id: String) -> Result<QuantumStateMeasuremen/;"	P	implementation:NetworkManager
measure_vote_register	src/chain/quantum_voting/quantum_state_decoding.rs	/^    fn measure_vote_register($/;"	P	implementation:QuantumStateDecoding
merge_state	src/chain/shard.rs	/^    fn merge_state(&self, transactions: &mut VecDeque<Vec<u8>>, other_state: ShardState) {$/;"	P	implementation:Shard
merge_trained_models	src/hdcmodels/parallel_processing.rs	/^    fn merge_trained_models(&self, trained_models: Vec<Vec<Vec<f64>>>) -> Vec<Vec<f64>> {$/;"	P	implementation:ParallelHDCTrainer
merkle_proof	src/zkp/zk_starks.rs	/^    pub merkle_proof: Vec<FieldElement>,$/;"	m	struct:FriQueryRoundProof
merkle_root	src/api/models/request/blockchain_request.rs	/^    pub merkle_root: String,$/;"	m	struct:BlockHeader
merkle_root	src/api/models/response/blockchain_response.rs	/^    pub merkle_root: String,$/;"	m	struct:BlockHeader
merkle_root	src/chain/block.rs	/^    pub merkle_root: String,$/;"	m	struct:Block
merkle_root	src/qup/types.rs	/^    pub merkle_root: Hash,$/;"	m	struct:QUPBlockHeader
merkle_trie	src/chain/state/mod.rs	/^mod merkle_trie;/;"	n
message	src/network/p2p/mod.rs	/^mod message;$/;"	n
message	src/network/p2p/mod.rs	/^pub mod message;$/;"	n
message	src/secure_core/quantum_resistant_signatures.rs	/^    pub message: Vec<u8>,$/;"	m	struct:QuantumResistantSignature
message_handler	src/chain/node.rs	/^    message_handler: Arc<NodeMessageHandler>,$/;"	m	struct:Node
message_handler	src/chain/state_channel.rs	/^    message_handler: Arc<StateChannelMessageHandler>,$/;"	m	struct:ChannelManagerOptimized
message_sender	src/chain/sharding.rs	/^    message_sender: Option<mpsc::Sender<(u64, ShardMessage)>>,$/;"	m	struct:Sharding
message_sender	src/network/network_manager.rs	/^    message_sender: mpsc::Sender<Message>,$/;"	m	struct:NetworkManager
message_sender	src/network/shard_message.rs	/^    message_sender: Option<Sender<(u64, ShardMessage)>>,$/;"	m	struct:ShardMessageHandler
message_timeout	src/network/config.rs	/^    pub message_timeout: Duration,$/;"	m	struct:NetworkConfig
message_type	src/network/node_message.rs	/^    pub fn message_type(&self) -> &str {$/;"	P	implementation:NodeMessage
metadata	src/optimization_problems/problem_solution.rs	/^    pub metadata: Option<String>,$/;"	m	struct:ProblemSolution
method	src/api/handlers/smart_contract_handler.rs	/^    method: String,$/;"	m	struct:CallRequest
method	src/api/routes/smart_contract.rs	/^    method: String,$/;"	m	struct:CallRequest
middleware	src/api/mod.rs	/^pub mod middleware;$/;"	n
min_length	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    min_length: usize,$/;"	m	struct:Preprocessor
mine	src/chain/block.rs	/^    pub fn mine(&mut self) -> Result<(), BlockError> {$/;"	P	implementation:Block
mine_block	src/chain/block.rs	/^    fn mine_block(&mut self) -> Result<(), BlockError> {$/;"	P	implementation:Block
mine_block	src/mining/miner.rs	/^    fn mine_block(&self, block_template: Block) -> Option<Block> {$/;"	P	implementation:Miner
miner	src/mining/mod.rs	/^mod miner;$/;"	n
minimum_stake	src/api/handlers/qup_handler.rs	/^    minimum_stake: u64,$/;"	m	struct:QUPParameters
minimum_stake	src/api/models/request/qup_request.rs	/^    pub minimum_stake: u64,$/;"	m	struct:QUPParameters
minimum_stake	src/api/models/response/qup_response.rs	/^    pub minimum_stake: u64,$/;"	m	struct:QUPParameters
minimum_stake	src/api/routes/consensus.rs	/^    minimum_stake: f64,$/;"	m	struct:QDPoSParameters
mining	src/main.rs	/^mod mining;$/;"	n
mining_config	src/mining/mod.rs	/^mod mining_config;/;"	n
mining_interval	src/mining/mining_config.rs	/^    mining_interval: u64,$/;"	m	struct:MiningConfig
mining_interval	src/mining/mining_config.rs	/^    pub fn mining_interval(&self) -> u64 {$/;"	P	implementation:MiningConfig
mining_thread	src/mining/miner.rs	/^    mining_thread: Option<thread::JoinHandle<()>>,$/;"	m	struct:Miner
missed_heartbeats	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    missed_heartbeats: usize,$/;"	m	struct:FaultTolerantDistributedTrainingNode
missed_heartbeats_threshold	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    missed_heartbeats_threshold: usize,$/;"	m	struct:FaultTolerantDistributedTrainingAggregator
missed_heartbeats_threshold	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    missed_heartbeats_threshold: usize,$/;"	m	struct:FaultTolerantDistributedTrainingNode
mock_retrieve_certificate	src/chain/certificate_authority.rs	/^    async fn mock_retrieve_certificate($/;"	P	implementation:CertificateAuthorityClient
model	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    model: HDCModel,$/;"	m	struct:IncrementalLearningHDCModel
model	src/hdcmodels/continuous_learning/online_learning.rs	/^    model: HDCModel,$/;"	m	struct:OnlineLearningHDCModel
model	src/hdcmodels/distributed_training/synchronization.rs	/^    model: Arc<RwLock<HDCModel>>,$/;"	m	struct:Synchronizer
model	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    model: HDCModel,$/;"	m	struct:GPUHDCModel
model	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^    model: HDCModel,$/;"	m	struct:OptimizedHDCModel
model	src/optimization_problems/hdc_code_generation/mod.rs	/^mod model;$/;"	n
model_id	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub model_id: String,$/;"	m	struct:HDCBenchmarkResult
model_id	src/hdcmodels/benchmarking/reporting.rs	/^    pub model_id: String,$/;"	m	struct:BenchmarkReport
model_id	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub model_id: String,$/;"	m	struct:SecureHDCModelUpdate
model_update	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub model_update: SecureHDCModelUpdate,$/;"	m	struct:SecureHDCModelUpdateProposal
model_update	src/hdcmodels/distributed_training/synchronization.rs	/^    pub model_update: Vec<f64>,$/;"	m	struct:ModelUpdateMessage
models	src/api/mod.rs	/^pub mod models;$/;"	n
models	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    models: Vec<HDCModel>,$/;"	m	struct:HDCBenchmarkSuite
monitor_consensus	src/hdcmodels/governance_integration/consensus_security.rs	/^    pub fn monitor_consensus(&self, state: &ConsensusState, message: &ConsensusMessage) -> bool /;"	P	implementation:ConsensusSecurityMonitor
mul	src/zkp/constraint_system.rs	/^    pub fn mul(lhs: Expression, rhs: Expression) -> Self {$/;"	P	implementation:Expression
mul	src/zkp/math.rs	/^    fn mul(self, other: Self) -> Self {$/;"	P	implementation:FieldElement
mul_assign	src/zkp/math.rs	/^    fn mul_assign(&mut self, other: Self) {$/;"	P	implementation:FieldElement
name	src/api/middleware/request_validator.rs	/^    name: String,$/;"	m	struct:RequestModel
name	src/api/models/request/smart_contract_request.rs	/^    pub name: String,$/;"	m	struct:ContractFunctionInput
name	src/smart_contract/types.rs	/^    pub name: String,$/;"	m	struct:SmartContract
natural_language_to_hdc	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn natural_language_to_hdc(text: &str, hdc_model: &HDCModel) -> Vec<f64> {$/;"	P	implementation:DataConverter
network	src/main.rs	/^mod network; \/\/ Networking and peer-to-peer communication$/;"	n
network_config	src/qup/config.rs	/^    pub network_config: NetworkConfig,$/;"	m	struct:QUPConfig
network_error	src/error_handling/mod.rs	/^pub(crate) mod network_error;/;"	n
network_manager	src/hdcmodels/distributed_training/synchronization.rs	/^    network_manager: Arc<NetworkManager>,$/;"	m	struct:Synchronizer
network_manager	src/network/mod.rs	/^mod network_manager;$/;"	n
network_routes	src/api/routes/network.rs	/^pub fn network_routes(cfg: &mut web::ServiceConfig) {$/;"	f
neural_network	src/hdcmodels/model_integration/hybrid_models.rs	/^    neural_network: nn::Sequential,$/;"	m	struct:HybridModel
neural_network_to_hdc	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn neural_network_to_hdc(tensors: &[Tensor], hdc_dimension: usize) -> Vec<Vec<f64>> {$/;"	P	implementation:DataConverter
new	src/api/middleware/authorization.rs	/^    pub fn new() -> Self {$/;"	P	implementation:AuthorizationMiddleware
new	src/api/middleware/rate_limiter.rs	/^    fn new() -> Self {$/;"	P	implementation:RateLimiter
new	src/api/middleware/rate_limiter.rs	/^    pub fn new() -> Self {$/;"	P	implementation:RateLimiterMiddleware
new	src/chain/blockchain.rs	/^    pub fn new($/;"	P	implementation:Blockchain
new	src/chain/certificate_authority.rs	/^    pub fn new($/;"	P	implementation:CertificateAuthority
new	src/chain/certificate_authority.rs	/^    pub fn new($/;"	P	implementation:CertificateAuthorityClient
new	src/chain/governance/governance_engine.rs	/^    pub fn new($/;"	P	implementation:GovernanceEngine
new	src/chain/governance/proposal.rs	/^    pub fn new($/;"	P	implementation:Proposal
new	src/chain/governance/rewards.rs	/^    pub fn new(initial_reward_pool: u64, reward_rate: f64) -> Self {$/;"	P	implementation:Rewards
new	src/chain/governance/staking.rs	/^    pub fn new(reward_rate: f64, lock_period: u64) -> Self {$/;"	P	implementation:Staking
new	src/chain/governance/treasury.rs	/^    pub fn new(initial_balance: u64) -> Self {$/;"	P	implementation:Treasury
new	src/chain/governance/voting.rs	/^    pub fn new(total_voting_power: u64, quorum: u64, threshold: u64) -> Self {$/;"	P	implementation:Voting
new	src/chain/node.rs	/^    pub async fn new($/;"	P	implementation:Node
new	src/chain/quantum_entropy.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumEntropySource
new	src/chain/quantum_entropy.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumResistantConnectionManager
new	src/chain/quantum_voting/entanglement_distillation.rs	/^    pub fn new() -> Self {$/;"	P	implementation:EntanglementDistillation
new	src/chain/quantum_voting/mod.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumVoting
new	src/chain/quantum_voting/quantum_communication.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumCommunication
new	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumCryptography
new	src/chain/quantum_voting/quantum_key_distribution.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumKeyDistribution
new	src/chain/quantum_voting/quantum_key_management.rs	/^    pub fn new(voting_state: Arc<VotingState>) -> Self {$/;"	P	implementation:QuantumKeyManagement
new	src/chain/quantum_voting/quantum_state_decoding.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumStateDecoding
new	src/chain/quantum_voting/quantum_state_encoding.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumStateEncoding
new	src/chain/quantum_voting/quantum_state_preparation.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumStatePreparation
new	src/chain/quantum_voting/quantum_state_verification.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumStateVerification
new	src/chain/quantum_voting/quantum_voting.rs	/^    pub fn new(voting_state: Arc<VotingState>) -> Self {$/;"	P	implementation:QuantumVoting
new	src/chain/quantum_voting/security_analysis.rs	/^    pub fn new(security_parameter: QuantumSecurityParameter) -> Self {$/;"	P	implementation:SecurityAnalysis
new	src/chain/quantum_voting/voting_protocols.rs	/^    pub fn new() -> Self {$/;"	P	implementation:VotingProtocols
new	src/chain/quantum_voting/voting_state.rs	/^    pub fn new() -> Self {$/;"	P	implementation:VotingState
new	src/chain/shard.rs	/^    pub fn new(shard_id: u64, total_shards: u64, encryption_key: EncryptionKey, consensus_config/;"	P	implementation:Shard
new	src/chain/sharding.rs	/^    pub fn new($/;"	P	implementation:Sharding
new	src/chain/state/account.rs	/^    pub fn new(address: String, balance: u64) -> Self {$/;"	P	implementation:Account
new	src/chain/state/merkle_trie.rs	/^    pub fn new() -> Self {$/;"	P	implementation:MerkleTrie
new	src/chain/state/merkle_trie.rs	/^    pub fn new(key: Arc<[u8]>, value: Option<Arc<[u8]>>) -> Self {$/;"	P	implementation:TrieNode
new	src/chain/state/state_db.rs	/^    pub fn new<P: AsRef<Path>>(path: P, qup_state: QUPState) -> Self {$/;"	P	implementation:StateDB
new	src/chain/state/state_manager.rs	/^    pub fn new(state_db: StateDB, qup_state: Arc<RwLock<QUPState>>) -> Self {$/;"	P	implementation:StateManager
new	src/chain/state/state_transition.rs	/^    pub fn new($/;"	P	implementation:StateTransition
new	src/chain/state_channel.rs	/^    pub fn new($/;"	P	implementation:ChannelManagerOptimized
new	src/chain/state_channel.rs	/^    pub fn new(id: String, party1: String, party2: String) -> Self {$/;"	P	implementation:StateChannelOptimized
new	src/chain/state_transition.rs	/^    pub fn new(state_manager: Arc<StateManager>) -> Self {$/;"	P	implementation:StateTransition
new	src/chain/storage/block_storage.rs	/^    pub fn new(db: Box<dyn Database>) -> Self {$/;"	P	implementation:BlockStorage
new	src/chain/storage/contract_storage.rs	/^    pub fn new(db: Box<dyn Database>) -> Self {$/;"	P	implementation:ContractStorage
new	src/chain/storage/database.rs	/^    pub fn new() -> Self {$/;"	P	implementation:MemoryDatabase
new	src/chain/storage/snapshot.rs	/^    pub fn new(block: Block, state: State) -> Self {$/;"	P	implementation:Snapshot
new	src/chain/validator/validator.rs	/^    pub fn new(address: Address, public_key: Vec<u8>, private_key: Vec<u8>) -> Self {$/;"	P	implementation:Validator
new	src/chain/wallet.rs	/^    pub fn new($/;"	P	implementation:Wallet
new	src/chain/wallet.rs	/^    pub fn new(spend_public_key: &[u8], view_key: &[u8]) -> Result<Self, WalletError> {$/;"	P	implementation:StealthAddress
new	src/crypto/quantum_state.rs	/^    pub fn new(num_nodes: usize, num_time_bins: usize) -> Self {$/;"	P	implementation:TimeBinState
new	src/crypto/quantum_state.rs	/^    pub fn new(re: f64, im: f64) -> Self {$/;"	P	implementation:Complex64
new	src/error_handling/error_reporter.rs	/^    pub fn new(sentry_dsn: Option<String>) -> Self {$/;"	P	implementation:ErrorReporter
new	src/hdcmodels/benchmark.rs	/^    pub fn new(state_manager: Arc<StateManager>) -> Self {$/;"	P	implementation:AccuracyBenchmark
new	src/hdcmodels/benchmarking/analysis.rs	/^    pub fn new(data_collector: BenchmarkDataCollector) -> Self {$/;"	P	implementation:BenchmarkAnalyzer
new	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub fn new(models: Vec<HDCModel>, datasets: Vec<Dataset>) -> Self {$/;"	P	implementation:HDCBenchmarkSuite
new	src/hdcmodels/benchmarking/data_collection.rs	/^    pub fn new(benchmark_suite: HDCBenchmarkSuite, peers: Vec<Peer>) -> Self {$/;"	P	implementation:BenchmarkDataCollector
new	src/hdcmodels/benchmarking/reporting.rs	/^    pub fn new(analyzer: BenchmarkAnalyzer, peers: Vec<Peer>) -> Self {$/;"	P	implementation:BenchmarkReporter
new	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    pub fn new(model: HDCModel, learning_rate: f64, similarity_threshold: f64) -> Self {$/;"	P	implementation:IncrementalLearningHDCModel
new	src/hdcmodels/continuous_learning/online_learning.rs	/^    pub fn new(model: HDCModel, learning_rate: f64, adaptation_threshold: f64) -> Self {$/;"	P	implementation:OnlineLearningHDCModel
new	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub fn new(model_id: String, updated_model: HDCModel, private_key: &[u8]) -> Self {$/;"	P	implementation:SecureHDCModelUpdate
new	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub fn new(proposal_id: String, voter: String, vote: bool, private_key: &[u8]) -> Self {$/;"	P	implementation:SecureHDCModelUpdateVote
new	src/hdcmodels/distributed_training/distributed_framework.rs	/^    pub async fn new($/;"	P	implementation:DistributedTrainingAggregator
new	src/hdcmodels/distributed_training/distributed_framework.rs	/^    pub async fn new($/;"	P	implementation:DistributedTrainingNode
new	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    pub async fn new($/;"	P	implementation:FaultTolerantDistributedTrainingAggregator
new	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    pub async fn new($/;"	P	implementation:FaultTolerantDistributedTrainingNode
new	src/hdcmodels/distributed_training/load_balancing.rs	/^    pub fn new(node: DistributedTrainingAggregator, load_balancer: T) -> Self {$/;"	P	implementation:LoadBalancedDistributedTrainingAggregator
new	src/hdcmodels/distributed_training/load_balancing.rs	/^    pub fn new(node_capacities: Vec<f64>) -> Self {$/;"	P	implementation:ComputeCapacityLoadBalancer
new	src/hdcmodels/distributed_training/synchronization.rs	/^    pub fn new(network_manager: Arc<NetworkManager>, model: Arc<RwLock<HDCModel>>) -> Self {$/;"	P	implementation:Synchronizer
new	src/hdcmodels/governance_integration/consensus_security.rs	/^    pub fn new(hdc_model: HDCModel, anomaly_threshold: f64) -> Self {$/;"	P	implementation:ConsensusSecurityMonitor
new	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    pub fn new(hdc_model: HDCModel) -> Self {$/;"	P	implementation:ProposalAnalyzer
new	src/hdcmodels/hdcmodels.rs	/^    pub fn new() -> Self {$/;"	P	implementation:Dataset
new	src/hdcmodels/hdcmodels.rs	/^    pub fn new(similarity_metric: SimilarityMetric) -> Self {$/;"	P	implementation:HDCModel
new	src/hdcmodels/mod.rs	/^    pub fn new(similarity_metric: SimilarityMetric) -> Self {$/;"	P	implementation:HDCModel
new	src/hdcmodels/model_integration/hybrid_models.rs	/^    pub fn new($/;"	P	implementation:HybridModel
new	src/hdcmodels/model_integration/transfer_learning.rs	/^    pub fn new(hdc_model: HDCModel, pretrained_model: nn::Sequential) -> Self {$/;"	P	implementation:TransferLearningModel
new	src/hdcmodels/parallel_processing.rs	/^    pub fn new(num_threads: usize) -> Self {$/;"	P	implementation:ParallelHDCInference
new	src/hdcmodels/parallel_processing.rs	/^    pub fn new(num_threads: usize) -> Self {$/;"	P	implementation:ParallelHDCTrainer
new	src/hdcmodels/parallel_processing.rs	/^    pub fn new(num_threads: usize) -> Self {$/;"	P	implementation:ParallelHDCValidator
new	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    pub fn new(model: HDCModel) -> Self {$/;"	P	implementation:GPUHDCModel
new	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^    pub fn new(model: HDCModel) -> Self {$/;"	P	implementation:OptimizedHDCModel
new	src/hdcmodels/performance_optimization/profiling.rs	/^    pub fn new() -> Self {$/;"	P	implementation:Profiler
new	src/hdcmodels/qup_integration/qup_decoding.rs	/^    pub fn new(qup_crypto: QUPCrypto) -> Self {$/;"	P	implementation:QUPDecoding
new	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn new(qup_crypto: QUPCrypto) -> Self {$/;"	P	implementation:QUPEncoding
new	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn new(scheme: QuantumErrorCorrectionScheme) -> Self {$/;"	P	implementation:QUPErrorCorrection
new	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    pub fn new($/;"	P	implementation:SmartContractGenerator
new	src/hdcmodels/smart_contract_generation/optimization.rs	/^    pub fn new(optimizer: QuantumSecureOptimizer) -> Self {$/;"	P	implementation:SmartContractOptimizer
new	src/hdcmodels/smart_contract_generation/specification_encoding.rs	/^    pub fn new(hdc_model: HDCModel) -> Self {$/;"	P	implementation:SmartContractSpecEncoder
new	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn new(hdc_model: HDCModel, optimizer: QuantumSecureOptimizer) -> Self {$/;"	P	implementation:TransactionOptimizer
new	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub fn new(hdc_model: HDCModel) -> Self {$/;"	P	implementation:TransactionEncoder
new	src/mining/block_producer.rs	/^    pub fn new(blockchain: Arc<Mutex<Blockchain>>, config: MiningConfig) -> Self {$/;"	P	implementation:BlockProducer
new	src/mining/miner.rs	/^    pub fn new($/;"	P	implementation:Miner
new	src/mining/mining_config.rs	/^    pub fn new() -> Self {$/;"	P	implementation:MiningConfig
new	src/mining/transaction_pool.rs	/^    pub fn new(capacity: usize) -> Self {$/;"	P	implementation:TransactionPool
new	src/network/client.rs	/^    pub fn new(peer_address: String, handler: Arc<dyn Handler>, crypto: Arc<QUPCrypto>) -> Self /;"	P	implementation:Client
new	src/network/config.rs	/^    pub fn new(listen_address: String, bootstrap_nodes: Vec<String>) -> Self {$/;"	P	implementation:NetworkConfig
new	src/network/discovery.rs	/^    pub fn new($/;"	P	implementation:Discovery
new	src/network/handler.rs	/^    pub fn new() -> Self {$/;"	P	implementation:HandlerImpl
new	src/network/lib.rs	/^    pub fn new(config: NetworkConfig, handler: Arc<dyn Handler>) -> Result<Self, NetworkError> {$/;"	P	implementation:Network
new	src/network/mod.rs	/^    pub fn new(config: &NetworkConfig, consensus: Arc<dyn Consensus>) -> Self {$/;"	P	implementation:Network
new	src/network/network_manager.rs	/^    pub fn new($/;"	P	implementation:NetworkManager
new	src/network/node_message.rs	/^    pub fn new(crypto: QUPCrypto) -> Self {$/;"	P	implementation:NodeMessageHandler
new	src/network/p2p/peer.rs	/^    pub async fn new(address: String, stream: TLSStream) -> Result<Self, PeerError> {$/;"	P	implementation:Peer
new	src/network/quantum_resistant.rs	/^    fn new(stream: TcpStream, shared_secret: SecretKey) -> Self {$/;"	P	implementation:QuantumChannel
new	src/network/quantum_resistant.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QuantumResistantConnection
new	src/network/server.rs	/^    pub fn new(address: String, handler: Arc<dyn Handler>, crypto: Arc<QUPCrypto>) -> Self {$/;"	P	implementation:Server
new	src/network/shard_message.rs	/^    pub fn new(crypto: QUPCrypto) -> Self {$/;"	P	implementation:ShardMessageHandler
new	src/network/sync/state_sync.rs	/^    pub fn new(consensus: Arc<dyn Consensus>, signature_scheme: SignatureScheme) -> Self {$/;"	P	implementation:StateSync
new	src/network/tls.rs	/^    pub async fn new(stream: TcpStream) -> Result<Self, TLSError> {$/;"	P	implementation:PostQuantumTLSConnection
new	src/network/tls.rs	/^    pub fn new() -> Self {$/;"	P	implementation:PostQuantumTLSConfig
new	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub fn new() -> Self {$/;"	P	implementation:CodeDataset
new	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub fn new(dataset: &'a CodeDataset, preprocessor: Preprocessor) -> Self {$/;"	P	implementation:Evaluator
new	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    pub fn new(max_length: usize, min_length: usize) -> Self {$/;"	P	implementation:Preprocessor
new	src/optimization_problems/problem_solution.rs	/^    pub fn new(solution_data: Vec<u8>, objective_value: f64, metadata: Option<String>) -> Self {$/;"	P	implementation:ProblemSolution
new	src/quantum_entropy/config.rs	/^    pub fn new() -> Self {$/;"	P	implementation:QRNGConfig
new	src/quantum_entropy/qrng.rs	/^    pub fn new(config: &QRNGConfig) -> Result<Self, QRNGError> {$/;"	P	implementation:QuantumEntropy
new	src/qup/block.rs	/^    pub fn new($/;"	P	implementation:QUPBlock
new	src/qup/config.rs	/^    pub fn new($/;"	P	implementation:QUPConfig
new	src/qup/consensus.rs	/^    pub fn new(config: Arc<QUPConfig>, state: Arc<QUPState>, key_pair: QUPKeyPair) -> Self {$/;"	P	implementation:QUPConsensus
new	src/qup/crypto.rs	/^    pub fn new(config: Arc<QUPConfig>) -> Self {$/;"	P	implementation:QUPCrypto
new	src/qup/delegator.rs	/^    pub fn new(address: Address, config: Arc<QUPConfig>, state: Arc<QUPState>) -> Self {$/;"	P	implementation:QUPDelegator
new	src/qup/hdcomm.rs	/^    pub fn new(config: Arc<QUPConfig>) -> Self {$/;"	P	implementation:HDCommunication
new	src/qup/reward.rs	/^    pub fn new(config: QUPConfig) -> Self {$/;"	P	implementation:RewardDistributor
new	src/qup/state.rs	/^    pub fn new(config: Arc<QUPConfig>) -> Self {$/;"	P	implementation:QUPState
new	src/qup/validator.rs	/^    pub fn new($/;"	P	implementation:QUPValidator
new	src/secure_core/access_control.rs	/^    pub fn new() -> Self {$/;"	P	implementation:AccessControl
new	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn new(secure_vault: Arc<SecureVault>) -> Self {$/;"	P	implementation:QuantumResistantSigner
new	src/secure_core/secure_communication.rs	/^    pub fn new(secure_vault: Arc<SecureVault>) -> Self {$/;"	P	implementation:SecureCommunication
new	src/secure_core/secure_storage.rs	/^    pub fn new(secure_vault: Arc<SecureVault>) -> Self {$/;"	P	implementation:SecureStorage
new	src/secure_core/secure_vault.rs	/^    pub fn new(max_audit_log_entries: usize, master_key: &[u8; 32]) -> Self {$/;"	P	implementation:SecureVault
new	src/smart_contract/execution_context.rs	/^    pub fn new(gas_limit: u64) -> Self {$/;"	P	implementation:ExecutionContext
new	src/smart_contract/interpreter.rs	/^    pub fn new(gas_cost: GasCost) -> Self {$/;"	P	implementation:Interpreter
new	src/types/address.rs	/^    pub fn new(bytes: Vec<u8>) -> Self {$/;"	P	implementation:Address
new	src/types/block_reward.rs	/^    pub fn new(amount: u64, recipient: Address) -> Self {$/;"	P	implementation:BlockReward
new	src/utils/indexing.rs	/^    pub fn new() -> Self {$/;"	P	implementation:BalanceManager
new	src/utils/indexing.rs	/^    pub fn new() -> Self {$/;"	P	implementation:BlockchainIndexer
new	src/utils/indexing.rs	/^    pub fn new() -> Self {$/;"	P	implementation:TransactionIndex
new	src/utils/merkle_tree.rs	/^    pub fn new(transactions: &[QUPTransaction]) -> Result<Self, MerkleTreeError> {$/;"	P	implementation:MerkleTree
new	src/utils/node_id.rs	/^    pub fn new() -> Self {$/;"	P	implementation:NodeId
new	src/zephyrchain_circuit.rs	/^    fn new(trace_length: usize, public_inputs: Self::PublicInputs, options: ProofOptions) -> Sel/;"	P	implementation:ZephyrChainCircuit
new	src/zkp/constraint_system.rs	/^    fn new() -> Self {$/;"	P	implementation:ConstraintSystemImpl
new	src/zkp/constraint_system.rs	/^    fn new() -> Self;$/;"	P	interface:ConstraintSystem
new	src/zkp/constraint_system.rs	/^    pub fn new(a: Expression, b: Expression) -> Self {$/;"	P	implementation:EqualsConstraint
new	src/zkp/constraint_system.rs	/^    pub fn new(variable: Variable, bitwidth: usize) -> Self {$/;"	P	implementation:RangeConstraint
new	src/zkp/crypto.rs	/^    fn new() -> Self {$/;"	P	implementation:Blake3bHasher
new	src/zkp/crypto.rs	/^    fn new() -> Self;$/;"	P	interface:Hasher
new	src/zkp/crypto.rs	/^    pub fn new(leaves: &[FieldElement]) -> Self {$/;"	P	implementation:QuantumResistantMerkleTree
new	src/zkp/math.rs	/^    pub fn new(coefficients: Vec<FieldElement>) -> Self {$/;"	P	implementation:PolynomialCommitment
new	src/zkp/math.rs	/^    pub fn new(value: BigUint, modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
new	src/zkp/zk_starks.rs	/^    pub fn new(security_level: usize, num_queries: usize, field_size: FieldElement) -> Self {$/;"	P	implementation:ZkStarksVerifier
new_transform	src/api/middleware/authorization.rs	/^    fn new_transform(&self, service: S) -> Self::Future {$/;"	f
new_transform	src/api/middleware/rate_limiter.rs	/^    fn new_transform(&self, service: S) -> Self::Future {$/;"	f
new_transform	src/api/middleware/request_validator.rs	/^    fn new_transform(&self, service: S) -> Self::Future {$/;"	f
node	src/chain/mod.rs	/^pub(crate) mod node;$/;"	n
node	src/hdcmodels/distributed_training/distributed_framework.rs	/^    node: Node,$/;"	m	struct:DistributedTrainingAggregator
node	src/hdcmodels/distributed_training/distributed_framework.rs	/^    node: Node,$/;"	m	struct:DistributedTrainingNode
node	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    node: DistributedTrainingAggregator,$/;"	m	struct:FaultTolerantDistributedTrainingAggregator
node	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    node: DistributedTrainingNode,$/;"	m	struct:FaultTolerantDistributedTrainingNode
node	src/hdcmodels/distributed_training/load_balancing.rs	/^    node: DistributedTrainingAggregator,$/;"	m	struct:LoadBalancedDistributedTrainingAggregator
node_capacities	src/hdcmodels/distributed_training/load_balancing.rs	/^    node_capacities: Vec<f64>,$/;"	m	struct:ComputeCapacityLoadBalancer
node_heartbeats	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    node_heartbeats: HashMap<usize, usize>,$/;"	m	struct:FaultTolerantDistributedTrainingAggregator
node_id	src/chain/node.rs	/^    pub node_id: NodeId,$/;"	m	struct:NodeConfig
node_id	src/hdcmodels/benchmarking/data_collection.rs	/^    pub node_id: String,$/;"	m	struct:BenchmarkData
node_id	src/utils/mod.rs	/^pub(crate) mod node_id;$/;"	n
node_message	src/network/mod.rs	/^mod node_message;$/;"	n
nonce	src/api/models/request/blockchain_request.rs	/^    pub nonce: u64,$/;"	m	struct:BlockHeader
nonce	src/api/models/response/blockchain_response.rs	/^    pub nonce: u64,$/;"	m	struct:BlockHeader
nonce	src/chain/block.rs	/^    pub nonce: u64,$/;"	m	struct:Block
nonce	src/chain/state/account.rs	/^    pub nonce: u64,$/;"	m	struct:Account
nonce	src/chain/transaction.rs	/^    pub nonce: u64,$/;"	m	struct:Transaction
nonce	src/qup/types.rs	/^    pub nonce: u64,$/;"	m	struct:QUPBlockHeader
nonce	src/secure_core/secure_communication.rs	/^    pub nonce: Vec<u8>,$/;"	m	struct:SecureMessage
nonce	src/secure_core/secure_storage.rs	/^    pub nonce: Vec<u8>,$/;"	m	struct:EncryptedData
norm_sqr	src/crypto/quantum_state.rs	/^    pub fn norm_sqr(&self) -> f64 {$/;"	P	implementation:Complex64
notify_anomaly	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn notify_anomaly(&self, state: &ConsensusState, message: &ConsensusMessage) {$/;"	P	implementation:ConsensusSecurityMonitor
num_nodes	src/crypto/quantum_state.rs	/^    num_nodes: usize,$/;"	m	struct:TimeBinState
num_nodes	src/crypto/quantum_state.rs	/^    pub fn num_nodes(&self) -> usize {$/;"	P	implementation:TimeBinState
num_nodes	src/hdcmodels/distributed_training/distributed_framework.rs	/^    num_nodes: usize,$/;"	m	struct:DistributedTrainingAggregator
num_qubits	src/crypto/quantum_state.rs	/^    fn num_qubits(&self) -> usize {$/;"	P	implementation:TimeBinState
num_qubits	src/crypto/quantum_state.rs	/^    fn num_qubits(&self) -> usize;$/;"	P	interface:QuantumState
num_queries	src/zkp/zk_starks.rs	/^    pub num_queries: usize,$/;"	m	struct:ZkStarksVerifier
num_representatives	src/chain/quantum_voting/voting_state.rs	/^    num_representatives: usize,$/;"	m	struct:VotingState
num_threads	src/hdcmodels/parallel_processing.rs	/^    num_threads: usize,$/;"	m	struct:ParallelHDCInference
num_threads	src/hdcmodels/parallel_processing.rs	/^    num_threads: usize,$/;"	m	struct:ParallelHDCTrainer
num_threads	src/hdcmodels/parallel_processing.rs	/^    num_threads: usize,$/;"	m	struct:ParallelHDCValidator
num_time_bins	src/crypto/quantum_state.rs	/^    num_time_bins: usize,$/;"	m	struct:TimeBinState
num_time_bins	src/crypto/quantum_state.rs	/^    pub fn num_time_bins(&self) -> usize {$/;"	P	implementation:TimeBinState
objective_value	src/optimization_problems/problem_solution.rs	/^    pub objective_value: f64,$/;"	m	struct:ProblemSolution
off_chain_transactions	src/chain/state_channel.rs	/^    pub off_chain_transactions: VecDeque<OffChainTransaction>,$/;"	m	struct:StateChannelOptimized
one	src/zkp/math.rs	/^    pub fn one(modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
op_cost	src/smart_contract/gas.rs	/^    pub op_cost: u64,$/;"	m	struct:GasCost
optimization_problem	src/optimization_problems/mod.rs	/^mod optimization_problem;$/;"	n
optimization_problems	src/main.rs	/^mod optimization_problems; \/\/ Optimization problems for PoUW consensus$/;"	n
optimize_code	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    fn optimize_code(&self, code: &str) -> String {$/;"	P	implementation:SmartContractGenerator
optimize_code	src/hdcmodels/smart_contract_generation/optimization.rs	/^    pub fn optimize_code(&self, code: &str) -> String {$/;"	P	implementation:SmartContractOptimizer
optimize_execution_efficiency	src/hdcmodels/smart_contract_generation/optimization.rs	/^    fn optimize_execution_efficiency(&self, code: &str) -> String {$/;"	P	implementation:SmartContractOptimizer
optimize_execution_efficiency	src/hdcmodels/smart_contract_generation/optimization.rs	/^    pub fn optimize_execution_efficiency(&self, code: &str) -> String {$/;"	P	implementation:QuantumSecureOptimizer
optimize_hyperparameters	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^pub fn optimize_hyperparameters(model: &mut HDCModel, data: &[Vec<f64>], labels: &[String]) {$/;"	f
optimize_quantum_state	src/chain/quantum_voting/compression.rs	/^    fn optimize_quantum_state($/;"	P	implementation:Compression
optimize_quantum_state	src/chain/quantum_voting/quantum_voting.rs	/^    fn optimize_quantum_state($/;"	P	implementation:QuantumVoting
optimize_resource_utilization	src/hdcmodels/smart_contract_generation/optimization.rs	/^    fn optimize_resource_utilization(&self, code: &str) -> String {$/;"	P	implementation:SmartContractOptimizer
optimize_resource_utilization	src/hdcmodels/smart_contract_generation/optimization.rs	/^    pub fn optimize_resource_utilization(&self, code: &str) -> String {$/;"	P	implementation:QuantumSecureOptimizer
optimize_security_hardening	src/hdcmodels/smart_contract_generation/optimization.rs	/^    fn optimize_security_hardening(&self, code: &str) -> String {$/;"	P	implementation:SmartContractOptimizer
optimize_security_hardening	src/hdcmodels/smart_contract_generation/optimization.rs	/^    pub fn optimize_security_hardening(&self, code: &str) -> String {$/;"	P	implementation:QuantumSecureOptimizer
optimize_state_transition	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn optimize_state_transition(&self, state_transition: &StateTransition) -> StateTransiti/;"	P	implementation:TransactionOptimizer
optimize_transaction	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    pub fn optimize_transaction(&self, transaction: &Transaction) -> Transaction {$/;"	P	implementation:TransactionOptimizer
optimizer	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    optimizer: QuantumSecureOptimizer,$/;"	m	struct:SmartContractGenerator
optimizer	src/hdcmodels/smart_contract_generation/optimization.rs	/^    optimizer: QuantumSecureOptimizer,$/;"	m	struct:SmartContractOptimizer
optimizer	src/hdcmodels/transaction_optimization/optimization_techniques.rs	/^    optimizer: QuantumSecureOptimizer,$/;"	m	struct:TransactionOptimizer
outgoing_messages	src/chain/shard.rs	/^    pub outgoing_messages: Sender<NetworkMessage>,$/;"	m	struct:Shard
outgoing_peers	src/api/handlers/network_handler.rs	/^    outgoing_peers: usize,$/;"	m	struct:NetworkStats
outgoing_peers	src/api/models/response/network_response.rs	/^    pub outgoing_peers: usize,$/;"	m	struct:NetworkStats
outgoing_peers	src/api/routes/network.rs	/^    outgoing_peers: usize,$/;"	m	struct:NetworkStats
p2p	src/network/lib.rs	/^pub mod p2p;$/;"	n
pad	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    fn pad(&self, snippet: &str) -> String {$/;"	P	implementation:Preprocessor
parallel	src/main.rs	/^mod parallel; \/\/ Zero-knowledge proof library$/;"	n
parallel_constraint_evaluation	src/constraint_system.rs	/^fn parallel_constraint_evaluation(constraints: &[Constraint], witness: &Witness) -> Result<Evalu/;"	f
parallel_fft	src/utils/fft.rs	/^fn parallel_fft(input: &[BaseElement], len: usize) -> Result<Vec<Complex<BaseElement>>, String> /;"	f
parallel_filter	src/parallel/parallel_map.rs	/^pub fn parallel_filter<T, F>(input: &[T], predicate: F) -> Vec<T>$/;"	f
parallel_filter_map	src/parallel/parallel_map.rs	/^pub fn parallel_filter_map<T, U, F>(input: &[T], func: F) -> Vec<U>$/;"	f
parallel_flat_map	src/parallel/parallel_map.rs	/^pub fn parallel_flat_map<T, U, F>(input: &[T], func: F) -> Vec<U>$/;"	f
parallel_fold	src/parallel/parallel_map.rs	/^pub fn parallel_fold<T, U, F>(input: &[T], init: U, func: F) -> U$/;"	f
parallel_map	src/parallel/mod.rs	/^pub(crate) mod parallel_map;/;"	n
parallel_map	src/parallel/parallel_map.rs	/^pub fn parallel_map<T, U, F>(input: &[T], func: F) -> Vec<U>$/;"	f
parallel_map_mut	src/parallel/parallel_map.rs	/^pub fn parallel_map_mut<T, F>(input: &mut [T], func: F)$/;"	f
parallel_reduce	src/parallel/parallel_map.rs	/^pub fn parallel_reduce<T, F>(input: &[T], func: F) -> Option<T>$/;"	f
parse_contract	src/smart_contract/parser.rs	/^    pub fn parse_contract(code: &str) -> Result<Vec<Operation>, String> {$/;"	P	implementation:Parser
parse_expression	src/smart_contract/parser.rs	/^    fn parse_expression(expr: &str) -> Result<Expression, String> {$/;"	P	implementation:Parser
parse_operation	src/smart_contract/parser.rs	/^    fn parse_operation(line: &str) -> Result<Option<Operation>, String> {$/;"	P	implementation:Parser
parser	src/smart_contract/lib.rs	/^pub mod parser;$/;"	n
parser	src/smart_contract/mod.rs	/^mod parser;$/;"	n
participate_in_consensus	src/chain/validator/validator.rs	/^    pub fn participate_in_consensus(&self, state: &State, consensus: &mut dyn Consensus) {$/;"	P	implementation:Validator
parties	src/chain/state_channel.rs	/^    pub parties: [String; 2],$/;"	m	struct:StateChannelOptimized
partition_data	src/hdcmodels/distributed_training/distributed_framework.rs	/^    fn partition_data(&self, dataset: Dataset, num_partitions: usize) -> Vec<Dataset> {$/;"	P	implementation:DistributedTrainingAggregator
partition_data	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn partition_data(&self, dataset: Dataset, num_nodes: usize) -> Vec<Dataset> {$/;"	P	implementation:ComputeCapacityLoadBalancer
partition_data	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn partition_data(&self, dataset: Dataset, num_nodes: usize) -> Vec<Dataset> {$/;"	P	implementation:DataSizeLoadBalancer
partition_data	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn partition_data(&self, dataset: Dataset, num_nodes: usize) -> Vec<Dataset> {$/;"	P	implementation:RoundRobinLoadBalancer
partition_data	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn partition_data(&self, dataset: Dataset, num_nodes: usize) -> Vec<Dataset>;$/;"	P	interface:LoadBalancer
partition_data	src/hdcmodels/parallel_processing.rs	/^    fn partition_data(&self, dataset: &Dataset) -> Vec<Dataset> {$/;"	P	implementation:ParallelHDCTrainer
partition_data	src/hdcmodels/parallel_processing.rs	/^    fn partition_data(&self, dataset: &Dataset) -> Vec<Dataset> {$/;"	P	implementation:ParallelHDCValidator
peer	src/network/client.rs	/^    peer: Arc<Peer>,$/;"	m	struct:Client
peer	src/network/p2p/mod.rs	/^pub mod peer;$/;"	n
peer_address	src/api/models/request/network_request.rs	/^    pub peer_address: String,$/;"	m	struct:ConnectPeerRequest
peer_channel	src/network/mod.rs	/^    peer_channel: (Sender<Message>, Receiver<Message>),$/;"	m	struct:Network
peer_id	src/api/models/request/network_request.rs	/^    pub peer_id: String,$/;"	m	struct:BanPeerRequest
peer_id	src/api/models/request/network_request.rs	/^    pub peer_id: String,$/;"	m	struct:DisconnectPeerRequest
peers	src/api/models/response/network_response.rs	/^    pub peers: Vec<PeerInfo>,$/;"	m	struct:GetPeersResponse
peers	src/hdcmodels/benchmarking/data_collection.rs	/^    pub peers: Vec<Peer>,$/;"	m	struct:BenchmarkDataCollector
peers	src/hdcmodels/benchmarking/reporting.rs	/^    peers: Vec<Peer>,$/;"	m	struct:BenchmarkReporter
peers	src/network/mod.rs	/^    peers: RwLock<HashMap<String, Peer>>,$/;"	m	struct:Network
peers	src/network/network_manager.rs	/^    peers: Arc<RwLock<HashMap<String, Peer>>>,$/;"	m	struct:NetworkManager
peers	src/network/server.rs	/^    peers: Arc<Mutex<HashMap<String, Peer>>>,$/;"	m	struct:Server
perform_distillation	src/chain/quantum_voting/entanglement_distillation.rs	/^    pub fn perform_distillation($/;"	P	implementation:EntanglementDistillation
perform_eavesdropping_detection	src/chain/quantum_voting/security_analysis.rs	/^    fn perform_eavesdropping_detection($/;"	P	implementation:SecurityAnalysis
perform_entanglement_distillation	src/chain/quantum_voting/quantum_voting.rs	/^    fn perform_entanglement_distillation($/;"	P	implementation:QuantumVoting
perform_entanglement_purification	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn perform_entanglement_purification($/;"	P	implementation:EntanglementDistillation
perform_qkd	src/network/discovery.rs	/^    async fn perform_qkd(&mut self, peer_id: &PeerId) -> Result<(), NetworkError> {$/;"	P	implementation:Discovery
perform_qkd	src/network/network_manager.rs	/^    async fn perform_qkd(&self) -> Result<()> {$/;"	P	implementation:NetworkManager
perform_quantum_key_distribution	src/chain/quantum_voting/vote_collection.rs	/^    fn perform_quantum_key_distribution($/;"	P	implementation:VoteCollection
perform_quantum_noise_simulations	src/chain/quantum_voting/quantum_voting.rs	/^    fn perform_quantum_noise_simulations($/;"	P	implementation:QuantumVoting
perform_quantum_state_tomography	src/chain/quantum_voting/vote_collection.rs	/^    fn perform_quantum_state_tomography($/;"	P	implementation:VoteCollection
perform_quantum_teleportation	src/chain/quantum_voting/quantum_state_transmission.rs	/^    fn perform_quantum_teleportation($/;"	P	implementation:QuantumStateTransmission
perform_state_tomography	src/chain/quantum_voting/compression.rs	/^    fn perform_state_tomography($/;"	P	implementation:Compression
perform_state_tomography	src/chain/quantum_voting/quantum_voting.rs	/^    fn perform_state_tomography($/;"	P	implementation:QuantumVoting
perform_superdense_coding	src/network/discovery.rs	/^    async fn perform_superdense_coding($/;"	P	implementation:Discovery
perform_tomography	src/chain/quantum_voting/quantum_state_verification.rs	/^    fn perform_tomography($/;"	P	implementation:QuantumStateVerification
perform_useful_work	src/qup/consensus.rs	/^    fn perform_useful_work(&self, block: &QUPBlock) -> Result<UsefulWork, ConsensusError> {$/;"	P	implementation:QUPConsensus
perform_useful_work	src/qup/validator.rs	/^    pub fn perform_useful_work(&self, block: &QUPBlock) -> Result<UsefulWork, Error> {$/;"	P	implementation:QUPValidator
permissions	src/api/middleware/authorization.rs	/^    permissions: HashSet<(Method, Path, Permission)>,$/;"	m	struct:AuthorizationMiddleware
permissions	src/api/middleware/authorization.rs	/^    permissions: HashSet<(Method, Path, Permission)>,$/;"	m	struct:AuthorizationMiddlewareMiddleware
perplexity	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub perplexity: f32,$/;"	m	struct:EvaluationResult
ping	src/network/protocol.rs	/^        pub ping: (),$/;"	m	struct:protocol_message::ProtocolMessage
ping_interval	src/network/config.rs	/^    pub ping_interval: Duration,$/;"	m	struct:NetworkConfig
polynomial_values	src/zkp/zk_starks.rs	/^    pub polynomial_values: Vec<FieldElement>,$/;"	m	struct:FriQueryRoundProof
pong	src/network/protocol.rs	/^        pub pong: (),$/;"	m	struct:protocol_message::ProtocolMessage
post_quantum	src/crypto/mod.rs	/^pub(crate) mod post_quantum;/;"	n
post_quantum_certificate	src/chain/node.rs	/^    post_quantum_certificate: Arc<RwLock<Option<X509Certificate>>>,$/;"	m	struct:Node
post_quantum_decrypt	src/hdcmodels/qup_integration/qup_decoding.rs	/^    fn post_quantum_decrypt(&self, encoded_data: &[f64]) -> Vec<u8> {$/;"	P	implementation:QUPDecoding
post_quantum_encrypt	src/hdcmodels/qup_integration/qup_encoding.rs	/^    fn post_quantum_encrypt(&self, data: &[f64]) -> Vec<f64> {$/;"	P	implementation:QUPEncoding
post_quantum_keypair	src/chain/certificate_authority.rs	/^    post_quantum_keypair: Keypair,$/;"	m	struct:CertificateAuthority
post_quantum_keypair	src/chain/node.rs	/^    post_quantum_keypair: Arc<RwLock<Option<Keypair>>>,$/;"	m	struct:Node
post_quantum_keypair	src/chain/wallet.rs	/^    post_quantum_keypair: PostQuantumKeyPair,$/;"	m	struct:Wallet
post_quantum_keys	src/secure_core/secure_vault.rs	/^    post_quantum_keys: Arc<Mutex<HashMap<String, PostQuantumKeyPair>>>,$/;"	m	struct:SecureVault
post_quantum_signature	src/chain/transaction.rs	/^    pub post_quantum_signature: Option<PostQuantumSignature>,$/;"	m	struct:Transaction
pouw	src/api/routes/consensus.rs	/^    pouw: Option<PoUWParameters>,$/;"	m	struct:ConsensusParameters
pouw_miner	src/mining/mod.rs	/^mod pouw_miner;$/;"	n
pouw_state	src/api/routes/consensus.rs	/^    pouw_state: Option<PoUWState>,$/;"	m	struct:ConsensusState
pow	src/zkp/math.rs	/^    pub fn pow(&self, exponent: &BigUint, modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
pow_miner	src/mining/mod.rs	/^mod pow_miner;$/;"	n
predict	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    pub fn predict(&self, data: &[f64]) -> String {$/;"	P	implementation:IncrementalLearningHDCModel
predict	src/hdcmodels/continuous_learning/online_learning.rs	/^    pub fn predict(&self, data: &[f64]) -> String {$/;"	P	implementation:OnlineLearningHDCModel
predict	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    pub fn predict(&self, data: &[f64]) -> String {$/;"	P	implementation:GPUHDCModel
predict	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^    pub fn predict(&self, data: &[f64]) -> String {$/;"	P	implementation:OptimizedHDCModel
prepare_candidate_state	src/chain/quantum_voting/quantum_state_preparation.rs	/^    pub fn prepare_candidate_state($/;"	P	implementation:QuantumStatePreparation
prepare_quantum_state	src/chain/quantum_voting/quantum_state_transmission.rs	/^    fn prepare_quantum_state($/;"	P	implementation:QuantumStateTransmission
prepare_quantum_state	src/chain/quantum_voting/quantum_voting.rs	/^    fn prepare_quantum_state($/;"	P	implementation:QuantumVoting
prepare_state_for_compression	src/chain/quantum_voting/compression.rs	/^    fn prepare_state_for_compression($/;"	P	implementation:Compression
prepare_state_for_compression	src/chain/quantum_voting/quantum_voting.rs	/^    fn prepare_state_for_compression($/;"	P	implementation:QuantumVoting
prepare_state_for_distillation	src/chain/quantum_voting/entanglement_distillation.rs	/^    fn prepare_state_for_distillation($/;"	P	implementation:EntanglementDistillation
prepare_vote_state	src/chain/quantum_voting/quantum_state_preparation.rs	/^    pub fn prepare_vote_state(&self, vote: &Vote) -> Result<QuantumState, VotingError> {$/;"	P	implementation:QuantumStatePreparation
prepare_vote_state	src/chain/quantum_voting/voting_protocols.rs	/^    fn prepare_vote_state(&self, vote: &Vote) -> Result<QuantumState, VotingError> {$/;"	P	implementation:VotingProtocols
prepare_vote_states	src/chain/quantum_voting/voting_protocols.rs	/^    fn prepare_vote_states(&self, votes: &[Vote]) -> Result<Vec<QuantumState>, VotingError> {$/;"	P	implementation:VotingProtocols
preprocess	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    pub fn preprocess(&self, code_snippets: &[String]) -> Vec<String> {$/;"	P	implementation:Preprocessor
preprocess_dataset	src/datasets/mod.rs	/^pub fn preprocess_dataset($/;"	f
preprocess_snippet	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    fn preprocess_snippet(&self, snippet: &str) -> String {$/;"	P	implementation:Preprocessor
preprocessor	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    preprocessor: Preprocessor,$/;"	m	struct:Evaluator
preprocessor	src/optimization_problems/hdc_code_generation/mod.rs	/^mod preprocessor;$/;"	n
pretrained_model	src/hdcmodels/model_integration/transfer_learning.rs	/^    pretrained_model: nn::Sequential,$/;"	m	struct:TransferLearningModel
prev_block_hash	src/qup/block.rs	/^    pub prev_block_hash: Hash,$/;"	m	struct:QUPBlock
prev_block_hash	src/qup/types.rs	/^    pub prev_block_hash: Hash,$/;"	m	struct:QUPBlockHeader
previous_hash	src/api/models/request/blockchain_request.rs	/^    pub previous_hash: String,$/;"	m	struct:BlockHeader
previous_hash	src/api/models/response/blockchain_response.rs	/^    pub previous_hash: String,$/;"	m	struct:BlockHeader
previous_hash	src/chain/block.rs	/^    pub previous_hash: String,$/;"	m	struct:Block
print_timings	src/hdcmodels/performance_optimization/profiling.rs	/^    pub fn print_timings(&self) {$/;"	P	implementation:Profiler
private_key	src/chain/validator/validator.rs	/^    private_key: Vec<u8>,$/;"	m	struct:Validator
private_key	src/network/tls.rs	/^    pub private_key: PrivateKey,$/;"	m	struct:PostQuantumTLSConfig
problem	src/qup/block.rs	/^    pub problem: UsefulWorkProblem,$/;"	m	struct:UsefulWorkSolution
problem	src/qup/hdcomm.rs	/^    pub problem: UsefulWorkProblem,$/;"	m	struct:UsefulWork
problem_solution	src/optimization_problems/mod.rs	/^mod problem_solution;$/;"	n
problem_type	src/chain/block.rs	/^    pub problem_type: String,$/;"	m	struct:UsefulWork
problem_type	src/chain/transaction.rs	/^    pub problem_type: String,$/;"	m	struct:UsefulWorkSolution
process_block	src/network/node_message.rs	/^    async fn process_block(&mut self, block: Block) -> Result<(), NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
process_commit	src/qup/consensus.rs	/^    fn process_commit(&mut self, block_hash: Hash) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
process_incoming_messages	src/chain/shard.rs	/^    pub async fn process_incoming_messages(&mut self, secure_vault: &SecureVault) -> Result<(), /;"	P	implementation:Shard
process_message	src/qup/consensus.rs	/^    pub fn process_message(&mut self, message: ConsensusMessage) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
process_peers	src/network/node_message.rs	/^    async fn process_peers(&mut self, peers: Vec<NodeId>) -> Result<(), NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
process_propose	src/qup/consensus.rs	/^    fn process_propose(&mut self, block: QUPBlock) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
process_quantum_state	src/network/shard_message.rs	/^    async fn process_quantum_state(&mut self, shard_id: u64, state: QuantumState) -> Result<(), /;"	f
process_qup_shard_block	src/network/shard_message.rs	/^    async fn process_qup_shard_block(&mut self, shard_id: u64, block: QUPBlock) -> Result<(), Ne/;"	f
process_qup_shard_useful_work	src/network/shard_message.rs	/^    async fn process_qup_shard_useful_work(&mut self, shard_id: u64, useful_work: QUPUsefulWork)/;"	f
process_qup_shard_vote	src/network/shard_message.rs	/^    async fn process_qup_shard_vote(&mut self, shard_id: u64, vote: QUPVote) -> Result<(), Netwo/;"	f
process_state	src/network/node_message.rs	/^    async fn process_state(&mut self, state: Vec<u8>) -> Result<(), NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
process_transaction	src/chain/sharding.rs	/^    async fn process_transaction(&self, transaction: Transaction) {$/;"	P	implementation:Sharding
process_transaction	src/network/node_message.rs	/^    async fn process_transaction(&mut self, tx: Transaction) -> Result<(), NodeMessageError> {$/;"	P	implementation:NodeMessageHandler
process_transaction	src/network/shard_message.rs	/^    async fn process_transaction(&mut self, shard_id: u64, transaction: Transaction) -> Result<(/;"	f
process_transaction	src/utils/indexing.rs	/^    pub fn process_transaction(&mut self, transaction: &Transaction) {$/;"	P	implementation:BlockchainIndexer
process_vote	src/qup/consensus.rs	/^    fn process_vote(&mut self, vote: ConsensusVote) -> Result<(), ConsensusError> {$/;"	P	implementation:QUPConsensus
profile	src/hdcmodels/performance_optimization/profiling.rs	/^macro_rules! profile {$/;"	M
profile_hdcmodels	src/hdcmodels/performance_optimization/profiling.rs	/^pub fn profile_hdcmodels() {$/;"	f
proof	src/chain/transaction.rs	/^    pub proof: Proof,$/;"	m	struct:Transaction
proof	src/qup/block.rs	/^    pub proof: UsefulWorkProof,$/;"	m	struct:UsefulWorkSolution
proof	src/zkp/crypto.rs	/^    pub fn proof(&self, index: usize) -> (Vec<FieldElement>, Signature) {$/;"	P	implementation:QuantumResistantMerkleTree
proof_hash	src/chain/transaction.rs	/^    pub proof_hash: String,$/;"	m	struct:Proof
proposal	src/chain/governance/mod.rs	/^mod proposal;$/;"	n
proposal_id	src/api/models/request/governance_request.rs	/^    pub proposal_id: u64,$/;"	m	struct:CastVoteRequest
proposal_id	src/api/models/request/governance_request.rs	/^    pub proposal_id: u64,$/;"	m	struct:GetProposalRequest
proposal_id	src/chain/governance/voting.rs	/^    pub proposal_id: u64,$/;"	m	struct:Vote
proposal_id	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub proposal_id: String,$/;"	m	struct:SecureHDCModelUpdateVote
proposal_type	src/hdcmodels/continuous_learning/secure_updates.rs	/^    fn proposal_type(&self) -> String {$/;"	P	implementation:SecureHDCModelUpdateProposal
propose	src/hdcmodels/continuous_learning/secure_updates.rs	/^    fn propose(&self, consensus_protocol: &mut dyn ConsensusProtocol) {$/;"	P	implementation:SecureHDCModelUpdateProposal
propose_block	src/chain/validator/validator.rs	/^    pub fn propose_block(&self, transactions: Vec<Transaction>, consensus: &mut dyn Consensus) {$/;"	P	implementation:Validator
propose_block	src/qup/consensus.rs	/^    pub fn propose_block($/;"	P	implementation:QUPConsensus
propose_block	src/qup/validator.rs	/^    pub fn propose_block(&self, transactions: Vec<Transaction>) -> Result<QUPBlock, Error> {$/;"	P	implementation:QUPValidator
proposer	src/chain/governance/proposal.rs	/^    pub proposer: String,$/;"	m	struct:Proposal
proposer	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub proposer: String,$/;"	m	struct:SecureHDCModelUpdateProposal
protocol	src/network/lib.rs	/^pub mod protocol;$/;"	n
protocol	src/network/mod.rs	/^mod protocol;$/;"	n
protocol_message	src/network/protocol.rs	/^mod protocol_message {$/;"	n
protocols	src/chain/quantum_voting/mod.rs	/^    protocols: VotingProtocols,$/;"	m	struct:QuantumVoting
prover	src/zkp/mod.rs	/^mod prover;$/;"	n
prune_blockchain	src/chain/blockchain.rs	/^    pub async fn prune_blockchain(blockchain: &Blockchain, max_blocks: usize) {$/;"	f	module:blockchain_utils
prune_state	src/chain/shard.rs	/^    pub async fn prune_state(&mut self) {$/;"	P	implementation:Shard
public_key	src/api/handlers/qup_handler.rs	/^    public_key: String,$/;"	m	struct:ValidatorInfo
public_key	src/api/models/response/qup_response.rs	/^    pub public_key: String,$/;"	m	struct:ValidatorInfo
public_key	src/api/routes/consensus.rs	/^    public_key: String,$/;"	m	struct:Validator
public_key	src/chain/node.rs	/^    pub public_key: PublicKey,$/;"	m	struct:PostQuantumCertificateSigningRequest
public_key	src/chain/quantum_voting/types.rs	/^    pub public_key: Vec<u8>,$/;"	m	struct:Candidate
public_key	src/chain/validator/validator.rs	/^    pub public_key: Vec<u8>,$/;"	m	struct:Validator
public_key	src/chain/wallet.rs	/^    pub fn public_key(&self) -> &[u8] {$/;"	P	implementation:Wallet
public_key	src/crypto/post_quantum.rs	/^    pub public_key: DilithiumPublicKey,$/;"	m	struct:DilithiumKeypair
public_key	src/crypto/post_quantum.rs	/^    pub public_key: KyberPublicKey,$/;"	m	struct:KyberKeypair
public_key	src/network/p2p/peer.rs	/^    pub public_key: PublicKey,$/;"	m	struct:Peer
public_key	src/secure_core/quantum_resistant_signatures.rs	/^    pub public_key: Vec<u8>,$/;"	m	struct:QuantumResistantSignature
public_key	src/zkp/crypto.rs	/^    public_key: PublicKey,$/;"	m	struct:QuantumResistantMerkleTree
put	src/chain/storage/database.rs	/^    fn put(&self, key: &[u8], value: &[u8]) -> Result<(), DatabaseError> {$/;"	P	implementation:MemoryDatabase
put	src/chain/storage/database.rs	/^    fn put(&self, key: &[u8], value: &[u8]) -> Result<(), DatabaseError>;$/;"	P	interface:Database
qdpos	src/api/routes/consensus.rs	/^    qdpos: Option<QDPoSParameters>,$/;"	m	struct:ConsensusParameters
qdpos_state	src/api/routes/consensus.rs	/^    qdpos_state: Option<QDPoSState>,$/;"	m	struct:ConsensusState
qkd	src/network/network_manager.rs	/^    qkd: QuantumKeyDistribution,$/;"	m	struct:NetworkManager
qrng	src/quantum_entropy/qrng.rs	/^    qrng: RandomNumberGenerator,$/;"	m	struct:QuantumEntropy
quantum_channel	src/network/discovery.rs	/^    quantum_channel: QuantumChannel,$/;"	m	struct:Discovery
quantum_channel	src/network/quantum_resistant.rs	/^    quantum_channel: Option<QuantumChannel>,$/;"	m	struct:QuantumResistantConnection
quantum_communication	src/chain/quantum_voting/mod.rs	/^mod quantum_communication;$/;"	n
quantum_connection	src/network/client.rs	/^    quantum_connection: QuantumResistantConnection,$/;"	m	struct:Client
quantum_cryptography	src/chain/quantum_voting/mod.rs	/^mod quantum_cryptography;$/;"	n
quantum_entropy	src/chain/certificate_authority.rs	/^    quantum_entropy: QuantumEntropy,$/;"	m	struct:CertificateAuthority
quantum_entropy	src/chain/certificate_authority.rs	/^    quantum_entropy: QuantumEntropy,$/;"	m	struct:CertificateAuthorityClient
quantum_entropy	src/chain/mod.rs	/^pub(crate) mod quantum_entropy;$/;"	n
quantum_entropy	src/chain/wallet.rs	/^    quantum_entropy: QuantumEntropy,$/;"	m	struct:Wallet
quantum_entropy	src/main.rs	/^mod quantum_entropy; \/\/ Quantum entropy source$/;"	n
quantum_entropy_source	src/chain/node.rs	/^    quantum_entropy_source: Arc<QuantumEntropySource>,$/;"	m	struct:Node
quantum_entropy_source	src/secure_core/secure_vault.rs	/^    quantum_entropy_source: QuantumEntropySource,$/;"	m	struct:SecureVault
quantum_key_distribution	src/chain/quantum_voting/mod.rs	/^mod quantum_key_distribution;$/;"	n
quantum_key_distribution	src/network/discovery.rs	/^    quantum_key_distribution: QuantumKeyDistribution,$/;"	m	struct:Discovery
quantum_key_generator	src/chain/quantum_voting/quantum_key_management.rs	/^    quantum_key_generator: QuantumKeyGenerator,$/;"	m	struct:QuantumKeyManagement
quantum_key_generator	src/chain/quantum_voting/quantum_voting.rs	/^    quantum_key_generator: QuantumKeyGenerator,$/;"	m	struct:QuantumVoting
quantum_peer_discovery	src/network/discovery.rs	/^    async fn quantum_peer_discovery(&mut self, peer_id: &PeerId) -> Result<(), NetworkError> {$/;"	P	implementation:Discovery
quantum_resistant	src/network/mod.rs	/^mod quantum_resistant;$/;"	n
quantum_resistant_signatures	src/secure_core/mod.rs	/^pub(crate) mod quantum_resistant_signatures;$/;"	n
quantum_signature	src/chain/quantum_voting/quantum_voting.rs	/^    quantum_signature: QuantumSignature,$/;"	m	struct:QuantumVoting
quantum_state_preparation	src/chain/quantum_voting/mod.rs	/^mod quantum_state_preparation;$/;"	n
quantum_state_verification	src/chain/quantum_voting/mod.rs	/^mod quantum_state_verification;$/;"	n
quantum_voting	src/chain/mod.rs	/^mod quantum_voting;/;"	n
query_channel_state_route	src/chain/state_channel.rs	/^fn query_channel_state_route($/;"	f
query_round_proofs	src/zkp/zk_starks.rs	/^    pub query_round_proofs: Vec<FriQueryRoundProof>,$/;"	m	struct:FriProof
quorum	src/chain/governance/voting.rs	/^    pub quorum: u64,$/;"	m	struct:Voting
quorum_ratio	src/api/handlers/governance_handler.rs	/^    quorum_ratio: f64,$/;"	m	struct:GovernanceParameters
quorum_ratio	src/api/models/request/governance_request.rs	/^    pub quorum_ratio: f64,$/;"	m	struct:GovernanceParameters
quorum_ratio	src/api/routes/governance.rs	/^    quorum_ratio: f64,$/;"	m	struct:GovernanceParameters
qup_config	src/chain/blockchain.rs	/^    qup_config: Arc<QUPConfig>,$/;"	m	struct:Blockchain
qup_consensus	src/chain/blockchain.rs	/^    qup_consensus: Arc<QUPConsensus>,$/;"	m	struct:Blockchain
qup_consensus	src/mining/miner.rs	/^    qup_consensus: Arc<Mutex<QUPConsensus>>,$/;"	m	struct:Miner
qup_crypto	src/chain/certificate_authority.rs	/^    qup_crypto: QUPCrypto,$/;"	m	struct:CertificateAuthority
qup_crypto	src/chain/certificate_authority.rs	/^    qup_crypto: QUPCrypto,$/;"	m	struct:CertificateAuthorityClient
qup_crypto	src/chain/sharding.rs	/^    qup_crypto: Arc<QUPCrypto>,$/;"	m	struct:Sharding
qup_crypto	src/chain/state/state_transition.rs	/^    qup_crypto: Arc<QUPCrypto>,$/;"	m	struct:StateTransition
qup_crypto	src/chain/state_channel.rs	/^    qup_crypto: Arc<QUPCrypto>,$/;"	m	struct:ChannelManagerOptimized
qup_crypto	src/chain/wallet.rs	/^    qup_crypto: Arc<QUPCrypto>,$/;"	m	struct:Wallet
qup_crypto	src/hdcmodels/qup_integration/qup_decoding.rs	/^    qup_crypto: QUPCrypto,$/;"	m	struct:QUPDecoding
qup_crypto	src/hdcmodels/qup_integration/qup_encoding.rs	/^    qup_crypto: QUPCrypto,$/;"	m	struct:QUPEncoding
qup_delegator_reward_ratio	src/mining/mining_config.rs	/^    pub fn qup_delegator_reward_ratio(&self) -> f64 {$/;"	P	implementation:MiningConfig
qup_delegator_reward_ratio	src/mining/mining_config.rs	/^    qup_delegator_reward_ratio: f64,$/;"	m	struct:MiningConfig
qup_parameters	src/api/models/request/qup_request.rs	/^    pub qup_parameters: QUPParameters,$/;"	m	struct:UpdateConsensusParametersRequest
qup_parameters	src/api/models/response/qup_response.rs	/^    pub qup_parameters: QUPParameters,$/;"	m	struct:GetConsensusParametersResponse
qup_signature	src/chain/governance/proposal.rs	/^    pub qup_signature: Vec<u8>,$/;"	m	struct:Proposal
qup_state	src/api/models/response/qup_response.rs	/^    pub qup_state: QUPState,$/;"	m	struct:GetConsensusStateResponse
qup_state	src/chain/blockchain.rs	/^    qup_state: Arc<QUPState>,$/;"	m	struct:Blockchain
qup_state	src/chain/governance/governance_engine.rs	/^    qup_state: Arc<QUPState>,$/;"	m	struct:GovernanceEngine
qup_state	src/chain/sharding.rs	/^    qup_state: Arc<QUPState>,$/;"	m	struct:Sharding
qup_state	src/chain/state/state_db.rs	/^    qup_state: QUPState,$/;"	m	struct:StateDB
qup_state	src/chain/state/state_manager.rs	/^    qup_state: Arc<RwLock<QUPState>>,$/;"	m	struct:StateManager
qup_state	src/chain/state/state_transition.rs	/^    qup_state: Arc<QUPState>,$/;"	m	struct:StateTransition
qup_useful_work_difficulty	src/mining/mining_config.rs	/^    pub fn qup_useful_work_difficulty(&self) -> u64 {$/;"	P	implementation:MiningConfig
qup_useful_work_difficulty	src/mining/mining_config.rs	/^    qup_useful_work_difficulty: u64,$/;"	m	struct:MiningConfig
qup_validator_reward_ratio	src/mining/mining_config.rs	/^    pub fn qup_validator_reward_ratio(&self) -> f64 {$/;"	P	implementation:MiningConfig
qup_validator_reward_ratio	src/mining/mining_config.rs	/^    qup_validator_reward_ratio: f64,$/;"	m	struct:MiningConfig
qup_voting_threshold	src/mining/mining_config.rs	/^    pub fn qup_voting_threshold(&self) -> u64 {$/;"	P	implementation:MiningConfig
qup_voting_threshold	src/mining/mining_config.rs	/^    qup_voting_threshold: u64,$/;"	m	struct:MiningConfig
random	src/zkp/math.rs	/^    pub fn random(modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
random_projection	src/hdcmodels/encoding.rs	/^fn random_projection(token: &str, dimension: usize) -> Vec<f64> {$/;"	f
rate_limit_check	src/api/middleware/authentication.rs	/^fn rate_limit_check(ip: &str) -> bool {$/;"	f
rate_limiter	src/api/middleware/rate_limiter.rs	/^    rate_limiter: RateLimiter,$/;"	m	struct:RateLimiterMiddleware
rate_limiter	src/api/middleware/rate_limiter.rs	/^    rate_limiter: RateLimiter,$/;"	m	struct:RateLimiterMiddlewareMiddleware
re	src/crypto/quantum_state.rs	/^    pub re: f64,$/;"	m	struct:Complex64
read_from_file	src/utils/mod.rs	/^pub fn read_from_file(file_path: &str) -> Result<String, std::io::Error> {$/;"	f
reason	src/chain/state_channel.rs	/^    pub reason: String,$/;"	m	struct:Dispute
receive	src/network/p2p/peer.rs	/^    pub async fn receive(&mut self) -> Result<Message, PeerError> {$/;"	P	implementation:Peer
receive	src/network/tls.rs	/^    pub async fn receive(&mut self) -> Result<Vec<u8>, std::io::Error> {$/;"	P	implementation:PostQuantumTLSConnection
receive_encrypted_vote	src/chain/quantum_voting/vote_collection.rs	/^    fn receive_encrypted_vote($/;"	P	implementation:VoteCollection
receive_entangled_state	src/network/quantum_resistant.rs	/^    async fn receive_entangled_state(&mut self) -> Result<TimeBinState, NetworkError> {$/;"	P	implementation:QuantumChannel
receive_entangled_state	src/network/quantum_resistant.rs	/^    async fn receive_entangled_state(&mut self) -> Result<TimeBinState, NetworkError> {$/;"	P	implementation:QuantumResistantConnection
receive_entangled_state	src/network/quantum_resistant.rs	/^    async fn receive_entangled_state(&mut self) -> Result<TimeBinState, NetworkError>;$/;"	P	interface:QuantumResistantConnectionManager
receive_entangled_state	src/network/quantum_resistant.rs	/^    pub async fn receive_entangled_state(&mut self) -> Result<TimeBinState, NetworkError> {$/;"	P	implementation:QuantumResistantConnection
receive_measurement_results	src/network/quantum_resistant.rs	/^    async fn receive_measurement_results(&mut self) -> Result<Vec<bool>, NetworkError> {$/;"	P	implementation:QuantumChannel
receive_measurement_results	src/network/quantum_resistant.rs	/^    async fn receive_measurement_results(&mut self) -> Result<Vec<bool>, NetworkError> {$/;"	P	implementation:QuantumResistantConnection
receive_measurement_results	src/network/quantum_resistant.rs	/^    async fn receive_measurement_results(&mut self) -> Result<Vec<bool>, NetworkError>;$/;"	P	interface:QuantumResistantConnectionManager
receive_message	src/network/quantum_resistant.rs	/^    async fn receive_message(&self, node_id: &str) -> Result<Vec<u8>, NetworkError> {$/;"	P	implementation:QuantumResistantConnection
receive_message	src/network/quantum_resistant.rs	/^    async fn receive_message(&self, node_id: &str) -> Result<Vec<u8>, NetworkError>;$/;"	P	interface:QuantumResistantConnectionManager
receive_quantum_state	src/chain/quantum_voting/quantum_communication.rs	/^    pub fn receive_quantum_state($/;"	P	implementation:QuantumCommunication
receive_report	src/hdcmodels/benchmarking/reporting.rs	/^    pub async fn receive_report(&self) -> Option<HashMap<String, BenchmarkReport>> {$/;"	P	implementation:BenchmarkReporter
receive_vote	src/chain/quantum_voting/quantum_voting.rs	/^    fn receive_vote(&self, candidate: &Candidate) -> Result<Vec<String>, VotingError> {$/;"	P	implementation:QuantumVoting
receive_vote	src/chain/quantum_voting/vote_collection.rs	/^    fn receive_vote(&self, candidate: &Candidate) -> Result<Vec<String>, VotingError> {$/;"	P	implementation:VoteCollection
receiver	src/api/api.rs	/^    receiver: String,$/;"	m	struct:NewTransactionRequest
receiver	src/api/routes/blockchain.rs	/^    receiver: String,$/;"	m	struct:TransactionInfo
receiver	src/chain/state_channel.rs	/^    pub receiver: String,$/;"	m	struct:OffChainTransaction
receiver	src/chain/transaction.rs	/^    pub receiver: String,$/;"	m	struct:Transaction
receiver	src/network/p2p/peer.rs	/^    receiver: Receiver<Message>,$/;"	m	struct:Peer
recipient	src/api/handlers/blockchain_handler.rs	/^    recipient: String,$/;"	m	struct:TransactionInfo
recipient	src/api/handlers/transaction_handler.rs	/^    recipient: String,$/;"	m	struct:SubmitTransactionRequest
recipient	src/api/handlers/transaction_handler.rs	/^    recipient: String,$/;"	m	struct:TransactionInfo
recipient	src/api/models/request/blockchain_request.rs	/^    pub recipient: String,$/;"	m	struct:TransactionData
recipient	src/api/models/request/transaction_request.rs	/^    pub recipient: Option<String>,$/;"	m	struct:GetTransactionsRequest
recipient	src/api/models/request/transaction_request.rs	/^    pub recipient: String,$/;"	m	struct:SubmitTransactionRequest
recipient	src/api/models/request/transaction_request.rs	/^    pub recipient: String,$/;"	m	struct:Transaction
recipient	src/api/models/response/blockchain_response.rs	/^    pub recipient: String,$/;"	m	struct:TransactionData
recipient	src/api/routes/transaction.rs	/^    recipient: String,$/;"	m	struct:SubmitTransactionRequest
recipient	src/api/routes/transaction.rs	/^    recipient: String,$/;"	m	struct:TransactionInfo
recipient	src/types/block_reward.rs	/^    pub recipient: Address,$/;"	m	struct:BlockReward
reconstruct_key	src/secure_core/security_utils.rs	/^    pub fn reconstruct_key(shares: &[Vec<u8>]) -> Option<Vec<u8>> {$/;"	P	implementation:SecurityUtils
record_vote	src/chain/quantum_voting/voting_state.rs	/^    pub fn record_vote(&self, candidate_id: &str) -> Result<(), VotingError> {$/;"	P	implementation:VotingState
refresh_access_token	src/api/middleware/authentication.rs	/^async fn refresh_access_token(data: web::Json<RefreshTokenRequest>) -> impl Responder {$/;"	f
refresh_token	src/api/middleware/authentication.rs	/^    refresh_token: String,$/;"	m	struct:RefreshTokenRequest
register_validator	src/chain/blockchain.rs	/^    pub async fn register_validator($/;"	P	implementation:Blockchain
register_validator	src/chain/blockchain.rs	/^    pub async fn register_validator(&self, validator: &QUPValidator) -> Result<(), BlockchainErr/;"	P	implementation:Blockchain
relay_qup_message	src/network/network_manager.rs	/^    pub async fn relay_qup_message(&self, message: QUPMessage) -> Result<()> {$/;"	P	implementation:NetworkManager
remove	src/chain/state/merkle_trie.rs	/^    pub fn remove(&mut self, key: &[u8]) -> Result<(), MerkleTrieError> {$/;"	P	implementation:MerkleTrie
remove_account	src/chain/state/state_db.rs	/^    pub fn remove_account(&mut self, address: &str) {$/;"	P	implementation:StateDB
remove_account	src/chain/state/state_manager.rs	/^    pub fn remove_account(&self, address: &str) {$/;"	P	implementation:StateManager
remove_comments	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    fn remove_comments(&self, snippet: &str) -> String {$/;"	P	implementation:Preprocessor
remove_comments_external	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^fn remove_comments_external(snippet: &str) -> String {$/;"	f
remove_encrypted	src/secure_core/secure_storage.rs	/^    pub fn remove_encrypted(&self, key: &str) -> Result<(), SecureStorageError> {$/;"	P	implementation:SecureStorage
remove_expired_keys	src/secure_core/secure_vault.rs	/^    pub fn remove_expired_keys(&self) {$/;"	P	implementation:SecureVault
remove_expired_sp_keys	src/secure_core/secure_vault.rs	/^    pub fn remove_expired_sp_keys(&self) {$/;"	P	implementation:SecureVault
remove_extra_whitespace	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    fn remove_extra_whitespace(&self, snippet: &str) -> String {$/;"	P	implementation:Preprocessor
remove_peer	src/network/discovery.rs	/^    async fn remove_peer(&mut self, peer_id: &PeerId) {$/;"	P	implementation:Discovery
remove_recursive	src/chain/state/merkle_trie.rs	/^    fn remove_recursive($/;"	P	implementation:MerkleTrie
remove_storage	src/chain/state/account.rs	/^    pub fn remove_storage(&mut self, key: &str) {$/;"	P	implementation:Account
remove_transaction	src/mining/transaction_pool.rs	/^    pub fn remove_transaction(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:TransactionPool
remove_value	src/smart_contract/execution_context.rs	/^    pub fn remove_value(&mut self, key: &str) {$/;"	P	implementation:ExecutionContext
report_blockchain_error	src/error_handling/error_reporter.rs	/^    fn report_blockchain_error(&self, error: &BlockchainError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_configuration_error	src/error_handling/error_reporter.rs	/^    fn report_configuration_error(&self, error: &ConfigurationError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_consensus_error	src/error_handling/error_reporter.rs	/^    fn report_consensus_error(&self, error: &ConsensusError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_crypto_error	src/error_handling/error_reporter.rs	/^    fn report_crypto_error(&self, error: &CryptoError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_error	src/error_handling/error_reporter.rs	/^    pub fn report_error(&self, error: &Error, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_invalid_data_error	src/error_handling/error_reporter.rs	/^    fn report_invalid_data_error(&self, error: &str, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_io_error	src/error_handling/error_reporter.rs	/^    fn report_io_error(&self, error: &std::io::Error, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_network_error	src/error_handling/error_reporter.rs	/^    fn report_network_error(&self, error: &NetworkError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_permission_denied_error	src/error_handling/error_reporter.rs	/^    fn report_permission_denied_error(&self, error: &str, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_resource_not_found_error	src/error_handling/error_reporter.rs	/^    fn report_resource_not_found_error(&self, error: &str, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_serialization_error	src/error_handling/error_reporter.rs	/^    fn report_serialization_error(&self, error: &serde_json::Error, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_smart_contract_error	src/error_handling/error_reporter.rs	/^    fn report_smart_contract_error(&self, error: &SmartContractError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_storage_error	src/error_handling/error_reporter.rs	/^    fn report_storage_error(&self, error: &StorageError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_unexpected_error	src/error_handling/error_reporter.rs	/^    fn report_unexpected_error(&self, error: &str, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
report_wallet_error	src/error_handling/error_reporter.rs	/^    fn report_wallet_error(&self, error: &WalletError, context: Option<&str>) {$/;"	P	implementation:ErrorReporter
request_blind_signature	src/chain/quantum_voting/voting_protocols.rs	/^    fn request_blind_signature($/;"	P	implementation:VotingProtocols
request_certificate	src/chain/certificate_authority.rs	/^    pub async fn request_certificate($/;"	P	implementation:CertificateAuthorityClient
request_post_quantum_certificate	src/chain/node.rs	/^    pub async fn request_post_quantum_certificate(&self) -> Result<(), NodeError> {$/;"	P	implementation:Node
request_shard_state	src/chain/sharding.rs	/^    pub async fn request_shard_state(&self, shard_id: u64) -> Result<(), ShardingError> {$/;"	P	implementation:Sharding
request_shard_state	src/network/shard_message.rs	/^    pub async fn request_shard_state(&self, shard_id: u64) -> Result<(), NetworkError> {$/;"	P	implementation:ShardMessageHandler
reset_gas	src/smart_contract/execution_context.rs	/^    pub fn reset_gas(&mut self) {$/;"	P	implementation:ExecutionContext
resolution	src/chain/state_channel.rs	/^    pub resolution: Option<DisputeResolution>,$/;"	m	struct:Dispute
resolve_dispute	src/chain/state_channel.rs	/^    pub fn resolve_dispute(&mut self, channel_id: &str, resolution: DisputeResolution) -> Result/;"	P	implementation:ChannelManagerOptimized
resolve_dispute	src/chain/state_channel.rs	/^    pub fn resolve_dispute(&mut self, resolution: DisputeResolution) -> Result<(), StateChannelE/;"	P	implementation:StateChannelOptimized
response_sender	src/network/node_message.rs	/^    response_sender: Option<Sender<NodeMessage>>,$/;"	m	struct:NodeMessageHandler
restore_sp_key	src/secure_core/secure_vault.rs	/^    pub async fn restore_sp_key(&self, sp_key_id: &str) -> Result<Vec<u8>, Box<dyn std::error::E/;"	P	implementation:SecureVault
result	src/error_handling/mod.rs	/^mod result;$/;"	n
results	src/hdcmodels/benchmarking/data_collection.rs	/^    pub results: Vec<HDCBenchmarkResult>,$/;"	m	struct:BenchmarkData
retrieve_encrypted	src/secure_core/secure_storage.rs	/^    pub fn retrieve_encrypted(&self, key: &str) -> Result<Option<EncryptedData>, SecureStorageEr/;"	P	implementation:SecureStorage
retrieve_key_pair	src/chain/wallet.rs	/^    pub fn retrieve_key_pair(&self) -> Result<Option<PostQuantumKeyPair>, WalletError> {$/;"	P	implementation:Wallet
retrieve_keypair	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn retrieve_keypair(&self, key_id: &str) -> Option<(PublicKey, SigningKey)> {$/;"	P	implementation:QuantumResistantSigner
retrieve_session_key	src/secure_core/secure_communication.rs	/^    pub fn retrieve_session_key(&self, session_id: &str) -> Option<[u8; 32]> {$/;"	P	implementation:SecureCommunication
return_cost	src/smart_contract/gas.rs	/^    pub return_cost: u64,$/;"	m	struct:GasCost
revert	src/chain/state/state_transition.rs	/^    fn revert(&self, transaction: &Transaction) -> Result<(), String> {$/;"	P	implementation:StateTransition
revert	src/chain/state_transition.rs	/^    fn revert(&self, transaction: &Transaction) -> Result<(), StateTransitionError> {$/;"	P	implementation:StateTransition
revert_block	src/chain/blockchain.rs	/^    pub async fn revert_block(&self, block: &Block) -> Result<(), BlockchainError> {$/;"	P	implementation:Blockchain
revert_block	src/chain/state/state_transition.rs	/^    pub fn revert_block(&self, block: &Block) -> Result<(), String> {$/;"	P	implementation:StateTransition
revert_block	src/chain/state_transition.rs	/^    pub fn revert_block(&self, block: &Block) -> Result<(), StateTransitionError> {$/;"	P	implementation:StateTransition
revoke_permission	src/secure_core/access_control.rs	/^    pub fn revoke_permission(&self, role: Role, permission: Permission) {$/;"	P	implementation:AccessControl
revoke_role	src/secure_core/access_control.rs	/^    pub fn revoke_role(&self, user_id: &str, role: Role) {$/;"	P	implementation:AccessControl
revoke_token	src/api/middleware/authentication.rs	/^async fn revoke_token(auth_user: AuthenticatedUser, data: web::Json<RevokeTokenRequest>) -> impl/;"	f
reward	src/qup/lib.rs	/^pub mod reward;$/;"	n
reward_pool	src/chain/governance/rewards.rs	/^    pub reward_pool: u64,$/;"	m	struct:Rewards
reward_rate	src/chain/governance/rewards.rs	/^    pub reward_rate: f64,$/;"	m	struct:Rewards
reward_rate	src/chain/governance/staking.rs	/^    pub reward_rate: f64,$/;"	m	struct:Staking
reward_scheme	src/qup/config.rs	/^    pub reward_scheme: RewardScheme,$/;"	m	struct:QUPConfig
rewards	src/chain/governance/governance_engine.rs	/^    rewards: Arc<Rewards>,$/;"	m	struct:GovernanceEngine
rewards	src/chain/governance/mod.rs	/^mod rewards;$/;"	n
rewards	src/chain/governance/rewards.rs	/^    pub rewards: HashMap<String, u64>,$/;"	m	struct:Rewards
robustness	src/hdcmodels/hdcmodels.rs	/^    robustness: f64,$/;"	m	struct:HDCModel
role	src/api/middleware/authentication.rs	/^    pub role: String,$/;"	m	struct:AuthenticatedUser
role	src/api/middleware/authentication.rs	/^    role: String,$/;"	m	struct:Claims
role_permissions	src/secure_core/access_control.rs	/^    role_permissions: Arc<RwLock<HashMap<Role, Vec<Permission>>>>,$/;"	m	struct:AccessControl
rollback	src/qup/state.rs	/^    pub fn rollback(&mut self, height: u64) -> Result<(), Error> {$/;"	P	implementation:QUPState
rollback_transaction	src/smart_contract/execution_context.rs	/^    pub fn rollback_transaction(&mut self) {$/;"	P	implementation:ExecutionContext
root	src/chain/state/merkle_trie.rs	/^    root: Option<Arc<TrieNode>>,$/;"	m	struct:MerkleTrie
root	src/utils/merkle_tree.rs	/^    root: Hash,$/;"	m	struct:MerkleTree
root	src/zkp/crypto.rs	/^    pub fn root(&self) -> FieldElement {$/;"	P	implementation:QuantumResistantMerkleTree
root_hash	src/chain/state/merkle_trie.rs	/^    pub fn root_hash(&self) -> Option<Vec<u8>> {$/;"	P	implementation:MerkleTrie
rotate_key	src/secure_core/secure_vault.rs	/^    pub fn rotate_key(&self, id: &str, new_key: PrivateKey, expiry_duration: Duration) {$/;"	P	implementation:SecureVault
rotate_sp_key	src/secure_core/secure_vault.rs	/^    pub fn rotate_sp_key(&self, old_sp_key_id: &str) -> Option<String> {$/;"	P	implementation:SecureVault
routes	src/api/mod.rs	/^pub mod routes;$/;"	n
run	src/hdcmodels/benchmarking/benchmark_suite.rs	/^    pub fn run(&self) -> Vec<HDCBenchmarkResult> {$/;"	P	implementation:HDCBenchmarkSuite
rust_code_to_hdc	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn rust_code_to_hdc(code: &str, hdc_model: &HDCModel) -> Vec<f64> {$/;"	P	implementation:DataConverter
rustls	src/network/tls_config.rs	/^    let suites: Vec<&'static rustls::SupportedCipherSuite> = cipher_suites$/;"	v	function:set_cipher_suites_client
rustls	src/network/tls_config.rs	/^    let suites: Vec<&'static rustls::SupportedCipherSuite> = cipher_suites$/;"	v	function:set_cipher_suites_server
save	src/chain/governance/proposal.rs	/^    pub async fn save(&self, storage: &Arc<ProposalStorage>) -> Result<(), GovernanceError> {$/;"	P	implementation:Proposal
save	src/chain/storage/snapshot.rs	/^    pub fn save(&self, path: &Path) -> Result<(), SnapshotError> {$/;"	P	implementation:Snapshot
score	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub score: i32,$/;"	m	struct:StackEntry
secret_key	src/crypto/post_quantum.rs	/^    pub secret_key: DilithiumSecretKey,$/;"	m	struct:DilithiumKeypair
secret_key	src/crypto/post_quantum.rs	/^    pub secret_key: KyberSecretKey,$/;"	m	struct:KyberKeypair
secure_communication	src/secure_core/mod.rs	/^mod secure_communication;$/;"	n
secure_core	src/main.rs	/^mod secure_core;$/;"	n
secure_key_generation	src/chain/wallet.rs	/^    pub fn secure_key_generation(&self) -> Result<PostQuantumKeyPair, WalletError> {$/;"	P	implementation:Wallet
secure_storage	src/chain/blockchain.rs	/^    secure_storage: Arc<SecureStorage>,$/;"	m	struct:Blockchain
secure_storage	src/chain/wallet.rs	/^    secure_storage: Arc<SecureStorage>,$/;"	m	struct:Wallet
secure_storage	src/secure_core/mod.rs	/^mod secure_storage;$/;"	n
secure_vault	src/chain/sharding.rs	/^    secure_vault: Arc<SecureVault>,$/;"	m	struct:Sharding
secure_vault	src/mining/miner.rs	/^    secure_vault: Arc<SecureVault>,$/;"	m	struct:Miner
secure_vault	src/secure_core/mod.rs	/^pub(crate) mod secure_vault;/;"	n
secure_vault	src/secure_core/quantum_resistant_signatures.rs	/^    secure_vault: Arc<SecureVault>,$/;"	m	struct:QuantumResistantSigner
secure_vault	src/secure_core/secure_communication.rs	/^    secure_vault: Arc<SecureVault>,$/;"	m	struct:SecureCommunication
secure_vault	src/secure_core/secure_storage.rs	/^    secure_vault: Arc<SecureVault>,$/;"	m	struct:SecureStorage
security	src/chain/quantum_voting/mod.rs	/^    security: SecurityAnalysis,$/;"	m	struct:QuantumVoting
security_analysis	src/chain/quantum_voting/mod.rs	/^mod security_analysis;$/;"	n
security_level	src/zkp/zk_starks.rs	/^    pub security_level: usize,$/;"	m	struct:ZkStarksVerifier
security_parameter	src/chain/quantum_voting/security_analysis.rs	/^    security_parameter: QuantumSecurityParameter,$/;"	m	struct:SecurityAnalysis
security_utils	src/secure_core/mod.rs	/^mod security_utils;$/;"	n
seed_nodes	src/api/handlers/network_handler.rs	/^    seed_nodes: Vec<String>,$/;"	m	struct:NetworkConfig
seed_nodes	src/api/models/request/network_request.rs	/^    pub seed_nodes: Option<Vec<String>>,$/;"	m	struct:UpdateNetworkConfigRequest
seed_nodes	src/api/models/request/network_request.rs	/^    pub seed_nodes: Vec<String>,$/;"	m	struct:NetworkConfig
seed_nodes	src/api/models/response/network_response.rs	/^    pub seed_nodes: Vec<String>,$/;"	m	struct:NetworkConfig
seed_nodes	src/api/routes/network.rs	/^    seed_nodes: Vec<String>,$/;"	m	struct:NetworkConfig
select_most_suitable_code	src/chain/quantum_voting/quantum_voting.rs	/^    fn select_most_suitable_code($/;"	P	implementation:QuantumVoting
select_most_suitable_scheme	src/chain/quantum_voting/compression.rs	/^    fn select_most_suitable_scheme($/;"	P	implementation:Compression
selected_items	src/qup/types.rs	/^    pub selected_items: Vec<bool>,$/;"	m	struct:KnapsackSolution
send	src/network/p2p/peer.rs	/^    pub async fn send(&mut self, message: Message) -> Result<(), PeerError> {$/;"	P	implementation:Peer
send	src/network/tls.rs	/^    pub async fn send(&mut self, data: &[u8]) -> Result<(), std::io::Error> {$/;"	P	implementation:PostQuantumTLSConnection
send_entangled_state	src/network/quantum_resistant.rs	/^    async fn send_entangled_state(&mut self, state: &TimeBinState) -> Result<(), NetworkError> {$/;"	P	implementation:QuantumChannel
send_error_response	src/network/node_message.rs	/^    async fn send_error_response(&mut self, error: NodeMessageError) {$/;"	P	implementation:NodeMessageHandler
send_heartbeat	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn send_heartbeat(&mut self) -> Result<(), ()> {$/;"	P	implementation:FaultTolerantDistributedTrainingNode
send_measurement_results	src/network/quantum_resistant.rs	/^    async fn send_measurement_results(&mut self, results: &[bool]) -> Result<(), NetworkError> {$/;"	P	implementation:QuantumChannel
send_measurement_results	src/network/quantum_resistant.rs	/^    async fn send_measurement_results(&mut self, results: &[bool]) -> Result<(), NetworkError> {$/;"	P	implementation:QuantumResistantConnection
send_measurement_results	src/network/quantum_resistant.rs	/^    async fn send_measurement_results(&mut self, results: &[bool]) -> Result<(), NetworkError>;$/;"	P	interface:QuantumResistantConnectionManager
send_message	src/chain/sharding.rs	/^    pub async fn send_message($/;"	P	implementation:Sharding
send_message	src/network/lib.rs	/^    pub fn send_message(&mut self, message: Message) -> Result<(), NetworkError> {$/;"	P	implementation:Network
send_message	src/network/network_manager.rs	/^    pub async fn send_message(&self, message: Message) -> Result<()> {$/;"	P	implementation:NetworkManager
send_message	src/network/node_message.rs	/^    async fn send_message(&mut self, message: NodeMessage) {$/;"	P	implementation:NodeMessageHandler
send_message	src/network/quantum_resistant.rs	/^    async fn send_message(&self, node_id: &str, message: &[u8]) -> Result<(), NetworkError> {$/;"	P	implementation:QuantumResistantConnection
send_message	src/network/quantum_resistant.rs	/^    async fn send_message(&self, node_id: &str, message: &[u8]) -> Result<(), NetworkError>;$/;"	P	interface:QuantumResistantConnectionManager
send_message	src/network/quantum_resistant.rs	/^    pub async fn send_message(&self, node_id: &str, message: &[u8]) -> Result<(), NetworkError> /;"	P	implementation:QuantumResistantConnection
send_message	src/network/shard_message.rs	/^    pub async fn send_message($/;"	P	implementation:ShardMessageHandler
send_message_to_shard	src/chain/shard.rs	/^    pub async fn send_message_to_shard(&self, shard_id: u64, message: NetworkMessage) -> Result</;"	P	implementation:Shard
send_quantum_key	src/chain/quantum_voting/quantum_key_distribution.rs	/^    fn send_quantum_key($/;"	P	implementation:QuantumKeyDistribution
send_quantum_state	src/chain/quantum_voting/quantum_communication.rs	/^    pub fn send_quantum_state($/;"	P	implementation:QuantumCommunication
send_quantum_state	src/chain/quantum_voting/quantum_key_management.rs	/^    fn send_quantum_state($/;"	P	implementation:QuantumKeyManagement
send_quantum_state	src/chain/quantum_voting/quantum_state_transmission.rs	/^    pub fn send_quantum_state($/;"	P	implementation:QuantumStateTransmission
send_quantum_state_to_voter	src/chain/quantum_voting/quantum_key_management.rs	/^    fn send_quantum_state_to_voter($/;"	P	implementation:QuantumKeyManagement
send_quantum_state_to_voter	src/chain/quantum_voting/quantum_state_transmission.rs	/^    pub fn send_quantum_state_to_voter($/;"	P	implementation:QuantumStateTransmission
send_shard_state	src/chain/sharding.rs	/^    pub async fn send_shard_state($/;"	P	implementation:Sharding
send_shard_state	src/network/shard_message.rs	/^    pub async fn send_shard_state($/;"	P	implementation:ShardMessageHandler
send_state_response	src/network/sync/state_sync.rs	/^    async fn send_state_response(&self, response: StateSyncMessage) -> Result<(), StateSyncError/;"	P	implementation:StateSync
send_state_sync_message	src/network/lib.rs	/^    pub fn send_state_sync_message(&mut self, message: StateSyncMessage) -> Result<(), NetworkEr/;"	P	implementation:Network
send_trained_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn send_trained_model(&mut self, trained_model: Vec<Vec<f64>>) {$/;"	P	implementation:DistributedTrainingNode
send_transaction	src/chain/sharding.rs	/^    pub async fn send_transaction($/;"	P	implementation:Sharding
send_transaction	src/network/shard_message.rs	/^    pub async fn send_transaction($/;"	P	implementation:ShardMessageHandler
send_transaction_route	src/chain/state_channel.rs	/^fn send_transaction_route($/;"	f
sender	src/api/api.rs	/^    sender: String,$/;"	m	struct:NewTransactionRequest
sender	src/api/handlers/blockchain_handler.rs	/^    sender: String,$/;"	m	struct:TransactionInfo
sender	src/api/handlers/transaction_handler.rs	/^    sender: String,$/;"	m	struct:SubmitTransactionRequest
sender	src/api/handlers/transaction_handler.rs	/^    sender: String,$/;"	m	struct:TransactionInfo
sender	src/api/models/request/blockchain_request.rs	/^    pub sender: String,$/;"	m	struct:TransactionData
sender	src/api/models/request/transaction_request.rs	/^    pub sender: Option<String>,$/;"	m	struct:GetTransactionsRequest
sender	src/api/models/request/transaction_request.rs	/^    pub sender: String,$/;"	m	struct:SubmitTransactionRequest
sender	src/api/models/request/transaction_request.rs	/^    pub sender: String,$/;"	m	struct:Transaction
sender	src/api/models/response/blockchain_response.rs	/^    pub sender: String,$/;"	m	struct:TransactionData
sender	src/api/routes/blockchain.rs	/^    sender: String,$/;"	m	struct:TransactionInfo
sender	src/api/routes/transaction.rs	/^    sender: String,$/;"	m	struct:SubmitTransactionRequest
sender	src/api/routes/transaction.rs	/^    sender: String,$/;"	m	struct:TransactionInfo
sender	src/chain/state_channel.rs	/^    pub sender: String,$/;"	m	struct:OffChainTransaction
sender	src/chain/transaction.rs	/^    pub sender: String,$/;"	m	struct:Transaction
sender	src/network/p2p/peer.rs	/^    sender: Sender<Message>,$/;"	m	struct:Peer
sentry_dsn	src/error_handling/error_reporter.rs	/^    sentry_dsn: Option<String>,$/;"	m	struct:ErrorReporter
serialize	src/network/node_message.rs	/^    pub fn serialize(&self, crypto: &QUPCrypto) -> Result<Vec<u8>, NodeMessageError> {$/;"	P	implementation:NodeMessage
serialize	src/network/p2p/message.rs	/^    pub fn serialize(&self) -> Result<Vec<u8>, bincode::Error> {$/;"	P	implementation:Message
serialize	src/network/protocol.rs	/^    pub fn serialize(&self, crypto: &QUPCrypto) -> Result<Vec<u8>, ProtocolError> {$/;"	P	implementation:ProtocolMessage
serialize	src/network/shard_message.rs	/^    pub fn serialize(&self, crypto: &QUPCrypto) -> Result<Vec<u8>, NetworkError> {$/;"	P	implementation:ShardMessage
serialize_account	src/chain/state/state_db.rs	/^fn serialize_account(account: &Account) -> Vec<u8> {$/;"	f
serialize_vote	src/chain/quantum_voting/utils.rs	/^pub fn serialize_vote(vote: &Vote) -> Result<Vec<u8>, VotingError> {$/;"	f
server	src/network/lib.rs	/^    pub server: Server,$/;"	m	struct:Network
server	src/network/lib.rs	/^pub mod server;$/;"	n
server	src/network/mod.rs	/^mod server;$/;"	n
service	src/api/middleware/authorization.rs	/^    service: S,$/;"	m	struct:AuthorizationMiddlewareMiddleware
service	src/api/middleware/rate_limiter.rs	/^    service: S,$/;"	m	struct:RateLimiterMiddlewareMiddleware
service	src/api/middleware/request_validator.rs	/^    service: S,$/;"	m	struct:RequestValidatorMiddlewareMiddleware
set_account	src/chain/state/state_db.rs	/^    pub fn set_account(&mut self, account: &Account) {$/;"	P	implementation:StateDB
set_balance	src/chain/state/account.rs	/^    pub fn set_balance(&mut self, balance: u64) {$/;"	P	implementation:Account
set_certificate	src/network/tls.rs	/^    pub fn set_certificate(&mut self, certificate: Certificate) {$/;"	P	implementation:PostQuantumTLSConfig
set_cipher_suites_client	src/network/tls_config.rs	/^fn set_cipher_suites_client(config: &mut ClientConfig) {$/;"	f
set_cipher_suites_server	src/network/tls_config.rs	/^fn set_cipher_suites_server(config: &mut ServerConfig) {$/;"	f
set_common_alpn_protocols	src/network/tls_config.rs	/^fn set_common_alpn_protocols(config: &mut ClientConfig) {$/;"	f
set_common_alpn_protocols_server	src/network/tls_config.rs	/^fn set_common_alpn_protocols_server(config: &mut ServerConfig) {$/;"	f
set_cost	src/smart_contract/gas.rs	/^    pub set_cost: u64,$/;"	m	struct:GasCost
set_error_correction_scheme	src/hdcmodels/qup_integration/qup_error_correction.rs	/^    pub fn set_error_correction_scheme(&mut self, scheme: QuantumErrorCorrectionScheme) {$/;"	P	implementation:QUPErrorCorrection
set_gas_limit	src/smart_contract/execution_context.rs	/^    pub fn set_gas_limit(&mut self, limit: u64) {$/;"	P	implementation:ExecutionContext
set_message_sender	src/network/shard_message.rs	/^    pub async fn set_message_sender(&mut self, sender: Sender<(u64, ShardMessage)>) {$/;"	P	implementation:ShardMessageHandler
set_post_quantum_certificate	src/chain/node.rs	/^    pub async fn set_post_quantum_certificate(&self, certificate: X509Certificate) {$/;"	P	implementation:Node
set_private_key	src/network/tls.rs	/^    pub fn set_private_key(&mut self, private_key: PrivateKey) {$/;"	P	implementation:PostQuantumTLSConfig
set_storage	src/chain/state/account.rs	/^    pub fn set_storage(&mut self, key: String, value: String) {$/;"	P	implementation:Account
set_value	src/smart_contract/execution_context.rs	/^    pub fn set_value(&mut self, key: String, value: Value) {$/;"	P	implementation:ExecutionContext
shard	src/chain/mod.rs	/^mod shard;$/;"	n
shard_channels	src/chain/shard.rs	/^    pub shard_channels: HashMap<u64, Sender<NetworkMessage>>,$/;"	m	struct:Shard
shard_id	src/chain/shard.rs	/^    pub shard_id: u64,$/;"	m	struct:Shard
shard_id	src/chain/shard.rs	/^    pub shard_id: u64,$/;"	m	struct:ShardState
shard_message	src/network/mod.rs	/^mod shard_message;$/;"	n
sharding	src/chain/mod.rs	/^mod sharding;$/;"	n
shards	src/chain/sharding.rs	/^    shards: Arc<RwLock<HashMap<u64, Arc<Shard>>>>,$/;"	m	struct:Sharding
share_report	src/hdcmodels/benchmarking/reporting.rs	/^    pub async fn share_report(&self, report: HashMap<String, BenchmarkReport>) {$/;"	P	implementation:BenchmarkReporter
shared_secret	src/network/quantum_resistant.rs	/^    shared_secret: SecretKey,$/;"	m	struct:QuantumChannel
sigmoid	src/qup/hdcomm.rs	/^fn sigmoid(x: f64) -> f64 {$/;"	f
sign	src/chain/block.rs	/^    pub fn sign(&mut self, qup_crypto: &QUPCrypto) -> Result<(), BlockError> {$/;"	P	implementation:Block
sign	src/chain/quantum_entropy.rs	/^    pub fn sign(&self, message: &[u8], secret_key: &SecretKey) -> Signature {$/;"	P	implementation:QuantumEntropySource
sign	src/chain/state/merkle_trie.rs	/^    pub fn sign(&mut self, private_key: &[u8]) -> Result<(), MerkleTrieError> {$/;"	P	implementation:MerkleTrie
sign	src/chain/state/merkle_trie.rs	/^    pub fn sign(&mut self, private_key: &[u8]) -> Result<(), MerkleTrieError> {$/;"	P	implementation:TrieNode
sign	src/chain/transaction.rs	/^    pub fn sign(&mut self, private_key: &SecretKey) -> Result<(), TransactionError> {$/;"	P	implementation:Transaction
sign	src/crypto/post_quantum.rs	/^    pub fn sign(&self, message: &[u8]) -> Result<DilithiumSignature, PostQuantumError> {$/;"	P	implementation:DilithiumKeypair
sign	src/crypto/post_quantum.rs	/^    pub fn sign(&self, message: &[u8]) -> Result<DilithiumSignature, PostQuantumError> {$/;"	P	implementation:DilithiumSecretKey
sign	src/qup/block.rs	/^    pub fn sign(&mut self, validator: &QUPValidator) {$/;"	P	implementation:QUPBlock
sign	src/qup/crypto.rs	/^    fn sign(&self, message: &[u8], secret_key: &Self::SecretKey) -> Self::Signature {$/;"	P	implementation:QUPCrypto
sign	src/qup/crypto.rs	/^    pub fn sign(&self, message: &[u8], secret_key: &DilithiumSecretKey) -> QUPSignature {$/;"	P	implementation:QUPCrypto
sign	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn sign(&self, message: &[u8], signing_key: &SigningKey) -> Result<Signature, QuantumRes/;"	P	implementation:QuantumResistantSigner
sign_and_generate_proof	src/chain/transaction.rs	/^    pub fn sign_and_generate_proof($/;"	P	implementation:Transaction
sign_block	src/qup/validator.rs	/^    pub fn sign_block(&self, block: &QUPBlock) -> QUPSignature {$/;"	P	implementation:QUPValidator
sign_certificate	src/chain/certificate_authority.rs	/^    async fn sign_certificate($/;"	P	implementation:CertificateAuthority
sign_encoded_data	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn sign_encoded_data(&self, encoded_data: &[f64]) -> QUPSignature {$/;"	P	implementation:QUPEncoding
sign_recursive	src/chain/state/merkle_trie.rs	/^fn sign_recursive(node: &mut Arc<TrieNode>, private_key: &[u8]) -> Result<(), MerkleTrieError> {$/;"	f
sign_state	src/network/sync/state_sync.rs	/^    fn sign_state(&self, state: &ShardState) -> Signature {$/;"	P	implementation:StateSync
sign_transaction	src/chain/validator/validator.rs	/^    pub fn sign_transaction(&self, transaction: &Transaction) -> Signature {$/;"	P	implementation:Validator
sign_transaction	src/chain/wallet.rs	/^    pub fn sign_transaction(&self, transaction: &mut Transaction) -> Result<(), WalletError> {$/;"	P	implementation:Wallet
sign_vote	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn sign_vote($/;"	P	implementation:QuantumCryptography
sign_with_post_quantum_key	src/chain/transaction.rs	/^    pub fn sign_with_post_quantum_key($/;"	P	implementation:Transaction
signature	src/api/api.rs	/^    signature: String,$/;"	m	struct:NewTransactionRequest
signature	src/api/handlers/transaction_handler.rs	/^    signature: String,$/;"	m	struct:SubmitTransactionRequest
signature	src/api/models/request/blockchain_request.rs	/^    pub signature: String,$/;"	m	struct:TransactionData
signature	src/api/models/request/transaction_request.rs	/^    pub signature: String,$/;"	m	struct:SubmitTransactionRequest
signature	src/api/routes/transaction.rs	/^    signature: String,$/;"	m	struct:SubmitTransactionRequest
signature	src/chain/governance/voting.rs	/^    pub signature: Vec<u8>,$/;"	m	struct:Vote
signature	src/chain/state/merkle_trie.rs	/^    pub signature: Option<PostQuantumSignature>,$/;"	m	struct:TrieNode
signature	src/chain/state_channel.rs	/^    pub signature: QUPSignature,$/;"	m	struct:OffChainTransaction
signature	src/chain/transaction.rs	/^    pub signature: Vec<u8>,$/;"	m	struct:Transaction
signature	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub signature: Vec<u8>,$/;"	m	struct:SecureHDCModelUpdate
signature	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub signature: Vec<u8>,$/;"	m	struct:SecureHDCModelUpdateVote
signature	src/hdcmodels/distributed_training/synchronization.rs	/^    pub signature: QUPSignature,$/;"	m	struct:ModelUpdateMessage
signature	src/network/node_message.rs	/^    pub signature: QUPSignature,$/;"	m	struct:QUPVote
signature	src/qup/types.rs	/^    pub signature: QUPSignature,$/;"	m	struct:QUPTransaction
signature	src/qup/types.rs	/^    pub signature: QUPSignature,$/;"	m	struct:QUPVote
signature	src/secure_core/quantum_resistant_signatures.rs	/^    pub signature: Vec<u8>,$/;"	m	struct:QuantumResistantSignature
signature_scheme	src/chain/validator/validator.rs	/^    signature_scheme: SignatureScheme,$/;"	m	struct:Validator
signature_scheme	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    signature_scheme: QuantumSecureSignatureScheme,$/;"	m	struct:SmartContractGenerator
signature_scheme	src/network/sync/state_sync.rs	/^    signature_scheme: SignatureScheme,$/;"	m	struct:StateSync
signing_key_pair	src/qup/crypto.rs	/^    pub signing_key_pair: DilithiumKeyPair,$/;"	m	struct:QUPKeyPair
similarity	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    similarity: f64,$/;"	m	struct:ProposalAnalysis
similarity	src/hdcmodels/mod.rs	/^pub mod similarity;$/;"	n
similarity	src/qup/hdcomm.rs	/^    pub fn similarity(&self, block1: &QUPBlock, block2: &QUPBlock) -> f64 {$/;"	P	implementation:HDCommunication
similarity_metric	src/hdcmodels/hdcmodels.rs	/^    similarity_metric: SimilarityMetric,$/;"	m	struct:HDCModel
similarity_metric	src/hdcmodels/mod.rs	/^    similarity_metric: SimilarityMetric,$/;"	m	struct:HDCModel
similarity_threshold	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    similarity_threshold: f64,$/;"	m	struct:IncrementalLearningHDCModel
simulate_noisy_transmission	src/chain/quantum_voting/error_correction.rs	/^    fn simulate_noisy_transmission($/;"	P	implementation:ErrorCorrection
simulate_noisy_transmission	src/chain/quantum_voting/quantum_voting.rs	/^    fn simulate_noisy_transmission($/;"	P	implementation:QuantumVoting
size	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn size(&self) -> usize {$/;"	P	implementation:HDCModel
size	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn size(&self) -> usize {$/;"	P	implementation:MyDataType
size	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn size(&self) -> usize {$/;"	P	implementation:String
size	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn size(&self) -> usize {$/;"	P	implementation:Vec
size	src/hdcmodels/distributed_training/load_balancing.rs	/^    fn size(&self) -> usize;$/;"	P	interface:DataItem
slice	src/hdcmodels/parallel_processing.rs	/^    fn slice(&self, range: std::ops::Range<usize>) -> &[DataItem] {$/;"	P	implementation:Dataset
slice	src/hdcmodels/parallel_processing.rs	/^    fn slice(&self, range: std::ops::Range<usize>) -> &[DataItem];$/;"	P	interface:DatasetExt
smart_contract	src/main.rs	/^mod smart_contract; \/\/ Smart contract execution and management$/;"	n
smart_contract_routes	src/api/routes/smart_contract.rs	/^pub fn smart_contract_routes(cfg: &mut web::ServiceConfig) {$/;"	f
smart_contracts	src/chain/block.rs	/^    pub smart_contracts: Vec<Arc<SmartContract>>,$/;"	m	struct:Block
snapshot	src/chain/storage/mod.rs	/^mod snapshot;$/;"	n
solution	src/chain/block.rs	/^    pub solution: Vec<u8>,$/;"	m	struct:UsefulWork
solution	src/chain/transaction.rs	/^    pub solution: Vec<u8>,$/;"	m	struct:UsefulWorkSolution
solution	src/qup/block.rs	/^    pub solution: Vec<u8>,$/;"	m	struct:UsefulWorkSolution
solution	src/qup/hdcomm.rs	/^    pub solution: UsefulWorkSolution,$/;"	m	struct:UsefulWork
solution_data	src/optimization_problems/problem_solution.rs	/^    pub solution_data: Vec<u8>,$/;"	m	struct:ProblemSolution
solve	src/optimization_problems/optimization_problem.rs	/^    fn solve(&self, block: &Block) -> Result<ProblemSolution, String>;$/;"	P	interface:OptimizationProblem
solve	src/qup/hdcomm.rs	/^    pub fn solve(&self) -> UsefulWorkSolution {$/;"	P	implementation:UsefulWorkProblem
solve_knapsack_hdc	src/qup/hdcomm.rs	/^fn solve_knapsack_hdc(problem: &KnapsackProblem) -> Vec<usize> {$/;"	f
solve_knapsack_problem	src/qup/utils.rs	/^pub fn solve_knapsack_problem(problem: &KnapsackProblem) -> KnapsackSolution {$/;"	f
solve_useful_work_problem	src/qup/utils.rs	/^pub fn solve_useful_work_problem(problem: &UsefulWorkProblem) -> UsefulWorkSolution {$/;"	f
solve_vertex_cover_hdc	src/qup/hdcomm.rs	/^fn solve_vertex_cover_hdc(problem: &VertexCoverProblem) -> Vec<usize> {$/;"	f
solve_vertex_cover_problem	src/qup/utils.rs	/^pub fn solve_vertex_cover_problem(problem: &VertexCoverProblem) -> VertexCoverSolution {$/;"	f
sp_key	src/api/api.rs	/^    sp_key: String,$/;"	m	struct:NewTransactionRequest
sp_keys	src/secure_core/secure_vault.rs	/^    sp_keys: Arc<Mutex<HashMap<String, (Vec<u8>, Vec<String>, SystemTime)>>>,$/;"	m	struct:SecureVault
spec_encoder	src/hdcmodels/smart_contract_generation/code_generation.rs	/^    spec_encoder: SmartContractSpecEncoder,$/;"	m	struct:SmartContractGenerator
spend_public_key	src/chain/wallet.rs	/^    pub spend_public_key: [u8; 32],$/;"	m	struct:StealthAddress
split_key	src/secure_core/security_utils.rs	/^    pub fn split_key(key: &[u8], num_shares: usize, threshold: usize) -> Vec<Vec<u8>> {$/;"	P	implementation:SecurityUtils
stake	src/api/handlers/qup_handler.rs	/^    stake: u64,$/;"	m	struct:ValidatorInfo
stake	src/api/models/response/qup_response.rs	/^    pub stake: u64,$/;"	m	struct:ValidatorInfo
stake	src/api/routes/consensus.rs	/^    stake: f64,$/;"	m	struct:Validator
stake	src/chain/governance/governance_engine.rs	/^    pub async fn stake(&mut self, staker: String, amount: u64) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
stake	src/chain/governance/staking.rs	/^    pub async fn stake($/;"	P	implementation:Staking
stake	src/qup/delegator.rs	/^    pub fn stake(&mut self, amount: u64) {$/;"	P	implementation:QUPDelegator
stake	src/qup/delegator.rs	/^    pub stake: u64,$/;"	m	struct:QUPDelegator
stake	src/qup/validator.rs	/^    pub fn stake(&mut self, amount: u64) {$/;"	P	implementation:QUPValidator
stake	src/qup/validator.rs	/^    pub stake: u64,$/;"	m	struct:QUPValidator
staked_amounts	src/chain/governance/staking.rs	/^    pub staked_amounts: HashMap<String, u64>,$/;"	m	struct:Staking
staking	src/chain/governance/governance_engine.rs	/^    staking: Arc<Staking>,$/;"	m	struct:GovernanceEngine
staking	src/chain/governance/mod.rs	/^pub(crate) mod staking;$/;"	n
start	src/mining/miner.rs	/^    pub fn start(&mut self) {$/;"	P	implementation:Miner
start	src/network/client.rs	/^    pub async fn start(&mut self) -> Result<(), NetworkError> {$/;"	P	implementation:Client
start	src/network/discovery.rs	/^    pub async fn start(&mut self) -> Result<(), NetworkError> {$/;"	P	implementation:Discovery
start	src/network/lib.rs	/^    pub async fn start(&mut self) -> Result<(), NetworkError> {$/;"	P	implementation:Network
start	src/network/mod.rs	/^    pub async fn start(&self, address: &str) {$/;"	P	implementation:Network
start	src/network/network_manager.rs	/^    pub async fn start(&mut self) -> Result<()> {$/;"	P	implementation:NetworkManager
start	src/network/server.rs	/^    pub async fn start(&self) {$/;"	P	implementation:Server
start	src/network/sync/state_sync.rs	/^    pub async fn start(&mut self) {$/;"	P	implementation:StateSync
start_arbitration	src/chain/state_channel.rs	/^    pub fn start_arbitration(&mut self, arbitrator: String) -> Result<(), StateChannelError> {$/;"	P	implementation:StateChannelOptimized
start_block	src/api/models/request/blockchain_request.rs	/^    pub start_block: Option<u64>,$/;"	m	struct:GetTransactionsRequest
start_block	src/api/models/request/transaction_request.rs	/^    pub start_block: Option<u64>,$/;"	m	struct:GetTransactionsRequest
start_heartbeat	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn start_heartbeat(&mut self) {$/;"	P	implementation:FaultTolerantDistributedTrainingNode
start_heartbeat_monitoring	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    async fn start_heartbeat_monitoring(&mut self) {$/;"	P	implementation:FaultTolerantDistributedTrainingAggregator
start_message_handler	src/chain/node.rs	/^    pub async fn start_message_handler(&self) {$/;"	P	implementation:Node
start_message_handler	src/chain/state_channel.rs	/^    pub async fn start_message_handler(&mut self) {$/;"	P	implementation:ChannelManagerOptimized
start_shard_message_handler	src/chain/sharding.rs	/^    pub async fn start_shard_message_handler(&self) {$/;"	P	implementation:Sharding
start_time	src/api/models/request/governance_request.rs	/^    pub start_time: Option<u64>,$/;"	m	struct:GetProposalsRequest
start_time	src/chain/governance/proposal.rs	/^    pub start_time: Timestamp,$/;"	m	struct:Proposal
start_timer	src/hdcmodels/performance_optimization/profiling.rs	/^    pub fn start_timer(&mut self, label: &str) {$/;"	P	implementation:Profiler
start_training	src/hdcmodels/distributed_training/distributed_framework.rs	/^    pub async fn start_training(&mut self, aggregator_address: &str) {$/;"	P	implementation:DistributedTrainingNode
start_training	src/hdcmodels/distributed_training/distributed_framework.rs	/^    pub async fn start_training(&mut self, num_nodes: usize, dataset: Dataset) {$/;"	P	implementation:DistributedTrainingAggregator
start_training	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    pub async fn start_training(&mut self, aggregator_address: &str) {$/;"	P	implementation:FaultTolerantDistributedTrainingNode
start_training	src/hdcmodels/distributed_training/fault_tolerance.rs	/^    pub async fn start_training(&mut self, num_nodes: usize, dataset: Dataset) {$/;"	P	implementation:FaultTolerantDistributedTrainingAggregator
start_training	src/hdcmodels/distributed_training/load_balancing.rs	/^    pub async fn start_training(&mut self, num_nodes: usize, dataset: Dataset) {$/;"	P	implementation:LoadBalancedDistributedTrainingAggregator
start_transaction	src/smart_contract/execution_context.rs	/^    pub fn start_transaction(&mut self) {$/;"	P	implementation:ExecutionContext
start_ui	src/ui.rs	/^pub fn start_ui(blockchain: Arc<Mutex<Blockchain>>) -> Result<(), io::Error> {$/;"	f
start_voting	src/chain/governance/proposal.rs	/^    pub async fn start_voting($/;"	P	implementation:Proposal
start_voting	src/chain/quantum_voting/quantum_voting.rs	/^    pub fn start_voting($/;"	P	implementation:QuantumVoting
state	src/chain/blockchain.rs	/^    state: Arc<RwLock<ChainState>>,$/;"	m	struct:Blockchain
state	src/chain/mod.rs	/^mod state;$/;"	n
state	src/chain/storage/snapshot.rs	/^    pub state: State,$/;"	m	struct:Snapshot
state	src/crypto/quantum_state.rs	/^    state: Vec<Vec<Complex64>>,$/;"	m	struct:TimeBinState
state	src/qup/consensus.rs	/^    pub state: Arc<QUPState>,$/;"	m	struct:QUPConsensus
state	src/qup/delegator.rs	/^    pub state: Arc<QUPState>,$/;"	m	struct:QUPDelegator
state	src/qup/lib.rs	/^pub mod state;$/;"	n
state	src/qup/mod.rs	/^pub mod state;$/;"	n
state	src/qup/validator.rs	/^    pub state: Arc<QUPState>,$/;"	m	struct:QUPValidator
state	src/smart_contract/execution_context.rs	/^    pub state: HashMap<String, Value>,$/;"	m	struct:ExecutionContext
state_channel	src/chain/mod.rs	/^mod state_channel;$/;"	n
state_channel_api	src/chain/state_channel.rs	/^pub fn state_channel_api($/;"	f
state_db	src/chain/state/mod.rs	/^mod state_db;$/;"	n
state_db	src/chain/state/state_manager.rs	/^    state_db: Arc<RwLock<StateDB>>,$/;"	m	struct:StateManager
state_db	src/qup/state.rs	/^    pub state_db: StateDB,$/;"	m	struct:QUPState
state_manager	src/chain/state/mod.rs	/^mod state_manager;$/;"	n
state_manager	src/chain/state/state_transition.rs	/^    state_manager: Arc<StateManager>,$/;"	m	struct:StateTransition
state_manager	src/chain/state_transition.rs	/^    state_manager: Arc<StateManager>,$/;"	m	struct:StateTransition
state_manager	src/hdcmodels/benchmark.rs	/^    state_manager: Arc<StateManager>,$/;"	m	struct:AccuracyBenchmark
state_mutex	src/chain/blockchain.rs	/^    state_mutex: Arc<Mutex<()>>,$/;"	m	struct:Blockchain
state_preparation	src/chain/quantum_voting/mod.rs	/^    state_preparation: QuantumStatePreparation,$/;"	m	struct:QuantumVoting
state_root	src/chain/block.rs	/^    pub state_root: String,$/;"	m	struct:Block
state_storage	src/chain/storage/mod.rs	/^mod state_storage;$/;"	n
state_sync	src/network/lib.rs	/^    pub state_sync: StateSync,$/;"	m	struct:Network
state_sync	src/network/mod.rs	/^    state_sync: StateSync,$/;"	m	struct:Network
state_sync	src/network/sync/mod.rs	/^mod state_sync;/;"	n
state_sync_channel	src/network/sync/state_sync.rs	/^    state_sync_channel: (Sender<StateSyncMessage>, Receiver<StateSyncMessage>),$/;"	m	struct:StateSync
state_transition	src/chain/blockchain.rs	/^    state_transition: Arc<StateTransition>,$/;"	m	struct:Blockchain
state_transition	src/chain/state/mod.rs	/^mod state_transition;$/;"	n
state_transition_utils	src/chain/state_transition.rs	/^pub(crate) mod state_transition_utils {$/;"	n
state_verification	src/chain/quantum_voting/mod.rs	/^    state_verification: QuantumStateVerification,$/;"	m	struct:QuantumVoting
stats	src/api/models/response/network_response.rs	/^    pub stats: NetworkStats,$/;"	m	struct:GetNetworkStatsResponse
status	src/api/handlers/governance_handler.rs	/^    status: String,$/;"	m	struct:ProposalInfo
status	src/api/handlers/transaction_handler.rs	/^    status: String,$/;"	m	struct:TransactionStatusResponse
status	src/api/models/request/governance_request.rs	/^    pub status: Option<ProposalStatus>,$/;"	m	struct:GetProposalsRequest
status	src/api/models/request/transaction_request.rs	/^    pub status: TransactionStatusType,$/;"	m	struct:TransactionStatus
status	src/api/routes/governance.rs	/^    status: String,$/;"	m	struct:ProposalInfo
status	src/api/routes/transaction.rs	/^    status: String,$/;"	m	struct:TransactionStatusResponse
status	src/chain/governance/proposal.rs	/^    pub status: ProposalStatus,$/;"	m	struct:Proposal
status	src/chain/state_channel.rs	/^    pub status: ArbitrationStatus,$/;"	m	struct:Arbitration
stop	src/mining/miner.rs	/^    pub fn stop(&mut self) {$/;"	P	implementation:Miner
stop_timer	src/hdcmodels/performance_optimization/profiling.rs	/^    pub fn stop_timer(&mut self, label: &str) {$/;"	P	implementation:Profiler
storage	src/chain/blockchain.rs	/^    storage: Arc<BlockchainStorage>,$/;"	m	struct:Blockchain
storage	src/chain/mod.rs	/^mod storage;$/;"	n
storage	src/chain/state/account.rs	/^    pub storage: HashMap<String, String>,$/;"	m	struct:Account
store_encrypted	src/secure_core/secure_storage.rs	/^    pub fn store_encrypted(&self, key: &str, encrypted_data: &EncryptedData) -> Result<(), Secur/;"	P	implementation:SecureStorage
store_key	src/secure_core/secure_vault.rs	/^    pub fn store_key(&self, id: &str, private_key: PrivateKey) {$/;"	P	implementation:SecureVault
store_key_pair	src/chain/wallet.rs	/^    pub fn store_key_pair(&self, key_pair: &PostQuantumKeyPair) -> Result<(), WalletError> {$/;"	P	implementation:Wallet
store_keypair	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn store_keypair(&self, key_id: &str, public_key: &PublicKey, signing_key: &SigningKey) /;"	P	implementation:QuantumResistantSigner
store_post_quantum_key	src/secure_core/secure_vault.rs	/^    pub fn store_post_quantum_key(&self, id: &str, post_quantum_keypair: PostQuantumKeyPair) -> /;"	P	implementation:SecureVault
store_session_key	src/secure_core/secure_communication.rs	/^    pub fn store_session_key(&self, session_id: &str, key: &[u8; 32]) {$/;"	P	implementation:SecureCommunication
store_sp_key	src/secure_core/secure_vault.rs	/^    fn store_sp_key(&self, sp_key_id: &str, encrypted_sp_key: &[u8], authorized_user_ids: &[Stri/;"	P	implementation:SecureVault
store_vote	src/chain/quantum_voting/vote_collection.rs	/^    fn store_vote(&self, vote: &Vote, candidate: &Candidate) -> Result<(), VotingError> {$/;"	P	implementation:VoteCollection
str	src/secure_core/secure_vault.rs	/^    const BACKUP_KEY_STORAGE_PATH: &'static str = "\/path\/to\/secure\/backup\/location";$/;"	v	implementation:SecureVault
stream	src/network/quantum_resistant.rs	/^    stream: TcpStream,$/;"	m	struct:QuantumChannel
stream	src/network/tls.rs	/^    stream: Stream<TcpStream<'a>>,$/;"	m	struct:PostQuantumTLSConnection
sub	src/api/middleware/authentication.rs	/^    sub: String,$/;"	m	struct:Claims
sub	src/api/middleware/authentication.rs	/^    sub: String,$/;"	m	struct:RefreshTokenClaims
sub	src/zkp/math.rs	/^    fn sub(self, other: Self) -> Self {$/;"	P	implementation:FieldElement
sub_assign	src/zkp/math.rs	/^    fn sub_assign(&mut self, other: Self) {$/;"	P	implementation:FieldElement
subject	src/chain/node.rs	/^    pub subject: String,$/;"	m	struct:PostQuantumCertificateSigningRequest
submission_time	src/api/handlers/governance_handler.rs	/^    submission_time: u64,$/;"	m	struct:ProposalInfo
submission_time	src/api/routes/governance.rs	/^    submission_time: u64,$/;"	m	struct:ProposalInfo
submit_transaction	src/api/handlers/transaction_handler.rs	/^pub async fn submit_transaction($/;"	f
submit_transaction	src/api/routes/transaction.rs	/^async fn submit_transaction($/;"	f
summarize_proposal	src/hdcmodels/governance_integration/proposal_analysis.rs	/^    pub fn summarize_proposal(&self, proposal: &Proposal) -> String {$/;"	P	implementation:ProposalAnalyzer
swarm	src/network/discovery.rs	/^    swarm: Swarm<Kademlia<MemoryStore>>,$/;"	m	struct:Discovery
sync	src/network/lib.rs	/^pub mod sync;$/;"	n
sync	src/network/mod.rs	/^pub mod sync;$/;"	n
synchronize_model_update	src/hdcmodels/distributed_training/synchronization.rs	/^    pub async fn synchronize_model_update(&self, model_update: Vec<f64>) {$/;"	P	implementation:Synchronizer
synchronize_shards	src/chain/sharding.rs	/^    pub async fn synchronize_shards(&self) {$/;"	P	implementation:Sharding
synchronize_state	src/chain/shard.rs	/^    async fn synchronize_state(&self) {$/;"	P	implementation:Shard
tally_votes	src/chain/quantum_voting/vote_tallying.rs	/^    pub fn tally_votes($/;"	P	implementation:VoteTallying
teleport_quantum_state	src/chain/quantum_voting/quantum_communication.rs	/^    fn teleport_quantum_state($/;"	P	implementation:QuantumCommunication
teleport_quantum_state_back	src/chain/quantum_voting/quantum_communication.rs	/^    fn teleport_quantum_state_back($/;"	P	implementation:QuantumCommunication
teleportation_protocol	src/chain/quantum_voting/quantum_communication.rs	/^    teleportation_protocol: QuantumTeleportationProtocol,$/;"	m	struct:QuantumCommunication
test_add_off_chain_transaction	src/chain/state_channel.rs	/^    async fn test_add_off_chain_transaction() {$/;"	f	module:tests
test_apply_block	src/qup/tests/state_tests.rs	/^fn test_apply_block() {$/;"	f
test_calculate_hash	src/chain/block_tests.rs	/^    fn test_calculate_hash() {$/;"	f	module:block_tests
test_calculate_merkle_root	src/chain/block_tests.rs	/^    fn test_calculate_merkle_root() {$/;"	f	module:block_tests
test_calculate_rewards	src/qup/tests/state_tests.rs	/^fn test_calculate_rewards() {$/;"	f
test_calculate_total_reward	src/qup/tests/rewards_tests.rs	/^fn test_calculate_total_reward() {$/;"	f
test_calculate_validator_reward	src/qup/tests/rewards_tests.rs	/^fn test_calculate_validator_reward() {$/;"	f
test_claim_rewards	src/qup/tests/delegator_tests.rs	/^fn test_claim_rewards() {$/;"	f
test_close_state_channel	src/chain/state_channel.rs	/^    async fn test_close_state_channel() {$/;"	f	module:tests
test_create_state_channel	src/chain/state_channel.rs	/^    async fn test_create_state_channel() {$/;"	f	module:tests
test_delegate_and_undelegate	src/qup/tests/delegator_tests.rs	/^fn test_delegate_and_undelegate() {$/;"	f
test_difficulty_adjustment	src/chain/block_tests.rs	/^    fn test_difficulty_adjustment() {$/;"	f
test_distribute_rewards	src/qup/tests/rewards_tests.rs	/^fn test_distribute_rewards() {$/;"	f
test_encode_decode_block	src/qup/tests/hdcomm_tests.rs	/^fn test_encode_decode_block() {$/;"	f
test_encryption_and_decryption	src/qup/tests/crypto_tests.rs	/^fn test_encryption_and_decryption() {$/;"	f
test_hashing	src/qup/tests/crypto_tests.rs	/^fn test_hashing() {$/;"	f
test_key_generation	src/qup/tests/crypto_tests.rs	/^fn test_key_generation() {$/;"	f
test_merkle_root_reflects_transaction_changes	src/chain/block_tests.rs	/^    fn test_merkle_root_reflects_transaction_changes() {$/;"	f
test_mine_block	src/chain/block_tests.rs	/^    fn test_mine_block() {$/;"	f	module:block_tests
test_propose_and_validate_block	src/qup/tests/validator_tests.rs	/^fn test_propose_and_validate_block() {$/;"	f
test_propose_block	src/qup/tests/consensus_tests.rs	/^fn test_propose_block() {$/;"	f
test_protocol_message_serialization	src/network/tests/protocol.rs	/^    async fn test_protocol_message_serialization() {$/;"	f	module:tests
test_signing_and_verification	src/qup/tests/crypto_tests.rs	/^fn test_signing_and_verification() {$/;"	f
test_similarity	src/qup/tests/hdcomm_tests.rs	/^fn test_similarity() {$/;"	f
test_stake_and_unstake	src/qup/tests/delegator_tests.rs	/^fn test_stake_and_unstake() {$/;"	f
test_stake_and_unstake	src/qup/tests/validator_tests.rs	/^fn test_stake_and_unstake() {$/;"	f
test_useful_work	src/qup/tests/hdcomm_tests.rs	/^fn test_useful_work() {$/;"	f
test_useful_work	src/qup/tests/validator_tests.rs	/^fn test_useful_work() {$/;"	f
test_validate_block	src/chain/block_tests.rs	/^    fn test_validate_block() {$/;"	f	module:block_tests
test_validate_block	src/qup/tests/consensus_tests.rs	/^fn test_validate_block() {$/;"	f
tests	src/chain/state_channel.rs	/^mod tests {$/;"	n
tests	src/network/tests/protocol.rs	/^mod tests {$/;"	n
text	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub text: String,$/;"	m	struct:StackEntry
threshold	src/chain/governance/voting.rs	/^    pub threshold: u64,$/;"	m	struct:Voting
timestamp	src/api/handlers/blockchain_handler.rs	/^    timestamp: u64,$/;"	m	struct:BlockInfo
timestamp	src/api/handlers/blockchain_handler.rs	/^    timestamp: u64,$/;"	m	struct:TransactionInfo
timestamp	src/api/handlers/transaction_handler.rs	/^    timestamp: u64,$/;"	m	struct:TransactionInfo
timestamp	src/api/models/request/blockchain_request.rs	/^    pub timestamp: u64,$/;"	m	struct:BlockHeader
timestamp	src/api/models/request/transaction_request.rs	/^    pub timestamp: u64,$/;"	m	struct:Transaction
timestamp	src/api/models/response/blockchain_response.rs	/^    pub timestamp: u64,$/;"	m	struct:BlockHeader
timestamp	src/api/models/response/blockchain_response.rs	/^    pub timestamp: u64,$/;"	m	struct:TransactionData
timestamp	src/api/routes/blockchain.rs	/^    timestamp: u64,$/;"	m	struct:BlockInfo
timestamp	src/api/routes/blockchain.rs	/^    timestamp: u64,$/;"	m	struct:TransactionInfo
timestamp	src/api/routes/transaction.rs	/^    timestamp: u64,$/;"	m	struct:TransactionInfo
timestamp	src/chain/block.rs	/^    pub timestamp: u64,$/;"	m	struct:Block
timestamp	src/chain/governance/voting.rs	/^    pub timestamp: i64,$/;"	m	struct:Vote
timestamp	src/optimization_problems/hdc_code_generation/dataset.rs	/^    pub timestamp: String,$/;"	m	struct:StackEntry
timestamp	src/qup/block.rs	/^    pub timestamp: u64,$/;"	m	struct:QUPBlock
timestamp	src/qup/types.rs	/^    pub timestamp: u64,$/;"	m	struct:QUPBlockHeader
timings	src/hdcmodels/performance_optimization/profiling.rs	/^    timings: HashMap<String, Duration>,$/;"	m	struct:Profiler
title	src/api/handlers/governance_handler.rs	/^    title: String,$/;"	m	struct:ProposalInfo
title	src/api/models/request/governance_request.rs	/^    pub title: String,$/;"	m	struct:SubmitProposalRequest
title	src/api/routes/governance.rs	/^    title: String,$/;"	m	struct:ProposalInfo
title	src/chain/governance/proposal.rs	/^    pub title: String,$/;"	m	struct:Proposal
tls	src/network/mod.rs	/^pub mod tls;$/;"	n
tls_certificate_path	src/network/config.rs	/^    pub tls_certificate_path: Option<String>,$/;"	m	struct:NetworkConfig
tls_private_key_path	src/network/config.rs	/^    pub tls_private_key_path: Option<String>,$/;"	m	struct:NetworkConfig
to	src/qup/types.rs	/^    pub to: Vec<u8>,$/;"	m	struct:QUPTransaction
to_bytes	src/chain/governance/proposal.rs	/^    pub fn to_bytes(&self) -> Vec<u8> {$/;"	P	implementation:ProposalStatus
to_bytes	src/optimization_problems/problem_solution.rs	/^    pub fn to_bytes(&self) -> Result<Vec<u8>, bincode::Error> {$/;"	P	implementation:ProblemSolution
to_hex	src/types/address.rs	/^    pub fn to_hex(&self) -> String {$/;"	P	implementation:Address
to_string	src/hdcmodels/hdcmodels.rs	/^    pub fn to_string(&self) -> String {$/;"	P	implementation:Transaction
to_string	src/utils/node_id.rs	/^    pub fn to_string(&self) -> String {$/;"	P	implementation:NodeId
to_vec	src/hdcmodels/parallel_processing.rs	/^    fn to_vec(&self) -> Vec<DataItem> {$/;"	P	implementation:Dataset
to_vec	src/hdcmodels/parallel_processing.rs	/^    fn to_vec(&self) -> Vec<DataItem>;$/;"	P	interface:DatasetExt
token	src/api/middleware/authentication.rs	/^    token: String,$/;"	m	struct:RevokeTokenRequest
token_pattern	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    token_pattern: Regex,$/;"	m	struct:Preprocessor
token_type	src/api/middleware/authentication.rs	/^    token_type: String,$/;"	m	struct:RefreshTokenClaims
tokenize	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    fn tokenize(&self, snippet: &str) -> Vec<String> {$/;"	P	implementation:Evaluator
tokenize_natural_language	src/hdcmodels/encoding.rs	/^fn tokenize_natural_language(text: &str) -> Vec<String> {$/;"	f
tokenize_rust_code	src/hdcmodels/encoding.rs	/^fn tokenize_rust_code(code: &str) -> Vec<String> {$/;"	f
tokenize_smart_contract	src/hdcmodels/encoding.rs	/^fn tokenize_smart_contract(contract: &str, n: usize) -> Vec<String> {$/;"	f
tokens	src/api/middleware/rate_limiter.rs	/^    tokens: usize,$/;"	m	struct:ClientBucket
tomography	src/chain/quantum_voting/quantum_state_verification.rs	/^    tomography: QuantumStateTomography,$/;"	m	struct:QuantumStateVerification
total_bytes_received	src/api/handlers/network_handler.rs	/^    total_bytes_received: u64,$/;"	m	struct:NetworkStats
total_bytes_received	src/api/models/response/network_response.rs	/^    pub total_bytes_received: u64,$/;"	m	struct:NetworkStats
total_bytes_received	src/api/routes/network.rs	/^    total_bytes_received: u64,$/;"	m	struct:NetworkStats
total_bytes_sent	src/api/handlers/network_handler.rs	/^    total_bytes_sent: u64,$/;"	m	struct:NetworkStats
total_bytes_sent	src/api/models/response/network_response.rs	/^    pub total_bytes_sent: u64,$/;"	m	struct:NetworkStats
total_bytes_sent	src/api/routes/network.rs	/^    total_bytes_sent: u64,$/;"	m	struct:NetworkStats
total_peers	src/api/handlers/network_handler.rs	/^    total_peers: usize,$/;"	m	struct:NetworkStats
total_peers	src/api/models/response/network_response.rs	/^    pub total_peers: usize,$/;"	m	struct:NetworkStats
total_peers	src/api/routes/network.rs	/^    total_peers: usize,$/;"	m	struct:NetworkStats
total_shards	src/chain/shard.rs	/^    pub total_shards: u64,$/;"	m	struct:Shard
total_shards	src/chain/sharding.rs	/^    total_shards: u64,$/;"	m	struct:Sharding
total_stake	src/api/models/response/qup_response.rs	/^    pub total_stake: u64,$/;"	m	struct:QUPState
total_stake	src/qup/state.rs	/^    pub total_stake: u64,$/;"	m	struct:QUPState
total_staked	src/chain/governance/staking.rs	/^    pub total_staked: u64,$/;"	m	struct:Staking
total_transactions	src/api/models/response/blockchain_response.rs	/^    pub total_transactions: u64,$/;"	m	struct:GetChainInfoResponse
total_voting_power	src/api/handlers/governance_handler.rs	/^    total_voting_power: f64,$/;"	m	struct:VotingPower
total_voting_power	src/api/routes/governance.rs	/^    total_voting_power: f64,$/;"	m	struct:VotingPower
total_voting_power	src/chain/governance/voting.rs	/^    pub total_voting_power: u64,$/;"	m	struct:Voting
train	src/hdcmodels/hdcmodels.rs	/^    pub fn train(&mut self, dataset: &Dataset) -> Vec<Vec<f64>> {$/;"	P	implementation:HDCModel
train	src/hdcmodels/mod.rs	/^    pub fn train(&self, rust_code_snippets: &[String], natural_language_descriptions: &[String])/;"	P	implementation:HDCModel
train	src/hdcmodels/model_integration/hybrid_models.rs	/^    pub fn train($/;"	P	implementation:HybridModel
train	src/hdcmodels/parallel_processing.rs	/^    pub fn train(&self, model: &mut HDCModel, dataset: &Dataset) -> Vec<Vec<f64>> {$/;"	P	implementation:ParallelHDCTrainer
train	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    pub fn train(&mut self, data: &[Vec<f64>], labels: &[String]) {$/;"	P	implementation:GPUHDCModel
train	src/hdcmodels/performance_optimization/optimization_strategies.rs	/^    pub fn train(&mut self, data: &[Vec<f64>], labels: &[String]) {$/;"	P	implementation:OptimizedHDCModel
train_model	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn train_model(&mut self) {$/;"	P	implementation:DistributedTrainingNode
trained_models	src/hdcmodels/distributed_training/distributed_framework.rs	/^    trained_models: Vec<Vec<Vec<f64>>>,$/;"	m	struct:DistributedTrainingAggregator
trainer	src/optimization_problems/hdc_code_generation/mod.rs	/^mod trainer;$/;"	n
trainer_channel	src/hdcmodels/distributed_training/distributed_framework.rs	/^    trainer_channel: Option<Receiver<DistributedTrainingMessage>>,$/;"	m	struct:DistributedTrainingNode
training_data	src/hdcmodels/distributed_training/distributed_framework.rs	/^    training_data: Option<Dataset>,$/;"	m	struct:DistributedTrainingNode
training_loop	src/hdcmodels/distributed_training/distributed_framework.rs	/^    async fn training_loop(&mut self) {$/;"	P	implementation:DistributedTrainingNode
transaction	src/api/models/request/blockchain_request.rs	/^    pub transaction: TransactionData,$/;"	m	struct:SubmitTransactionRequest
transaction	src/api/models/response/blockchain_response.rs	/^    pub transaction: TransactionData,$/;"	m	struct:GetTransactionResponse
transaction	src/chain/mod.rs	/^pub(crate) mod transaction;$/;"	n
transaction_fee_percentage	src/mining/mining_config.rs	/^    pub fn transaction_fee_percentage(&self) -> f64 {$/;"	P	implementation:MiningConfig
transaction_fee_percentage	src/mining/mining_config.rs	/^    transaction_fee_percentage: f64,$/;"	m	struct:MiningConfig
transaction_hash	src/api/models/request/transaction_request.rs	/^    pub transaction_hash: String,$/;"	m	struct:GetTransactionRequest
transaction_hash	src/api/models/request/transaction_request.rs	/^    pub transaction_hash: String,$/;"	m	struct:TransactionStatus
transaction_index	src/utils/indexing.rs	/^    pub transaction_index: TransactionIndex,$/;"	m	struct:BlockchainIndexer
transaction_pool	src/mining/miner.rs	/^    transaction_pool: Arc<Mutex<TransactionPool>>,$/;"	m	struct:Miner
transaction_pool	src/mining/mod.rs	/^mod transaction_pool;$/;"	n
transaction_routes	src/api/routes/transaction.rs	/^pub fn transaction_routes(cfg: &mut web::ServiceConfig) {$/;"	f
transaction_stack	src/smart_contract/execution_context.rs	/^    pub transaction_stack: VecDeque<TransactionContext>,$/;"	m	struct:ExecutionContext
transactions	src/api/handlers/transaction_handler.rs	/^    transactions: Vec<TransactionInfo>,$/;"	m	struct:TransactionHistoryResponse
transactions	src/api/models/request/blockchain_request.rs	/^    pub transactions: Vec<TransactionData>,$/;"	m	struct:BlockData
transactions	src/api/models/response/blockchain_response.rs	/^    pub transactions: Vec<TransactionData>,$/;"	m	struct:BlockData
transactions	src/api/models/response/blockchain_response.rs	/^    pub transactions: Vec<TransactionData>,$/;"	m	struct:GetTransactionsResponse
transactions	src/api/routes/transaction.rs	/^    transactions: Vec<TransactionInfo>,$/;"	m	struct:TransactionHistoryResponse
transactions	src/chain/block.rs	/^    pub transactions: Vec<Arc<Transaction>>,$/;"	m	struct:Block
transactions	src/chain/shard.rs	/^    pub transactions: Arc<RwLock<VecDeque<Vec<u8>>>>,$/;"	m	struct:Shard
transactions	src/chain/shard.rs	/^    pub transactions: Vec<Transaction>,$/;"	m	struct:ShardState
transactions	src/hdcmodels/transaction_optimization/transaction_encoding.rs	/^    pub transactions: Vec<Transaction>,$/;"	m	struct:StateTransition
transactions	src/mining/transaction_pool.rs	/^    transactions: Mutex<HashSet<Transaction>>,$/;"	m	struct:TransactionPool
transactions	src/qup/block.rs	/^    pub transactions: Vec<Transaction>,$/;"	m	struct:QUPBlock
transactions_count	src/api/handlers/blockchain_handler.rs	/^    transactions_count: usize,$/;"	m	struct:BlockInfo
transactions_count	src/api/routes/blockchain.rs	/^    transactions_count: usize,$/;"	m	struct:BlockInfo
transcript	src/zkp/mod.rs	/^mod transcript;$/;"	n
transfer	src/chain/governance/treasury.rs	/^    pub fn transfer(&mut self, recipient: String, amount: u64) -> Result<(), String> {$/;"	P	implementation:Treasury
transformer	src/hdcmodels/model_integration/hybrid_models.rs	/^    transformer: nn::Sequential,$/;"	m	struct:HybridModel
transformer_to_hdc	src/hdcmodels/model_integration/data_conversion.rs	/^    pub fn transformer_to_hdc(tensors: &[Tensor], hdc_dimension: usize) -> Vec<Vec<f64>> {$/;"	P	implementation:DataConverter
treasury	src/chain/governance/governance_engine.rs	/^    treasury: Arc<Treasury>,$/;"	m	struct:GovernanceEngine
treasury	src/chain/governance/mod.rs	/^mod treasury;$/;"	n
trigger_security_measures	src/hdcmodels/governance_integration/consensus_security.rs	/^    fn trigger_security_measures(&self) {$/;"	P	implementation:ConsensusSecurityMonitor
truncate	src/optimization_problems/hdc_code_generation/preprocessor.rs	/^    fn truncate(&self, snippet: &str) -> String {$/;"	P	implementation:Preprocessor
truncate_validity_period	src/chain/certificate_authority.rs	/^    fn truncate_validity_period($/;"	P	implementation:CertificateAuthority
truthy	src/smart_contract/interpreter.rs	/^    fn truthy(value: &Value) -> bool {$/;"	P	implementation:Interpreter
try_with_context	src/error_handling/error_utils.rs	/^macro_rules! try_with_context {$/;"	M
tx_pool	src/network/mod.rs	/^    tx_pool: RwLock<HashMap<Hasher, Transaction>>,$/;"	m	struct:Network
types	src/chain/quantum_voting/mod.rs	/^mod types;$/;"	n
types	src/main.rs	/^mod types; \/\/ Common data types and structures$/;"	n
types	src/qup/lib.rs	/^pub mod types;$/;"	n
types	src/smart_contract/lib.rs	/^pub mod types;$/;"	n
types	src/smart_contract/mod.rs	/^mod types;$/;"	n
ui	src/main.rs	/^mod ui; \/\/ User interface for interacting with the blockchain$/;"	n
unblind_vote_state	src/chain/quantum_voting/voting_protocols.rs	/^    fn unblind_vote_state($/;"	P	implementation:VotingProtocols
undelegate	src/qup/delegator.rs	/^    pub fn undelegate(&mut self, amount: u64) -> Result<(), Error> {$/;"	P	implementation:QUPDelegator
undelegate	src/qup/validator.rs	/^    pub fn undelegate(&mut self, delegator: &Address, amount: u64) {$/;"	P	implementation:QUPValidator
unstake	src/chain/governance/governance_engine.rs	/^    pub async fn unstake(&mut self, staker: String, amount: u64) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
unstake	src/chain/governance/staking.rs	/^    pub async fn unstake($/;"	P	implementation:Staking
unstake	src/qup/delegator.rs	/^    pub fn unstake(&mut self, amount: u64) {$/;"	P	implementation:QUPDelegator
unstake	src/qup/validator.rs	/^    pub fn unstake(&mut self, amount: u64) {$/;"	P	implementation:QUPValidator
update	src/hdcmodels/continuous_learning/incremental_learning.rs	/^    pub fn update(&mut self, data: &[f64], label: &str) {$/;"	P	implementation:IncrementalLearningHDCModel
update	src/hdcmodels/continuous_learning/online_learning.rs	/^    pub fn update(&mut self, data: &[f64], label: &str) {$/;"	P	implementation:OnlineLearningHDCModel
update	src/qup/crypto.rs	/^    fn update(&mut self, data: &[u8]) {$/;"	P	implementation:QUPCrypto
update	src/zkp/crypto.rs	/^    fn update(&mut self, data: &[u8]) {$/;"	P	implementation:Blake3bHasher
update	src/zkp/crypto.rs	/^    fn update(&mut self, data: &[u8]);$/;"	P	interface:Hasher
update_account	src/chain/state/state_manager.rs	/^    pub fn update_account(&self, account: &Account) {$/;"	P	implementation:StateManager
update_account	src/qup/state.rs	/^    pub fn update_account(&mut self, account: Account) -> Result<(), Error> {$/;"	P	implementation:QUPState
update_account_trie	src/chain/state/state_db.rs	/^    fn update_account_trie(&mut self, account: &Account) {$/;"	P	implementation:StateDB
update_accuracy_benchmark	src/hdcmodels/benchmark.rs	/^    pub fn update_accuracy_benchmark(&self, proposal: AccuracyBenchmarkProposal) -> Result<()> {$/;"	P	implementation:AccuracyBenchmark
update_balance	src/utils/indexing.rs	/^    pub fn update_balance(&mut self, transaction: &Transaction) {$/;"	P	implementation:BalanceManager
update_candidate_voting_status	src/chain/quantum_voting/vote_collection.rs	/^    fn update_candidate_voting_status(&self, candidate: &Candidate) -> Result<(), VotingError> {$/;"	P	implementation:VoteCollection
update_contract	src/chain/storage/contract_storage.rs	/^    pub fn update_contract(&self, contract: &SmartContract) -> Result<(), ContractStorageError> /;"	P	implementation:ContractStorage
update_delegator	src/qup/state.rs	/^    pub fn update_delegator(&mut self, delegator: QUPDelegator) {$/;"	P	implementation:QUPState
update_latest_block_height	src/chain/storage/block_storage.rs	/^    pub fn update_latest_block_height(&self, height: u64) -> Result<(), BlockStorageError> {$/;"	P	implementation:BlockStorage
update_lock_period	src/chain/governance/staking.rs	/^    pub async fn update_lock_period($/;"	P	implementation:Staking
update_qup_state	src/chain/state/state_manager.rs	/^    pub fn update_qup_state(&self, new_state: QUPState) {$/;"	P	implementation:StateManager
update_reward_rate	src/chain/governance/rewards.rs	/^    pub async fn update_reward_rate($/;"	P	implementation:Rewards
update_reward_rate	src/chain/governance/staking.rs	/^    pub async fn update_reward_rate($/;"	P	implementation:Staking
update_shard_state	src/network/shard_message.rs	/^    async fn update_shard_state(&mut self, shard_id: u64, state: ShardState) -> Result<(), Netwo/;"	f
update_state	src/chain/block.rs	/^    fn update_state(&self, state: &mut State) -> Result<(), BlockError> {$/;"	P	implementation:Block
update_state	src/qup/validator.rs	/^    pub fn update_state(&mut self, block: &QUPBlock) {$/;"	P	implementation:QUPValidator
update_status	src/chain/governance/proposal.rs	/^    pub fn update_status($/;"	P	implementation:Proposal
update_validator	src/qup/state.rs	/^    pub fn update_validator(&mut self, validator: QUPValidator) {$/;"	P	implementation:QUPState
update_validator_set	src/chain/governance/governance_engine.rs	/^    pub async fn update_validator_set($/;"	P	implementation:GovernanceEngine
update_validator_state	src/chain/state/state_manager.rs	/^    pub fn update_validator_state(&self, validator: QUPValidator) {$/;"	P	implementation:StateManager
update_weights_gpu	src/hdcmodels/performance_optimization/hardware_acceleration.rs	/^    fn update_weights_gpu(&mut self, encoded_data: &Array<f64>, labels: &Array<u8>) {$/;"	P	implementation:HDCModel
updated_model	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub updated_model: HDCModel,$/;"	m	struct:SecureHDCModelUpdate
use_gas	src/smart_contract/execution_context.rs	/^    pub fn use_gas(&mut self, amount: u64) -> Result<(), String> {$/;"	P	implementation:ExecutionContext
use_tls	src/network/config.rs	/^    pub use_tls: bool,$/;"	m	struct:NetworkConfig
useful_work	src/chain/block.rs	/^    pub useful_work: Option<UsefulWork>,$/;"	m	struct:Block
useful_work	src/chain/state_channel.rs	/^    pub useful_work: Option<UsefulWorkSolution>,$/;"	m	struct:OffChainTransaction
useful_work	src/qup/block.rs	/^    pub useful_work: UsefulWork,$/;"	m	struct:QUPBlock
useful_work_config	src/qup/config.rs	/^    pub useful_work_config: UsefulWorkConfig,$/;"	m	struct:QUPConfig
useful_work_difficulty	src/api/handlers/qup_handler.rs	/^    useful_work_difficulty: u64,$/;"	m	struct:QUPParameters
useful_work_difficulty	src/api/models/request/qup_request.rs	/^    pub useful_work_difficulty: u64,$/;"	m	struct:QUPParameters
useful_work_difficulty	src/api/models/response/qup_response.rs	/^    pub useful_work_difficulty: u64,$/;"	m	struct:QUPParameters
useful_work_score	src/api/handlers/qup_handler.rs	/^    useful_work_score: f64,$/;"	m	struct:ValidatorInfo
useful_work_score	src/api/models/response/qup_response.rs	/^    pub useful_work_score: f64,$/;"	m	struct:ValidatorInfo
useful_work_solution	src/chain/transaction.rs	/^    pub useful_work_solution: Option<UsefulWorkSolution>,$/;"	m	struct:Transaction
useful_work_threshold	src/api/models/response/qup_response.rs	/^    pub useful_work_threshold: u64,$/;"	m	struct:QUPState
user_id	src/api/middleware/authentication.rs	/^    pub user_id: String,$/;"	m	struct:AuthenticatedUser
user_roles	src/secure_core/access_control.rs	/^    user_roles: Arc<RwLock<HashMap<String, Vec<Role>>>>,$/;"	m	struct:AccessControl
utils	src/chain/quantum_voting/mod.rs	/^mod utils;$/;"	n
utils	src/main.rs	/^mod utils; \/\/ Utility functions and modules$/;"	n
utils	src/qup/lib.rs	/^pub mod utils;$/;"	n
utils	src/zkp/mod.rs	/^mod utils;$/;"	n
validate	src/chain/block.rs	/^    pub fn validate(&self, qup_consensus: &QUPConsensus) -> Result<(), BlockError> {$/;"	P	implementation:Block
validate	src/chain/transaction.rs	/^    pub fn validate(&self, state: &State) -> Result<(), TransactionError> {$/;"	P	implementation:Transaction
validate	src/hdcmodels/hdcmodels.rs	/^    pub fn validate(&mut self, dataset: &Dataset, trained_model: &[Vec<f64>]) {$/;"	P	implementation:HDCModel
validate	src/hdcmodels/parallel_processing.rs	/^    pub fn validate(&self, model: &mut HDCModel, dataset: &Dataset, trained_model: &[Vec<f64>]) /;"	P	implementation:ParallelHDCValidator
validate	src/optimization_problems/hdc_code_generation/evaluator.rs	/^    pub fn validate(&self, model: &CodeGenerationModel) -> Result<EvaluationResult, String> {$/;"	P	implementation:Evaluator
validate	src/optimization_problems/optimization_problem.rs	/^    fn validate(&self, block: &Block, solution: &ProblemSolution) -> Result<bool, String>;$/;"	P	interface:OptimizationProblem
validate	src/qup/block.rs	/^    pub fn validate(&self, state: &QUPState, config: &QUPConfig) -> Result<(), Error> {$/;"	P	implementation:QUPBlock
validate_block	src/chain/validation.rs	/^pub fn validate_block($/;"	f
validate_block	src/chain/validator/validator.rs	/^    pub fn validate_block(&self, state: &State, consensus: &dyn Consensus) -> bool {$/;"	P	implementation:Validator
validate_block	src/qup/consensus.rs	/^    pub fn validate_block(&self, block: &QUPBlock) -> Result<bool, ConsensusError> {$/;"	P	implementation:QUPConsensus
validate_block	src/qup/validator.rs	/^    pub fn validate_block(&self, block: &QUPBlock) -> Result<bool, Error> {$/;"	P	implementation:QUPValidator
validate_block_transactions	src/chain/state_transition.rs	/^    pub fn validate_block_transactions(state_transition: &StateTransition, block: &Block) -> Res/;"	f	module:state_transition_utils
validate_candidate	src/chain/quantum_voting/utils.rs	/^pub fn validate_candidate(candidate: &Candidate) -> Result<(), VotingError> {$/;"	f
validate_chain	src/chain/blockchain.rs	/^    pub async fn validate_chain(&self) -> Result<(), BlockchainError> {$/;"	P	implementation:Blockchain
validate_csr	src/chain/certificate_authority.rs	/^    async fn validate_csr($/;"	P	implementation:CertificateAuthority
validate_for_qup	src/chain/transaction.rs	/^    pub fn validate_for_qup(&self, qup_state: &QUPState) -> Result<(), TransactionError> {$/;"	P	implementation:Transaction
validate_jwt	src/api/middleware/authentication.rs	/^fn validate_jwt(token: &str) -> Result<AuthenticatedUser, Error> {$/;"	f
validate_smart_contracts	src/chain/block.rs	/^    pub fn validate_smart_contracts(&self) -> Result<(), BlockError> {$/;"	P	implementation:Block
validate_smart_contracts	src/chain/validation.rs	/^fn validate_smart_contracts(smart_contracts: &[Arc<SmartContract>]) -> Result<(), ValidationErro/;"	f
validate_transaction	src/chain/state/state_transition.rs	/^    fn validate_transaction($/;"	P	implementation:StateTransition
validate_transaction	src/chain/state_transition.rs	/^    fn validate_transaction($/;"	P	implementation:StateTransition
validate_transaction	src/chain/validation.rs	/^pub fn validate_transaction($/;"	f
validate_transaction	src/chain/validator/validator.rs	/^    pub fn validate_transaction(&self, transaction: &Transaction) -> bool {$/;"	P	implementation:Validator
validation	src/chain/mod.rs	/^mod validation;$/;"	n
validator	src/chain/validator/mod.rs	/^pub mod validator;$/;"	n
validator	src/network/network_manager.rs	/^    validator: Option<QUPValidator>,$/;"	m	struct:NetworkManager
validator	src/qup/lib.rs	/^pub mod validator;$/;"	n
validator	src/qup/mod.rs	/^pub mod validator;$/;"	n
validator_manager	src/chain/sharding.rs	/^    validator_manager: Arc<ValidatorManager>,$/;"	m	struct:Sharding
validator_reward_ratio	src/api/models/response/qup_response.rs	/^    pub validator_reward_ratio: f64,$/;"	m	struct:QUPParameters
validator_reward_ratio	src/qup/config.rs	/^    pub validator_reward_ratio: f64,$/;"	m	struct:QUPConfig
validator_signature	src/chain/block.rs	/^    pub validator_signature: Option<PostQuantumSignature>,$/;"	m	struct:Block
validator_signature	src/qup/block.rs	/^    pub validator_signature: QUPSignature,$/;"	m	struct:QUPBlock
validators	src/api/handlers/qup_handler.rs	/^    validators: Vec<String>, \/\/ list of validator public keys$/;"	m	struct:QUPState
validators	src/api/models/response/qup_response.rs	/^    pub validators: Vec<String>, \/\/ List of validator public keys$/;"	m	struct:QUPState
validators	src/api/models/response/qup_response.rs	/^    pub validators: Vec<ValidatorInfo>,$/;"	m	struct:GetValidatorsResponse
validators	src/api/routes/consensus.rs	/^    validators: Vec<String>, \/\/ list of validator public keys$/;"	m	struct:QDPoSState
validators	src/qup/state.rs	/^    pub validators: HashMap<Address, QUPValidator>,$/;"	m	struct:QUPState
validity_period	src/chain/node.rs	/^    pub validity_period: Validity,$/;"	m	struct:PostQuantumCertificateSigningRequest
value	src/api/models/request/smart_contract_request.rs	/^    pub value: String,$/;"	m	struct:ContractFunctionInput
value	src/chain/state/merkle_trie.rs	/^    pub value: Option<Arc<[u8]>>,$/;"	m	struct:TrieNode
values	src/qup/types.rs	/^    pub values: Vec<u64>,$/;"	m	struct:KnapsackProblem
variable	src/zkp/constraint_system.rs	/^    pub fn variable(variable: Variable) -> Self {$/;"	P	implementation:Expression
variable	src/zkp/constraint_system.rs	/^    pub variable: Variable,$/;"	m	struct:RangeConstraint
variable_map	src/zkp/constraint_system.rs	/^    pub variable_map: HashMap<Variable, FieldElement>,$/;"	m	struct:ConstraintSystemImpl
variables	src/api/handlers/smart_contract_handler.rs	/^    variables: Vec<(String, String)>,$/;"	m	struct:ContractState
variables	src/api/models/request/smart_contract_request.rs	/^    pub variables: Vec<(String, String)>,$/;"	m	struct:ContractState
variables	src/api/routes/smart_contract.rs	/^    variables: Vec<(String, String)>,$/;"	m	struct:ContractState
variables	src/zkp/constraint_system.rs	/^    pub variables: Vec<FieldElement>,$/;"	m	struct:ConstraintSystemImpl
verifier	src/chain/quantum_voting/quantum_state_verification.rs	/^    verifier: QuantumStateVerifier,$/;"	m	struct:QuantumStateVerification
verify	src/chain/quantum_entropy.rs	/^    pub fn verify(&self, message: &[u8], signature: &Signature, public_key: &PublicKey) -> bool /;"	P	implementation:QuantumEntropySource
verify	src/crypto/post_quantum.rs	/^    pub fn verify(&self, message: &[u8], signature: &DilithiumSignature) -> Result<(), PostQuant/;"	P	implementation:DilithiumKeypair
verify	src/crypto/post_quantum.rs	/^    pub fn verify(&self, message: &[u8], signature: &DilithiumSignature) -> Result<(), PostQuant/;"	P	implementation:DilithiumPublicKey
verify	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub fn verify(&self, public_key: &[u8]) -> bool {$/;"	P	implementation:SecureHDCModelUpdate
verify	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub fn verify(&self, public_key: &[u8]) -> bool {$/;"	P	implementation:SecureHDCModelUpdateVote
verify	src/qup/crypto.rs	/^    fn verify($/;"	P	implementation:QUPCrypto
verify	src/qup/crypto.rs	/^    pub fn verify($/;"	P	implementation:QUPCrypto
verify	src/qup/hdcomm.rs	/^    pub fn verify(&self, problem: &UsefulWorkProblem, state: &QUPState) -> bool {$/;"	P	implementation:UsefulWorkSolution
verify	src/secure_core/quantum_resistant_signatures.rs	/^    pub fn verify($/;"	P	implementation:QuantumResistantSigner
verify	src/zkp/math.rs	/^    pub fn verify(&self, point: &FieldElement, value: &FieldElement, opening: &FieldElement) -> /;"	P	implementation:PolynomialCommitment
verify	src/zkp/zk_starks.rs	/^    pub fn verify(&self, proof: &ZkStarksProof) -> bool {$/;"	P	implementation:ZkStarksVerifier
verify_block_signature	src/qup/utils.rs	/^pub fn verify_block_signature($/;"	f
verify_candidate_state	src/chain/quantum_voting/quantum_state_verification.rs	/^    pub fn verify_candidate_state($/;"	P	implementation:QuantumStateVerification
verify_certificate	src/chain/certificate_authority.rs	/^    fn verify_certificate(&self, certificate: &X509Certificate) -> bool {$/;"	P	implementation:CertificateAuthorityClient
verify_certificate	src/chain/certificate_authority.rs	/^    pub fn verify_certificate(&self, certificate: &X509Certificate) -> bool {$/;"	P	implementation:CertificateAuthority
verify_compressed_state	src/chain/quantum_voting/compression.rs	/^    fn verify_compressed_state(&self, quantum_state: &QuantumState) -> Result<bool, VotingError>/;"	P	implementation:Compression
verify_compressed_state	src/chain/quantum_voting/quantum_voting.rs	/^    fn verify_compressed_state(&self, quantum_state: &QuantumState) -> Result<bool, VotingError>/;"	P	implementation:QuantumVoting
verify_encoded_data_signature	src/hdcmodels/qup_integration/qup_encoding.rs	/^    pub fn verify_encoded_data_signature($/;"	P	implementation:QUPEncoding
verify_leaf	src/utils/merkle_tree.rs	/^    pub fn verify_leaf(&self, leaf: &Hash, proof: &[Hash]) -> bool {$/;"	P	implementation:MerkleTree
verify_post_quantum_signature	src/chain/transaction.rs	/^    pub fn verify_post_quantum_signature($/;"	P	implementation:Transaction
verify_proof	src/chain/state/merkle_trie.rs	/^    pub fn verify_proof($/;"	P	implementation:MerkleTrie
verify_proposal_integrity	src/chain/governance/proposal.rs	/^    pub fn verify_proposal_integrity(&self, qup_crypto: &QUPCrypto) -> bool {$/;"	P	implementation:Proposal
verify_quantum_merkle_proof	src/zkp/crypto.rs	/^pub fn verify_quantum_merkle_proof($/;"	f
verify_signature	src/chain/block.rs	/^    pub fn verify_signature(&self, qup_crypto: &QUPCrypto) -> Result<(), BlockError> {$/;"	P	implementation:Block
verify_signature	src/chain/state/merkle_trie.rs	/^    pub fn verify_signature(&self, public_key: &[u8]) -> Result<bool, MerkleTrieError> {$/;"	P	implementation:MerkleTrie
verify_signature	src/chain/state/merkle_trie.rs	/^    pub fn verify_signature(&self, public_key: &[u8]) -> Result<bool, MerkleTrieError> {$/;"	P	implementation:TrieNode
verify_signature	src/chain/transaction.rs	/^    pub fn verify_signature($/;"	P	implementation:Transaction
verify_signature	src/network/quantum_resistant.rs	/^    fn verify_signature(&self, message: &[u8], signature: &Signature) -> Result<(), NetworkError/;"	P	implementation:QuantumResistantConnection
verify_signature	src/qup/block.rs	/^    pub fn verify_signature(&self, validator: &QUPValidator) -> bool {$/;"	P	implementation:QUPBlock
verify_signature_recursive	src/chain/state/merkle_trie.rs	/^fn verify_signature_recursive($/;"	f
verify_signatures	src/chain/transaction.rs	/^    pub fn verify_signatures($/;"	P	implementation:Transaction
verify_state_proof	src/chain/state/state_db.rs	/^    pub fn verify_state_proof(&self, address: &str, account: &Account, proof: &[Vec<u8>]) -> boo/;"	P	implementation:StateDB
verify_state_proof	src/chain/state/state_manager.rs	/^    pub fn verify_state_proof(&self, address: &str, account: &Account, proof: &[Vec<u8>]) -> boo/;"	P	implementation:StateManager
verify_state_signature	src/network/sync/state_sync.rs	/^    fn verify_state_signature(&self, state: &ShardState, signature: &Signature) -> bool {$/;"	P	implementation:StateSync
verify_transaction	src/chain/shard.rs	/^    pub fn verify_transaction(&self, transaction: &Transaction) -> Result<(), ShardError> {$/;"	P	implementation:Shard
verify_transaction	src/utils/merkle_tree.rs	/^    pub fn verify_transaction(&self, transaction: &QUPTransaction, proof: &[Hash]) -> bool {$/;"	P	implementation:MerkleTree
verify_transaction_signature	src/qup/utils.rs	/^pub fn verify_transaction_signature(transaction: &QUPTransaction) -> bool {$/;"	f
verify_transactions	src/chain/block.rs	/^    pub fn verify_transactions(&self, secure_vault: &SecureVault) -> Result<(), BlockError> {$/;"	P	implementation:Block
verify_useful_work	src/qup/hdcomm.rs	/^    pub fn verify_useful_work(&self, state: &QUPState, useful_work: &UsefulWork) -> bool {$/;"	P	implementation:HDCommunication
verify_vote_integrity	src/chain/quantum_voting/vote_collection.rs	/^    fn verify_vote_integrity(&self, vote: &Vote, candidate: &Candidate) -> Result<(), VotingErro/;"	P	implementation:VoteCollection
verify_vote_signature	src/chain/quantum_voting/quantum_cryptography.rs	/^    pub fn verify_vote_signature($/;"	P	implementation:QuantumCryptography
verify_vote_signature	src/qup/utils.rs	/^pub fn verify_vote_signature(vote: &QUPVote) -> bool {$/;"	f
verify_vote_state	src/chain/quantum_voting/quantum_state_verification.rs	/^    pub fn verify_vote_state(&self, vote_state: &QuantumState) -> Result<bool, VotingError> {$/;"	P	implementation:QuantumStateVerification
version	src/api/models/request/blockchain_request.rs	/^    pub version: u32,$/;"	m	struct:BlockHeader
version	src/api/models/response/blockchain_response.rs	/^    pub version: u32,$/;"	m	struct:BlockHeader
version	src/qup/types.rs	/^    pub version: u32,$/;"	m	struct:QUPBlockHeader
version	src/smart_contract/types.rs	/^    pub version: String,$/;"	m	struct:SmartContract
vertex_cover	src/qup/types.rs	/^    pub vertex_cover: Vec<usize>,$/;"	m	struct:VertexCoverSolution
view_public_key	src/chain/wallet.rs	/^    pub view_public_key: [u8; 32],$/;"	m	struct:StealthAddress
vote	src/chain/governance/governance_engine.rs	/^    pub async fn vote(&mut self, vote: Vote) -> Result<(), String> {$/;"	P	implementation:GovernanceEngine
vote	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub vote: bool,$/;"	m	struct:SecureHDCModelUpdateVote
vote_counts	src/chain/quantum_voting/voting_state.rs	/^    vote_counts: RwLock<HashMap<String, usize>>,$/;"	m	struct:VotingState
vote_time	src/api/handlers/governance_handler.rs	/^    vote_time: u64,$/;"	m	struct:VoteInfo
vote_time	src/api/routes/governance.rs	/^    vote_time: u64,$/;"	m	struct:VoteInfo
vote_type	src/api/handlers/governance_handler.rs	/^    vote_type: String,$/;"	m	struct:VoteInfo
vote_type	src/api/models/request/governance_request.rs	/^    pub vote_type: VoteType,$/;"	m	struct:CastVoteRequest
vote_type	src/api/routes/governance.rs	/^    vote_type: String,$/;"	m	struct:VoteInfo
vote_type	src/chain/governance/voting.rs	/^    pub vote_type: VoteType,$/;"	m	struct:Vote
voter	src/api/handlers/governance_handler.rs	/^    voter: String,$/;"	m	struct:VoteInfo
voter	src/api/routes/governance.rs	/^    voter: String,$/;"	m	struct:VoteInfo
voter	src/chain/governance/voting.rs	/^    pub voter: String,$/;"	m	struct:Vote
voter	src/hdcmodels/continuous_learning/secure_updates.rs	/^    pub voter: String,$/;"	m	struct:SecureHDCModelUpdateVote
voter	src/qup/types.rs	/^    pub voter: Vec<u8>,$/;"	m	struct:QUPVote
voter_power	src/api/handlers/governance_handler.rs	/^    voter_power: Vec<(String, f64)>, \/\/ (voter, voting_power)$/;"	m	struct:VotingPower
voter_power	src/api/routes/governance.rs	/^    voter_power: Vec<(String, f64)>, \/\/ (voter, voting_power)$/;"	m	struct:VotingPower
votes	src/chain/governance/voting.rs	/^    pub votes: HashMap<u64, Vec<Vote>>,$/;"	m	struct:Voting
voting	src/chain/governance/governance_engine.rs	/^    voting: Arc<Voting>,$/;"	m	struct:GovernanceEngine
voting	src/chain/governance/mod.rs	/^mod voting;$/;"	n
voting_duration	src/chain/quantum_voting/voting_state.rs	/^    voting_duration: u64,$/;"	m	struct:VotingState
voting_end_time	src/api/handlers/governance_handler.rs	/^    voting_end_time: Option<u64>,$/;"	m	struct:ProposalInfo
voting_end_time	src/api/routes/governance.rs	/^    voting_end_time: Option<u64>,$/;"	m	struct:ProposalInfo
voting_period	src/api/handlers/governance_handler.rs	/^    voting_period: u64,$/;"	m	struct:GovernanceParameters
voting_period	src/api/models/request/governance_request.rs	/^    pub voting_period: u64,$/;"	m	struct:GovernanceParameters
voting_period	src/api/routes/governance.rs	/^    voting_period: u64,$/;"	m	struct:GovernanceParameters
voting_protocols	src/chain/quantum_voting/mod.rs	/^mod voting_protocols;$/;"	n
voting_start_time	src/api/handlers/governance_handler.rs	/^    voting_start_time: Option<u64>,$/;"	m	struct:ProposalInfo
voting_start_time	src/api/routes/governance.rs	/^    voting_start_time: Option<u64>,$/;"	m	struct:ProposalInfo
voting_state	src/chain/quantum_voting/mod.rs	/^    voting_state: VotingState,$/;"	m	struct:QuantumVoting
voting_state	src/chain/quantum_voting/mod.rs	/^mod voting_state;$/;"	n
voting_state	src/chain/quantum_voting/quantum_key_management.rs	/^    voting_state: Arc<VotingState>,$/;"	m	struct:QuantumKeyManagement
voting_state	src/chain/quantum_voting/quantum_voting.rs	/^    voting_state: Arc<VotingState>,$/;"	m	struct:QuantumVoting
voting_status	src/chain/quantum_voting/voting_state.rs	/^    voting_status: RwLock<VotingStatus>,$/;"	m	struct:VotingState
voting_threshold	src/api/handlers/qup_handler.rs	/^    voting_threshold: u64,$/;"	m	struct:QUPParameters
voting_threshold	src/api/models/request/qup_request.rs	/^    pub voting_threshold: u64,$/;"	m	struct:QUPParameters
voting_threshold	src/api/models/response/qup_response.rs	/^    pub voting_threshold: u64,$/;"	m	struct:QUPParameters
wallet	src/chain/mod.rs	/^mod wallet;$/;"	n
weights	src/qup/types.rs	/^    pub weights: Vec<u64>,$/;"	m	struct:KnapsackProblem
winning_model_hash	src/api/routes/consensus.rs	/^    winning_model_hash: String,$/;"	m	struct:PoUWState
with_blockchain	src/api/api.rs	/^fn with_blockchain(blockchain: Arc<Blockchain>) -> impl Filter<Extract = (Arc<Blockchain>,), Err/;"	f
with_handshake_timeout	src/network/config.rs	/^    pub fn with_handshake_timeout(mut self, timeout: Duration) -> Self {$/;"	P	implementation:NetworkConfig
with_max_connections	src/network/config.rs	/^    pub fn with_max_connections(mut self, max_connections: usize) -> Self {$/;"	P	implementation:NetworkConfig
with_max_frame_size	src/network/config.rs	/^    pub fn with_max_frame_size(mut self, size: usize) -> Self {$/;"	P	implementation:NetworkConfig
with_max_message_size	src/network/config.rs	/^    pub fn with_max_message_size(mut self, size: usize) -> Self {$/;"	P	implementation:NetworkConfig
with_message_timeout	src/network/config.rs	/^    pub fn with_message_timeout(mut self, timeout: Duration) -> Self {$/;"	P	implementation:NetworkConfig
with_ping_interval	src/network/config.rs	/^    pub fn with_ping_interval(mut self, interval: Duration) -> Self {$/;"	P	implementation:NetworkConfig
with_tls	src/network/config.rs	/^    pub fn with_tls($/;"	P	implementation:NetworkConfig
withdraw	src/chain/governance/treasury.rs	/^    pub fn withdraw(&mut self, amount: u64) -> Result<(), String> {$/;"	P	implementation:Treasury
wrap	src/error_handling/error_utils.rs	/^    fn wrap(self, message: &str) -> Result<T> {$/;"	P	implementation:Result
wrap	src/error_handling/error_utils.rs	/^    fn wrap(self, message: &str) -> Result<T>;$/;"	P	interface:ErrorExt
wrap_error	src/error_handling/error_utils.rs	/^pub fn wrap_error<T, E: Into<Error>>(result: std::result::Result<T, E>, message: &str) -> Result/;"	f
wrap_with	src/error_handling/error_utils.rs	/^    fn wrap_with(self, error: Error) -> Result<T> {$/;"	P	implementation:Result
wrap_with	src/error_handling/error_utils.rs	/^    fn wrap_with(self, error: Error) -> Result<T>;$/;"	P	interface:ErrorExt
write_to_file	src/utils/mod.rs	/^pub fn write_to_file(file_path: &str, content: &str) -> Result<(), std::io::Error> {$/;"	f
xor_data	src/secure_core/security_utils.rs	/^    pub fn xor_data(data1: &[u8], data2: &[u8]) -> Vec<u8> {$/;"	P	implementation:SecurityUtils
zero	src/crypto/quantum_state.rs	/^    pub fn zero() -> Self {$/;"	P	implementation:Complex64
zero	src/zkp/math.rs	/^    pub fn zero(modulus: &BigUint) -> Self {$/;"	P	implementation:FieldElement
zeroize_secret_key	src/chain/quantum_entropy.rs	/^    pub fn zeroize_secret_key(&self, secret_key: &mut SecretKey) {$/;"	P	implementation:QuantumEntropySource
zk_starks	src/zkp/mod.rs	/^mod zk_starks;$/;"	n
zkp_crate	src/main.rs	/^mod zkp_crate;$/;"	n
